ctions, shown as the four options in the resulting node. The Figure shows a path in which kali dal is being cooked on stove S; and chapati on Sz, and the time stamp is 0.3. The lowermost node in the figure represents a state in the search space in which there are two events in the queue Q. One adds the fluent asserting that the kali dal is cooked, and the other, likewise for the chapati. The action AdvanceTime, if applied now, will advance the time by 5 minutes, the smaller of the two durations in the queue, to 5.3. In the resulting node, the chapati will be cooked, the stove S will be free, the dal is cooking on S;, and the event queue still has the cooked daf event with the time stamp 45.3. Sapa is now ready to cook the second chapati on So. The goals are represented as a set of tuples G py, ty , po, to , . 1 SP tp where the i goal p; has to be achieved by the deadline t. A state S (P, M,N, Q, t) satisfies a goal G if for every g, tg G one of the following holds, There exists p;, t P, such that g p; and t; fg, and there is no event in Q that deletes p;. There exists qj, m, t Q that adds g q; at time t; ty and there is no event in Q that deletes it. The search algorithm in Sapa is the A algorithm (see Chapter 5). Like the heuristic search planners we have seen earlier in this chapter, Sapa also uses the notion of relaxation of the problem to arrive at an estimate of the cost involved. In fact, it uses phased relaxation to generate different heuristic functions with a decreasing amount of information gained. Sapa uses a relaxed version of a two level, temporal planning graph. One must keep in mind that a good, or optimal, solution in metric temporal planning could be defined in various ways. One could count the number of actions, or measure the total time the plan needs to execute (or makespan), or minimize the amount of slack in the plan, or minimize the amount of some resources used. In practice, one may want to optimize on a combination of these criteria. This wo