 add its negation. Observe that this approach requires us to abandon the negation by failure closed world assumption and takes us into an open world formulation. Consider the Unstack(A, B) action in the STRIPS domain, which has the proposition On(A, B) in the delete list. The closed world assumption says that if On(A, B) is not present in the state representation, it is false. That requires the algorithm to scan the representation, if testing for the negation was required. Having explicit negated formulas requires us to maintain one of the two, a proposition or its negation, explicitly. Having both would be inconsistent. Having a disjunction of both could represent uncertainty, as we will see below. One can also think of the add effect Clear(B) of the action Unstack(A, B) as a kind of expression of the fact sOn(A, B). And given that only A was on B, one can in fact assert that nothing is on B. This is the way STRIPS handled the frame problem. Thus, Clear(B) xOn(x, B) Vx 7 dOn(x, B). When we have Clear(B) as a precondition for the action, say Stack(C, B), we are really testing the quantified precondition it is equivalent to, which also has a negation in it. Conditional effects do extend the language beyond STRIPS (see (Gazen and Knoblock, 1997), (Koehler et al., 1997), (Anderson et al., 1998)). A conditional effect of an action is an effect that comes into being, only when a specified condition is true. Consider the action of driving a school bus from point A to point B, Drive(bus21, a, b). Also consider the action Board(Person, Bus) with effect n(Person, Bus), and the predicate At(Object, Location). What should be the effects of the action Drive(bus21, a, b)? Conditional effects allow us to say that when the bus is driven from point A to point B then anyone who had boarded the bus will also be at point B. The Drive operator could be represented as (Koehler et al., 1997), Action name: DriveBus Parameters: Bus (type bus); A, B (type Location); X (type Object) Precondi