elaxed temporal planning graph for estimating the heuristic value of a node. The end actions can only be applied after the corresponding start actions have been. This is achieved by adding a dummy precondition to the end actions, and generating it by the corresponding start action. The interesting point about CRIKEY3 is that it tends to separate the decisions concerning which actions to choose from when to schedule those actions. For every start action e the corresponding end action e, can only be applied after its earliest possible completion. As long as this is done, the actual scheduling of actions can be done by a scheduler after a candidate plan has been found. Reasoning with the snap actions enables us to pick the required actions, as illustrated by the following example. Se ae tmin(a) "4 Ss et Py) FIGURE 10.24 The state consistency check used by CRIKEY3. Actions a, 6, and b, have been added to the plan. The earliest action a, can be scheduled now is time point t,. If added the corresponding, STN would have a negative cycle as shown. CRIKEY3 can prune this state itself because the minimum time elapsed after action a started is more than its maximum duration. Consider the Chapati and the SpreadGhee actions described above with the corresponding snap actions C , C,, SG , and SG. The required concurrency is that the SpreadGhee action begins before Chapati ends, and ends after Chapati ends. This is shown in the top part of Figure 10.25 with only the relevant conditions and effects marked. A planner like Sapa that adds complete actions in toto to the plan is unable to schedule the SpreadGhee action at any of the time points it reasons with. The time points available to it are the start times and end times of the Chapati action. It cannot schedule SpreadGhee at the former because its at-end condition will not be met, and neither can it schedule it at the latter time point because its at-start condition is not met. ceeeeeeerstrett Cooking-On Cooked SpreadGhee Cooking