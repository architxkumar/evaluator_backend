dicates used for (onTable ?x - block) describing the situation (holding ?x - block) (clear ?x - block) (armempty) ) Given below are the four kinds of actions defined in the Blocks domain (:action pickup iparameters (2x - block) :precondition (and (onTable ?x) (armempty) (clear ?x)) reffect (and (not (armempty)) (holding ?x) (not (onTable ?x)))) (:action putdown :parameters (2x - block) iprecondition (and (holding ?x)) reffect (and (not (holding ?x)) (armempty) (onTable ?x))) (:action stack iparameters (?x - block ?y - block) iprecondition (and (holding ?x) (clear ?y)) reffect (and (not (holding ?x)) (armempty) (on ?x ?y) (not (clear 2y)))) (:action unstack iparameters (2x - block ?y - block) iprecondition (and (on 2x 2y) (clear 2x) (armempty)) reffect (and (not (on ?x ?y)) (holding ?x) (clear ?y) (not (armempty) ))) We now look at some planning algorithms in the STRIPS domain. The search algorithms developed in the preceding chapters can easily be adapted to the task of planning. We do so in the next section. After that, we look at other ways of searching for a plan. We look at the possibility of starting the search from the goal description. This is known as backward reasoning search. We then describe a way of combining the good features of both, forward and backward search, into an algorithm called Goal Stack Planning. We also look at an approach that seeks to fill in the actions constituting the plan in a nonlinear order, filling in actions as and when we spot their requirement. Such an approach is also described by terms like Plan Space Planning and Partial Order Planning. Following this, we look at some flavours of hierarchical planning that have been developed. In subsequent chapters, we introduce the concepts of domain independent heuristics and look at their applicability in the planning algorithms discussed here. 7.2 Forward State Space Planning Given a state, and given a set of operators, one can determine the actions (or moves) that can be applied in the 