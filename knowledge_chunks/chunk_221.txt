may terminate with the more expensive solution. DFS may terminate before fe) looking at a cheaper solution e) Ne) 6 cc) san o 9 6e a) (2) ,.e 7 o Oo eo 6 oO oO fe) yl cutoff is increased by ) fo) (2) avalue 5 DA may find a e) costlier solution. The extra fe) (costis bounded by 6 FIGURE 5.22 Loss in optimality is bounded by 6. 5.8 Recursive Best First Search (RBFS) One thing that DA suffers from is a lack of sense of direction, since the algorithm searches in a depth-first manner. Another algorithm developed by Richard Korf called Recursive Best First Search (RBFS) also requires linear space, but uses backtracking (Korf, 1993). One can think of the algorithm as heuristic depth-first search in which backtracking occurs when a given node does not have the best OPEN node amongst its successors. The interesting feature is that having explored a path once, if it backtracks from a node, it remembers the f-values it has found. It uses backed up fvalues to update the values for nodes it has explored and backtracked on. The backed up value of a node is given by, Sracked-up (node) f(node) ifnode is a leaf node min foscked-up(Child) child is a successor of node if node is not a leaf node Figure 5.23 depicts the behaviour of RBFS. As shown in the figure on the left, it pursues the middle path from the root node with heuristic value 55, till it reaches a point when all successors are worse than 59, its left sibling. It now rolls back the partial path, and reverts to the left sibling with value 59. It also revises the estimate of the middle node from 55 to 60, the best backed-up values as shown by the upward arrows. From the point of implementation, RBFS keeps the next best value (in Figure 5.23, this is 59) as an upper bound for search to progress further. Backtracking is initiated when all the children of the current node become costlier than the upper bound. Observe that like DFS, it maintains only one path in its memory, thus requiring linear space. Its time complexity is howe