rch space with no solution. In that situation, the above algorithm will loop endlessly. The detailed algorithm given below keeps a count of the number of nodes examined in each call of DBDFS. If the count is the same in two successive cycles, that is no new nodes are generated, the algorithm DFID reports failure. DepthFirstiterativeDeepening (start) depthBound 1 previousCount 0 newNodes YES repeat count 0 open ((start, NIL, 0)) elosed () while not Null (open) do nodePair Head(open) node Head(nodePair) if GoalTest (node) TRUE then return ReconstructPath(nodePair, closed) else closed Cons(nodePair, closed) if Head (Rest (Rest (nodePair))) depthBound then children MoveGen (node) noLoops RemoveSeen (children, open, closed) new MakePairs(noLoops, node, Head (Rest (Rest (nodeP air)))) open Append(new, Tail (open)) count count Length (new) aif previousCount count then newNodes NO previousCount count depthBound depthBound 1 until newNodes NO return No solution found FIGURE 2.29 DF D the algorithm in detail. Thus, the algorithm DFID finds the shortest solution using only linear space. Is there a catch somewhere? In a way there is, but only a small one. The DFID algorithm does a series of searches. In each search, it explores a new level of nodes. But for inspecting these new nodes, it has to generate the tree all over again. That is, for exploring the new level, it has to pay the additional cost of regenerating the internal nodes of the search tree all over again. The question one should ask is how significant is the above cost? The new nodes are the leaves of the search tree at the end of that cycle. What then, is the ratio of the number of internal nodes (the extra cost) to the number of leaves (the new nodes) in a tree? The ratio is the highest for binary trees. The number of internal nodes is just one less than the number of leaves. So, the number of nodes inspected is at most twice as in BFS. In general, for inspecting b? new nodes at level d, one has to inspect (b 1) (