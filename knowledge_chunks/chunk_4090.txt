 the class Pet-Bird provides a path from Fifi to Bird and thus to the answer that Fifi can fly, it provides no information that conflicts with the special case knowledge associated with the class Ostrich, so it should have no affect on the answer. To handle this case correctly, we need an algorithm for traversing the isa hierarchy that guarantees that specific knowledge will always dominate more general facts. In Fig. 9.15(b), we return to a problem we discussed in Section 7.2.1, namely determining whether Dick is a pacifist. Again, we must traverse multiple instance links, and more than one answer can be found along the paths. But in this case, there is no well-founded basis for choosing one answer over the other. The classes that are associated with the candidate answers are incommensurate with each other in the partial ordering that is defined by the DAG formed by the isa hierarchy. Just as we found that in Default Logic this theory had two extensions and there was no principled basis for choosing between them, what we need here is an inheritance algorithm that reports the ambiguity; we do not want an algorithm that finds one answer (arbitrarily) and stops without noticing the other. One possible basis for a new inheritance algorithm is path length. This can be implemented by executing a breadth-first search, starting with the frame for which a slot value is needed. Follow its instance links, then follow isa links upward. If a path produces a value, it can be terminated, as can al! other paths once their length exceeds that of the successful path. This algorithm works for both of the examples in Fig. 9.15. In (a), it finds a value at Ostrich. It continues the other path to the same length (Per-Bird), fails to find any other answers, and then halts. In the case of (b), it finds two competing answers at the same level, so it can report the contradiction. Bird fly: yes isa 7 isa Ostrich Quaker Republican fly :no Pet-Bird pacifist : true pacifist : false instance, < 