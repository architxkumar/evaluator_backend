ponding to its successor rather than to the new one. The new one can simply be thrown away. (b) If you are keeping track of the best (shortest or otherwise least-cost) path to each node, then check to see if the new path is better or worse than the old one. If worse, do nothing. If better, record the new path as the correct path to use to get to the node and propagate the corresponding change in cost down through successor nodes as necessary. One problem that may arise here is that cycles may be introduced into the search graph. A cycle is a path through the graph in which a given node appears more than once. For example, the graph of Fig. 2.19 contains two cycles of length two. One includes the nodes (0, 0) and (4, 0); the other includes the nodes (0, 0) and (0, 3), Whenever there is a cycle, there can be paths of arbitrary length. Thus it may become more difficult to show that a graph traversal algorithm is guaranteed to terminate. Treating the search process as a graph search rather than as a tree search reduces the amount of effort that is spent exploring essentially the same path several times. But it requires additional effort each time a node is Problems, Problem Spaces, and Search 47 _s Smiacasanenteasnr ceo uaa tezun Cn N esa ome ERANS generated to see if it has been generated before. Whether this effort is justified depends on the particular problem; If it is very likely that the same node will be generated in several different ways, then it is more worthwhile to use a graph procedure than if such duplication wil! happen only rarely. Graph search procedures are especially useful for dealing with partially commutative production systems in which a given set of operations will produce the same result regardless of the order in which the operations are applied. A systematic search procedure will try many of the permutations of these operators and so will generate the same node many times. This is exactly what happened in the water jug example shown above. 2.6