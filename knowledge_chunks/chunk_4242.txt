n and graph unification. The inputs to logical unification are treated as logical formulas. Order matters, since, for example, f(g(@), A(b)) is a different formula than f(h(b), g(a)). The inputs to graph unification, on the other hand, must be treated as sets, since the order in which attribute-value pairs are stated does not matter. For example, if a rule describes a constituent as {CAT: DET LEX: {1}] we want to be able to match a constituent such as [LEX: the CAT: DET] Algorithm: Graph-Unify 1. If either G, or G, is an attribute that is not itself an attribute-value pair then: (a) If the attributes conflict (as defined above), then fail. (b) If either is a variable, then bind it to the value of the other and return that value. (c) Otherwise, return the most general value that is consistent with both the original values. Specifically, if disjunction is allowed, then return the inter section of the values. 300 Artificial Intelligence eo e R encase 2. Otherwise, do: (a) Set variable NEW to empty. (b) For each attribute A that is present (at the top level) in either Gl or G2 do (i) If A is not present at the top level in the other input, then add A and its value to NEW. (ii) If it is, then call Graph-Unify with the two values for A. If that fails, then fail. Otherwise, take the new value of A to be the result of that unification and add A with its value to NEW. (c) If there are any labels attached to G1 or G2, then bind them to NEW and retumn NEW. A simple parser can use this algorithm to apply a grammar rule by unifying CONSTITUENT | with a proposed first constituent. If that succeeds, then CONSTITUENT2 is unified with a proposed second constituent, H that also succeeds, then a new constituent corresponding to the value of BUILD is produced. If there are variables in the value of BUILD that were bound during the matching of the constituents, then those bindings will be used to build the new constituent. There are many possible variations on the notation we have descr