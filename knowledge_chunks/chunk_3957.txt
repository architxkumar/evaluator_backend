wed, namely as a program, rather than as data to a program. In this view, the implication statements define the legitimate reasoning paths and the atomic assertions provide the starting points (or, if we reason backward, the ending points) of those paths. These reasoning paths define the possible execution paths of the program in much the same way that traditional control constructs, such as if-then-else. define the execution paths through traditional programs. In other words, we could view logical assertions as 130 Artificial Intelligence ss RN TEE END SESE PSE TRETP, procedural representations of knowledge. A procedural representation is one in which the control information that is necessary to use the knowledge is considered to be embedded in the knowledge itself. To use a procedural representation, we need to augment it with an interpreter that follows the instructions given in the knowledge. Actually, viewing logical assertions as code is not a very radical idea, given that all programs are really data to other programs that interpret (or compile) and execute them. The real difference between the declarative and the procedural views of knowledge lies in where control information resides. For example, consider the knowledge base: man(Marcus) man(Caesar) person(Cleapatra) Vx: man(x) 3 person(x) Now consider trying to extract from this knowledge base the answer to the question dy : person(y) We want to bind y to a particular value for which person is true. Our knowledge base justifies any of the following answers: y = Marcus y = Caesar y = Cleopatra Because there is more than one value that satisfies the predicate, but only one value is needed, the answer to the question will depend on the order in which the assertions are examined during the search for a response. If we view the assertions as declarative, then they do not themselves say anything about how they will be examined. If we view them as procedural, then they do. Of course, nondeterministic programs are 