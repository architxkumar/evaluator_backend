ther solutions for X. Now, inspect the modified program below: 504 Artificial intelligence likes(prakash, X) :-edible(X), tastes(X, sweet),write(X),nl fail. tastes( chocolates,sweet). tastes( gourd, bitter). tastes(toffees, sweet}. edible(chocolates). edible(toffees). edible( gourd). Note that we have added a new term called fail which effectively returns all possible answers one after the other. After the value of X has been bound to chocolates (as in the previous explanation) the next thing it encounters is a write(X)} which writes the currently bound value of X. The ni forces a newline. Finally fail forces the PROLOG engine to imagine that the right hand side is not true though all previous clauses have succeeded in finding an apt value for X. fail thus makes the system feel that it has not succeeded in its attempt to satisfy a goal and therefore forces it to backtrack to the previous fork and find the next alternative solution for X. fail can be used when one needs to perform an exhaustive search of a tree and not just deliver a single instance of the correct solution. In other words the goal succeeds in finding all possible solutions by failing each time! Thus, when we issue the goal: | ?- likes(prakash, X). here is what you get chocolates toffces no The final no crops up because after all solutions (two in this case) are found, the last search for another solution fails due to the fail! This can be avoided by allowing an automatic success after the final failure of likes. Insert an additional terminating clause for likes as shown below. likes(prakash, X) :-edible(X), tastes(X, sweet), write(X),nl fail. likes(_,_). /*Terminating condition*/ tastes( chocolates,sweet), tastes( gourd, bitter). tastes(toffees, sweet). edible(chocolates). edible(toffees). edible(gourd). After all possible values of K have been found the second clause is triggered which in plain English states that Anyone likes anyone. Now try to interpret what would happen if this clause were to be 