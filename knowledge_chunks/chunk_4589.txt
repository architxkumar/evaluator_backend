cate takes in a single character in ASCII directly from the keyboard while the string _chars/2 predicate converts the input into a regular string which is displayed by write. The second argument of the latter predicate has to be a list which is why the variable Ch is presented as a list, a structure discussed in the next section. Both grab and string chars ase LPA PROLOG specific. You can always find the equivalent of these predicates from the documentations of the PROLOG compiler you are using. The more important issue here is the role played by the predicate redo. As is obvious, the clauses for redo form a recursive loop. If you try to issue the goal as- : | j | | PROLOG - The Natural Language of Artificial Intelligence 507 sr m ER TET NETTIE LT UNRATE redo. you will find that the program succeeds. This is so because the very first clause for redo itself says it is true. However things work to our benefit in the above program. Let us understand the working of the latter part of the above program. For the goal -getinput., the sequence of execution of subgoals is given below: (a) Execute redo which is essentially true. (b) Read a character from the keyboard and bind it to the variable Ch. (c) Convert it into a string form. (d) Display the character. (e) Check whether the input is the Enter key (ASCII code 13). (f) If yes, then it s a success; so quit. E]se backtrack to find alternatives of the previous subgoals. Since none of the predicates - write, string_chars or grab have alternatives, backtracking is done all the way back to redo. This has an alternative path (its second clause) which also says redo. This causes it to verify the truth of redo (again). Naturally this succeeds thanks to the first clause for redo which is unconditionally true as in step (a). (g) Since the alternative path for redo has succeeded, carry on performing the sequence starting from step (b). We now inspect some other typical PROLOG programs that use recursion. Down-counting:; The followin