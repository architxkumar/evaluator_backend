 of the form (rulename timestamp, timestampo... timestamp,). Where the timestamp; is the sequence number used to identify the WME matching the corresponding pattern in the rule. That is, the Conflict Set contains a set of rules that are ready to fire along with their matching WMEs. 2. Resolve Select one element from the Conflict Set. That is, decide what rule is going to fire with its data. 3. Execute Execute (or fire) the selected rule. Make the appropriate changes in the WM, and also do any Input Out that is indicated. Then go back to step 1. The most straightforward task in the above cycle is step 3. It simply involves executing the instructions in the RHS of the rule. The other two steps need considerable attention because they determine the problem solving efficiency. The second step RESOLVE is the one that deploys the problem solving strategy in OPS5. The Match-Resolve-Execute cycle of rule based systems can be viewed as doing hill climbing search in a (dynamic) state space. The Match step is equivalent to applying the moveGen function (see Chapter 2) to a given state. It generates the possible changes one can make to the state. The Resolve step embodies the strategy of search. It decides which of the candidate moves should be applied. That is, which rule in the CS should be selected to fire. One strategy to select the move (rule instance with matching data) is some fixed strategy like the first (in order of writing) rule matching. This would be akin to doing depth first search in the state space. In practice, rule based systems employ some more sophisticated strategies. For example, OPS5 uses the following criteria, in order of application, to order the Conflict Set (CS). Refractoriness This says that a given rule will fire only once with a given combination of data. This prevents the same rule from firing again and again with the same data, when the RHS does not change the data. For example, the rule named top-card above will fire only once with the given da