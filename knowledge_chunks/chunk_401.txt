ords, or must identify a part of a word from her letters, such that the remaining letters are in place on the board already. In both cases, one must ensure that the move does not result in any sequence of letters on the board that is not a legal word. Move generation is thus a critical part of a Scrabble program. Bridge Bridges Bridging Bride Brim Chess Cheque Check Checking Pay Play Paying Playing Plan Planning Plane FIGURE 8.40 A sample trie data structure for the set of words in the box on the right. The darker nodes represent legal words. Appel and Jacobson (1988) use the DAWG structure to implement a fast move generator. Their algorithm first scans the current board looking for places where a word might be formed connecting to existing letters. Then it attempts to build words using letters on the rack and the letters near the chosen spot. Before searching for words, the program computes a cross-check for every existing word. If the program is searching for horizontal words then it precomputes what letters are feasible in the squares above and below an existing down word. For example, as shown in Figure 8.41, if a horizontal word is to be placed occupying one of the squares marked ? then one could use a P on the upper square or an R in the lower one while making the new word. The set of allowable letters can be represented as a 26-bit vector, with one bit for each letter in the alphabet. Changes in these values will be few during each move of the game. In addition, the program precomputes anchor squares on the board where a move may be made. Anchor squares are empty squares next to existing letters where a word may be made. Note that squares marked ? in the figure are also anchor squares. As described in (Appel and Jacobson, 1988): The move generation problem is thus reduced to the following one-dimensional problem: given a rack of tiles, the contents of a row on the board, and the cross-checks and anchors for the row generate all legal plays in that row. Each w