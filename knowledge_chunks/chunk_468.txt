 strategies that can foresee the dead end a little earlier. The degree of foresight is dependent on the amount of work the algorithm does analysing future variables. Vanables Go: Vv D g m B b b g b g 6 F r r r r r r w w i Elgir r gr i g r r g Lr w A r 6 r b r b r r r b c b FIGURE 9.34 The search tree explored by algorithm Backtracking for the CSP in Fig. 9.33 when it finds the first solution. Each node represents a value for the variable listed on the left. The dashed edges indicate nodes not explored by the algorithm. 9.7 Lookahead Strategies The lookahead strategies we are about to look at, do some amount of consistency checking when considering a value for a variable inside the SelectValue procedure of Figure 9.32. In general, the lookahead procedures we discuss, prune the domains of future variables during the process of selecting a value for the variable. They reject the value being considered for the variable if it can be determined that some future domain has become empty. The domains have to be carefully maintained. The procedure for selecting values should undo any changes to future domains it has made before finding the current value unfit. Likewise, the main procedure must also undo such pruning if it has to backtrack from a given variable. In the programs below, we assume that the domains and any copies that we make are global and visible to all procedures. In practice, one could package the needed domains into a structure and pass them as a parameter. We use a generalized lookahead algorithm that will call different versions of SelectValue-X for varying degrees of propagation (in the style of (Dechter, 2003)). The algorithm is described in Figure 9.34. Since the SelectValue-X procedure will prune future domains, removing values variously inconsistent with the value being considered, the main algorithm needs to be able to restore the values if it backtracks. In the algorithm below, this is done by maintaining copies of al! domains at each level in the se