rograms ari,d . therefore, is not recommended for general use. ,\ri e;irnplc of it function like riirmih ( iiieiiiher) which uses iteration. will illustrate this usc he iiinn Iunitiorr iiietrmh requires two aqguillelu,. all clenicrit and a list - )i1),irr rriemb (el 1st) lproq () start (cond beqoat el (car 1st)) (return ISM) )setq Est (cdr 1st)) (go start))) MEMB Note that prog used here requires no local variables Also note the label start, the transfer (loop back) point for the go statement. The second clause of tlic cond executes when the first clause is skipped because setq is non-nil! Sec. 3.5 Iteration and Recursion 33 3.5 ITERATION AND RECURSION Iteration Constructs We saw one way to perform iteration using the prog construct in the previous SCCI1OR. In this section. we introduce it structured turin of' iteration with the do construct, which is somewhat like the while loop in Pascal. The do statement hs the form (o( , var, vat, - -.var-update,>) (-var2 va I7 <var-update2>) (<test, <re*urn-value'-) ks-expressions>)) The vale are initial values which are all evaluated and then bound to the Corresponding variables var, in parallel. Following each such statement are optional update statements which define how the var, are to be updated with each iteration. After the variables are updated during an iteration, the test is evaluated, and if it returns non-nil (true). the r Cturn-value is evaluated and returned. The s-expressions forming the body of the construct are optional. If present, they are executed each iteration until an exit test condition is encountered. An example of the factorial function will illustrate the doconstruct. - (defun facto,a I (n) (do ((count n (- count 1)) (product n ( product ICount II) ((equal 0 count) produsct((( r ACTORIAt. In this definition there is no need to include it body. All operations required to compute the factorial of it are contained in the initial values and the update procedures. There is also a do* Construct which is the