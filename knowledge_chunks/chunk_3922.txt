ght associated with adult males and a different height associated with baseball players. Our procedure for manipulating the isa hierarchy guaranteed that we always found the correct (i.e., most specific) value for any attribute. Unfortunately, reproducing this result in logic is difficult. Suppose, for example, that, in addition to the facts we already have, we add the following.! Pompeian(Paulus) - [leyalto(Paulus, Caesar) \/ hate(Paulus,Caesar)] For convenience, we now return to our original notation using unary predicates to denote class relations. Using Predicate Logic 105 In other words, suppose we want to make Paulus an exception to the general rule about Romans and their feelings toward Caesar. Unfortunately, we cannot simply add these facts to our existing knowledge base the way we could just add new nodes into a semantic net. The difficulty is that if the old assertions are left unchanged, then the addition of the new assertions makes the knowledge base inconsistent. In order to restore consistency, it is necessary to modify the original assertion to which an exception is being made. So our original sentence 5 must become: Vx: Roman(x) \neq(x, Paulus) > loyalto(x,Caesar) \/ hate(x,Caesar) In this framework, every exception to a general rule must be stated twice, once in a particular statement and once in an exception list that forms part of the general rule. This makes the use of general rules in this framework less convenient and less efficient when there are exceptions than is the use of general rules in a semantic net. A further problem arises when information is incomplete and it is not possible to prove that no exceptions apply in a particular instance. But we defer consideration of this problem until Chapter 7. 5.3 COMPUTABLE FUNCTIONS AND PREDICATES In the example we explored in the last section, all the simple facts were expressed as combinations of individual Predicates, such as: tryassassinate(Marcus, Caesar) This is fine if the number of facts is