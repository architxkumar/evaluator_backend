n CLOSED OLD and add OLD to the list of BESTNODE , successors. Check to see if the new path or the old path is better just as in step 2(c), and set the parent link-and g and f values appropriately. Jf we have just found a better path to OLD, we must propagate the improvement to OLD s successors. This is a bit tricky. OLD points to its successors. Each successor in turn points to its successors, and so forth, until each branch terminates with a node that either is still on OPEN or has no successors. So to propagate the new cost downward, do a depth-first traversal of the tree starting at OLD, changing each node s g value (and thus also its f value), terminating each branch when you reach either a node with no successors or a node to which an equivalent or better path has already been found,* This condition is easy to check for. Each node s parent link points back to its best known parent. As we propagate down to a node, see if its parent points to the node we are coming from. If so, continue the propagation. If not, then its g value already reflects the better path of which it is part. So the propagation may stop here. But it is possible that with the new value of g being propagated downward, the path we are following may become better than the path through the current parent. So compare the two. If the path through the current parent is still better, stop the propagation. If the path we are propagating through is now better, reset the parent and continue propagation. If SUCCESSOR was not already on either OPEN or CLOSED, then put it on OPEN, and add it to the list of BESTNODE s successors. Compute f (.SUCCESSOR) = g(SUCCESSOR) + h'(SUCCESSOR). Several interesting observations can be made about this algorithm. The first concerns the role of the g function. It lets us choose which node to expand next on the basis not only of how good the node itself looks (as measured by / ), but also on the basis of how good the path to the node was. By incorporating g into f . we wi