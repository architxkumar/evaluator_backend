 with statements in predicate logic. Resolution is such a procedure, which gains its efficiency from the fact that it operates on statements that have been converted to a very convenient standard form, which is described below. Using Predicate Logic 109 naalive( Marcus, now) T (9, substitution) dead Marcus, now) T (7, substitution) mortal Marcus) /\ born( Marcus, t,) \ gt(now t,, 150) T (4, substitution) man(Marcus) /\ born(Marcus, t,) /\ gt(now t,, 150) T (1) born( Marcus, t,) /\ giinow t,, 150) T (3) gtinow 40,150) T (8) gt{1991 40,150) t T (compute minus) gt{1951,150) T (compute gt) nil Fig. 5.6 Another Way of Proving That Marcus is Dead Resolution produces proofs by refutation. In other words, to prove a statement (i.e., show that it is valid), resolution attempts to show that the negation of the statement produces a contradiction with the known statements (i.e,, that it is unsatisfiable). This approach contrasts with the technique that we have been using to generate proofs by chaining backward from the theorem to be proved to the axioms. Further discussion of how resolution operates will be much more straightforward after we have discussed the standard form in which statements will be represented, so we defer it until then. 5.4.1 Conversion to Clause Form Suppose we know that all Romans who know Marcus either hate Caesar or think that anyone who hates anyone is crazy. We could represent that in the following wff: Vx: [Roman(x) /\ know(x, Marcus)] > [hate(x, Caesar) \/ (Vy : dz: hate(y, 2) > thinkcrazy(x, y))] To use this formula in a proof requires a complex matching process. Then, having matched one piece of it, such as thinkcrazy(x,y), it is necessary to do the right thing with the rest of the formula including the pieces in which the matched part is embedded and those in which it is not. If the formula were in a simpler form, this proc;ess would be much easier. The formula would be easier to work with if It were flatter, i.e., there was less embedding of com