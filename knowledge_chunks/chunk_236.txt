growing only linearly with depth, but at the cost of completeness. The idea of a beam stack to do additional bookkeeping allows the Beam Stack Search to backtrack even after finding the first solution and look for a better one. This gives us an anytime algorithm that can be called upon to return a (good) solution on demand, along with the option to wait for the optimal solution. Combining the two ideas of Divide and Conquer reconstruction and the Beam Stack systematic search, gives us an algorithm DCBSS with almost constant space requirements. Thus, one can tackle arbitrarily large search spaces. All the above algorithms save on space as compared to A , but at the cost of extra running time. Every practical problem to be solved could use a variation that makes an appropriate trade off. The algorithms seen so far view the problem solving process as a trajectory in some space, starting with a given situation and finding a path towards the solution. Each move transforms the entire representation, state or solution, to a different one. In the next chapter, we look at an approach in which a problem can be broken down into smaller problems, each of which can be attempted independently. e A Exercises 1. Figure 5.33 below shows the graph being explored by algorithm A at the point when node N is about to be expanded. The shaded double circles represent nodes on CLOSED, and the unshaded circles represent nodes on OPEN. Values inside the circles represent gvalues of nodes. The two nodes marked New in dashed circles are about to be put on OPEN. The arrows depict back pointers and labels on edges denote costs. Redraw the graph after A has finished expanding the node N. New New FIGURE 5.33 A is about to expand node N in the above graph. How will the resulting graph look like? 2. Given the two graphs from Chapter 3 reproduced below, the task is to find an optimal path from the start node S to the goal node G. The length of each edge is marked on the graph. Use the Manhattan distan