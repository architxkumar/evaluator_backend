the alternative path for redo has succeeded, carry on performing the sequence starting from step (b). We now inspect some other typical PROLOG programs that use recursion. Down-counting:; The following program counts down from N to 0. count(0). count(N):- write(-Old N=), write(N),nl, Niis N-I, write( New N=),write(N1),nl, count(N}). Note that expression N/ is N-/ is equivalent to the statement NV = N-/ in conventional languages. Interestingly, if you replace it with N = N-1, PROLOG behaves differently. This is because it tries to verify whether the left hand side and right hand side are equal, which is never so. (What if we use N = N-1? Try and find out!) When the goal count(5) is given the first clause for count fails making it backtrack to its second clause. This decrements N and again calls count with N=4. The process continues till MN equals zero and the first clause succeeds. Now try to explain what would happen if we rewrite the same program as count(O). count{N):- write( Old N= ~),write(N), ni, Nlis N-i, count(NI), niwrite((New N= ~) write(N 1). Factorial of a number A simple version of the program is shown below: 508 Artificial Intelligence Cee eel factorial{1,1):-1. factorial(N, Fact_of_N):- Q is N-1, factorial(Q, Fact_of_Q), write( Fact_of_Q),nl, Fact_of_N is N*Fact_of_Q. The first clause obviously states that factorial of | is 1. The cut ensures that this is the dead-end. The second decrements N and recursively, calls factorial. The process continues till NW becomes | and the first clause terminates the recursion. The rest is mere unwinding by cumulatively multiplying 1 with 2, 2 with 3,6 with 4 and so on. Run the program by giving the goal factorial(4,X) and inspect the output. Another version of the program for computing the factorial of a number is given below: factorial(N, Fact_of_N):- factorial(N, Fact_of_N, 1, 1). factorial(N, Fact_of_N, N, Fact_of_N):-!. factorial(N, Fact_of_N, I, J):- Nextl is +], Nextt is J*Nextl, factorial(N, Fact_of_N,Nextl,Nex