orking them. In backward or goal-directed reasoning, we naturally break up the goal into subgoals and tackle each separately. This leads to the And Or search for finding the decompositions that make up the solution. We will revisit goal-directed reasoning again in Chapter 7 on planning, and Chapter 12 on logic and theorem proving. The mechanism used for problem decomposition was production systems, in which each goal is replaced by a set of subgoals and the subgoals have choices for solving them. But the process of reasoning in production systems is aligned with the arrow, from the left-hand side to the right-hand side. That is, the forward direction. We could use the forward chaining mechanism for goal-directed reasoning too, because we expressed the goal, subgoal relationship in this particular manner. We will visit backward chaining in the chapters on planning and theorem proving. Meanwhile, production systems found their applicability in forward reasoning as well. In forward or data-driven reasoning, we move from the given situation and transform it into the desired situation. Systems using data-driven reasoning have also been called pattern-directed inference systems (Waterman and Hayes-Roth, 1978). In many situations, datadriven reasoning is more appropriate, as was shown by the XCON system. token in class base class top surbace spherical surface plane J surface curved y colour colour black green block x greenPyramid rule cylinder rule Sn alee ' 921012 wand rule e All joins on equality of variable x Figure 6.22 A Rete net for the example problem, with the given WMEs. The rectangular boxes are alpha nodes accepting WMEs that satisfy the test condition. Beta nodes are represented as circles. They hold WMEs waiting for matching ones to arrive, and pass them on when they do. The language OPS5, and its derivates OPS83 and SOAR (Laird et al., 1987), employs the forward-chaining process to implement a programming language. The syntax of the rules are fixed by the lan