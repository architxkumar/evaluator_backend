terminate. If it is the latter, the ExtractPlan memoizes the failed goal set. This is a kind of nogood learning that can be exploited in future (backward) searches. If a failed goal set is regressed to, in the future the algorithm can immediately backtrack from there without trying to solve it. The algorithm ExtractPlan is described in Figure10.10. The procedure RegressGoalSet, called in line 1, returns SetOfSubGoalSets the set of possible subgoal sets along with the actions that regress to them as illustrated in Figure 10.8. Each element of the returned set is a pair Actions;, Subgoals;-, , where Actions; is the set of nonmutex actions that regress to the nonmutex set of propositions Subgoals; , in the previous layer. The procedure, which is left as an exercise for the reader, tries all combinations of relevant actions (see Chapter 7) that can be chosen in the goal-set layer, such that they achieve the goal set in a nonmutex manner. This set of actions may include No-op actions as well. We also assume two functions, Memoize and Memoized, that manage a memoization memory called mem. This memory could be implemented in various ways, for example as list structures or as hash tables. Memoize(goalSet, i, mem) adds a set of goals goa Set that cannot be solved together at layer i to the memory, and Memoized checks the memory mem to find out whether a goal set is marked as failed at level i. Lines 6-16 implement a backtracking based search algorithm that tries all options in setOfSubgoalSets one by one. Line 11 checks for the base case in recursion, in which the goal-set layer is P;. The actions, which have been tested to be nonmutex in the call to RegressGoalSet are returned as the plan. Note that these happen in parallel, or can be linearized in any order. Otherwise, in line 12, a recursive call is made to ExtractPlan. f the recursive call finds a subplan, it is appended to the actions that generated the subgoal set and returned as a plan. If the subplan was nix then whi