. That is, every time a node is expanded, it is put on a tabu list of all its successors. And when a node is expanded, only the non-tabu successors are generated. As a consequence, every arc in the search graph is traversed only once, and only in one direction. In this way, search can be constrained to only move forward . An algorithm that uses this approach is called Divide-andConquer Frontier Search (DCFS) (Korf and Zhang, 2000). Along with every node on OPEN, the algorithm DCFS keeps a list of disallowed moves. The list CLOSED, therefore, is no longer needed to prevent the search from leaking back. The second task of reconstructing the path when the goal is found still remains. DCFS addresses this problem by storing a relay node around the halfway mark in the search space for every node on OPEN. The halfway point could be approximately determined when the g-value is close to the h-value for a node. Every node on OPEN that is beyond the halfway mark keeps a pointer to its relay node Relay, as shown in the Figure 5.24. Note that different nodes on OPEN may have different relay nodes. Relay nodes mark a landmark roughly halfway on the path 0 on ; Oo 00 DOO FIGURE 5.24 Divide-and-Conquer uses relay nodes to remember landmarks. When the DCFS algorithm picks the goal node, it knows the cost of the solution, but not the path. It has only a pointer to the relay node (Relay) on its path, roughly on the halfway mark. To determine the path, DCFS is recursively called twice; once to find the path from Start to Relay, and next to find the path from Relay to Goal. It has divided the search problem into two parts. This process of recursive calls continues, till the entire path is reconstructed. The algorithm thus saves on space at the expense of running time. If T(d) is the time required to search a path of length d then DCFS has a time complexity given by, T(d) 2 T(d 2) 4 T(d 4) ... k T(d k), where in the last term, d k 1. The reader can verify that the above sums up to 7(d) g