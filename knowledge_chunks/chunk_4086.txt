r any of that slot s generalizations. Unfortunately, although this model of slots is simple and it is internally consistent, it is not easy to use. So we introduce some notational shorthand that allows the four most important properties of a slot (domain, range, definition, and default) to be defined implicitly by how the slot is used in the definitions of the classes in its domain. We describe the domain implicitly to be the class where the slot appears. We describe the range and any range constraints with the clause MUST BE, as the value of an inherited slot. Figure 9.12 shows an example of this notation. And we describe the definition and the default, if they are present, by inserting them as the value of the slot when it appears. The two will be distinguished by prefixing a definitional value with an asterisk (*). We then let the underlying bookkeeping of the frame system create the frames that represent slots as they are needed. ML-Baseball-Player bats : MUST BE {Left, Right, Switch} Fig. 9.12 A Shorthand Notation for Slot-Range Specification Now l Iet s took at examples of how these slots can be used. The slots bats and my-manager illustrate the use of the fo-compute attribute of a slot. The variable x will be bound to the frame to which the slot is attached. We use the dot notation to specify the value of a slot of a frame. Specifically, x.y describes the value(s) of the y slot o* frame x. So we know that to compute a frame s value for my-manager, it is necessary to find the frame s value for team, then find the resulting team s manager. We have simply composed two slots to form a new one.* Computing the value of the bats slot is even simpler. Just go get the value of the handed slot. The manager slot illustrates the use of a range constraint, It is stated in terms of a variable x, which is bound to the frame whose manager slot is being described. It requires that any manager be not only a person but someone with baseball experience. It relies on the domain-s