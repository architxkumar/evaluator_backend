tions between complex entities, and the like. The representations will be given in one or more of the formalisms like FOPL, networks, or some other scheme, and matching will invoke comparing the component parts of such structures. Matching is used in a variety of programs for different reasons. It may serve to control the sequence of operations. to identify or classify objects, to determine 188 Sec. 10.1 Introduction 189 the best of a number of different alternatives, or to tetrieve items from a data base. It is an essential operation in such diverse programs as spee'ch recognition, natural language understanding, vision, learning, automated reasoning, planning, automatic programming, and expert systems, as well as many others. In its simplest form, matching is just the process of comparing two structures or patterns for equality. The match fails if the patterns-differ in any aspect. For example, a match between the two character strings acdebt'ba and acdebeha fails on an exact match since the strings differ in the sixth character positions. In more complex cases the matching process may permit transformations in the patterns in order to achieve an equality match. The transformation may be a simple change of some variables to constants, or it may amount to ignoring some components during the match operation. For example, a pattern matching variable such as ?x may be used to permit successful matching between the two patterns (a b (c d) e) and (a b ?x e) by binding ?x to (c d). Such matchings are usually restricted in some way, however, as is the case with the unification of two clauses where only consistent bindings are permitted. Thus, two patterns such as (a b (cd ) e f) and (a b ?x e ?x) would not match since ?x could not be bound to two different constants. in some extreme cases, a complete change of representational form may be required in either one or both structures before a match can be attempted. This will be the case, for example, when one visual object i