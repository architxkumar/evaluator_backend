t) A gt(t, - t,, 150) > dead(x, t) now = 1991 Vx: Vt [alive(x, ) > -dead{x, 9] /\ [-dead(x, > alive(x, f] Vx: Vt 2 Vi, : died(x, ) A ott, t) > dead(x, t) Fig. 5.4 A Set of Facts about Marcus PO MNADRON = To answer that requires breaking time up into smaller units than years. If we do that, we can then add rules that say such things as One is dead at time (year I, month 1) if one died during (year J, month 1) and month 2 precedes month 1]. We can extend this to days, hours, etc., as necessary. But we do not want to reduce all time statements to that level of detail, which is unnecessary and often not available. A summary of all the facts we have now represented is given in Fig. 5.4. (The numbering is changed slightly because sentence 5 has been split into two parts.) Now let s attempt to answer the question Is Marcus alive? by proving: nalive(Marcus, now) Two such proofs are shown in Fig. 5.5 and 5.6. The term nil at the end of each proof indicates that the list of conditions remaining to be proved is empty and so the proof has succeeded. Notice in those proofs that whenever a statement of the form: a Nboc was used, a and b were set up as independent subgoals. In one sense they are, but in another sense they are not if they share the same bound variables, since, in that case, consistent substitutions must be made in each of them. For example, in Fig. 5.6 look at the step justified by statement 3. We can satisfy the goal 108 Artificial Intelligence esa AN AAPOR OGRE ITER OHHESAOCTY born(Marcus, t,) using statement 3 by binding A to 40, but then we must also bind A to 40 in gt(now t), 150) since the two t, s were the same variable in statement 4, from which the two goals came. A good computational proof procedure has to inchide both a way of determining that a match exists and a way of guaranteeing uniform substitutions throughout a proof. Mechanisms for doing both those things are discussed below. nalive(Marcus, now) t (8, substitution) dead Marcus, now) t T (10, subs