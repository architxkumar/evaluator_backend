 its preconditions must hold at time (t 1)'2. This is expressed as a clause (a; D precond(a);-1) where precond(a) is the conjunction of the preconditions of action a. For example we have, (UnSt(A, B, t) D (On(A, B, t 1) A ArmEmpty(t-1) A Clear(A, t - 1)). 4. For every fact fin level t, a disjunction of the actions that have f in their add effects is implied. For example, in some layer it might be, Holding(A, t) PkUp(A, t) V (Unstack(A, B, t) V (Unstack (A, C, t) V No-op. The actions that participate in the disjunction are determined by the planning graph. 5. Actions that are mutex define clauses in the SAT. For example in the planning graph of Figure 10.4, we have, (7PkUp(C, 0)V 7UnSt(A, B, 0)). Note that going backwards from the goal layer in the planning graph, an action only implies its preconditions and not its effects. Also a fact (fluent) implies an action that achieves it, in a manner similar to that of the explanatory Frame axioms. As reported in (Kautz and Selman, 1999), the above encoding of the planning graph is followed by a logical simplification algorithm that runs in polynomial time. This algorithm converts the encoding into CNF (Conjunctive Normal Form) and simplifies it by doing a limited amount of logical inference for mutex propagation. Kautz and Selman observe that the use of an intermediate plan graph representation appears to improve the quality of automatic SAT encodings of STRIPS problems. 10.3.3 Encoding Causal Links In Chapter 7, we had looked at an approach for searching for plans in the plan space. The basic idea behind the partial order planning systems was to identify flaws in a partial plan and find operators to resolve those flaws. The flaws were of two kinds. The first, open goals, for which we needed either to find an existing action in the plan to support them, or insert a new action into the plan. The second, threats, which could possibly disrupt a support for a goal, had to be dealt with by separating the threatening action, or m