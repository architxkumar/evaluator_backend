 define different neighbourhood functions for a given problem. Neighbourhood functions that are sparse lead to quicker movement during search, because the algorithm has to inspect fewer neighbours. But there is a greater probability of getting stuck on a local optimum. This probability of getting stuck becomes lower as neighbourhood functions become denser; but then search progress also slows down because the algorithm has to inspect more neighbours before each move. Variable Neighbourhood Descent (VDN) tries to get the best of both worlds (Hansen and Mladenovic, 2002; Hoos and Stutzle, 2005). It starts searching with a sparse neighbourhood function. When it reaches an optimum, it switches to a denser function. The hope is that most of the movement would be done in the earlier rounds, and that the time performance will be better. Otherwise, it is basically a Hill Climbing search. In the algorithm in Figure 3.16, we assume that there exists a sequence of moveGen functions ordered on increasing density, and that one can pass these functions as parameters to the Hill Climbing procedure. VariableNeighbourhccodDdescent () 2 node start for ic i1lton 3 do moveGen MoveGen(i) 4 node HillClimbing(node , moveGen) 5 return node FIGURE 3.16 Algorithm Variable Neighbourhood Descent. The algorithm assumes that the function moveGen can be passed as a parameter. It assumes that there are N moveGen functions sorted according to the density of the neighbourhoods produced. 3.7 Beam Search In many problem domains, fairly good heuristic functions can be devised; but they may not be foolproof. Typically, at various levels a few choices may look almost equal, and the function may not be able to discriminate between them. In such a situation, it may help to keep more than one node in the search tree at each level. The number of nodes kept is known as the beam width b. At each stage of expansion, all b nodes are expanded; and from the successors, the best b are retained. The memory requireme