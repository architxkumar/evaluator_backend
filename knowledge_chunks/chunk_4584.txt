hes viz. relishes(priya,coffee) which causes the variable Who to be bound to the value priya which in turn is finally returned. Now add the following facts to the above program: fond(priya,driving). Jond(prakash,cartoons). Compound goals like Who relishes coffee and is also fond of driving? viz. relishes(Who, coffee), fond(Who,driving). will initially bind the first Who to priya and then try to find a match with this value for the second goal viz. fond(priya,driving). Notice that Who has been bound to priya. Since it could consistently find a value for Who that matches both the goals, the system returns priya as an answer. The value bound in the first goal is thus propagated to the next goal and so on. What about the goal relishes(Who, coffee), fond(Who,cartoons). ? Since the propagated value of Who, viz. priya, cannot bind to the variable Who in the second clause (obviously), the PROLOG inference engine backtracks to another fact for relishes to find a new value for Who that matches the first goal. If you add the fact relishes(prakash, coffee). then this compound goal given above would in the second attempt, bind the variable Who to prakash and carry it forward to the second goal to finally satisfy it. One should bear in mind that free variables having the same position in a predicate can bind to each other. For instance in the goal PROLOG - The Natural Language of Artificial Intelligence 503 ne naapeeanmzaeaanaan pianmee tan enemiaeeeneaieeameneammniall likes(priya,X). the variable X is not bound (free) and hence wil! bind with the left hand side of the first rule viz. likes(priya, Food). which also has a variable as its second argument. We could thus say that X is mapped to the variable Food whose value is subsequently discovered if all the subgoals in the right hand side of the rule can are satisfied. In brief one should bear in mind that PROLOG allows structures that comprise a name (or it could be an atom) with arguments enclosed in brackets. Two such terms un