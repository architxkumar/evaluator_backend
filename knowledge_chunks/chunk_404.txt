e details here, but the interested reader is referred to the paper by Gordon. Play The game is characterized by the following properties, The branching factor is high, ranging from 700 without blank tiles, to as high as 8000 when a player holds two blanks (Sheppard, 2002). The opponent moves cannot be generated since the opponent's rack is hidden. This feature of incomplete information is similar to the one in card games like bridge. As a consequence, the second ply cannot be generated. Even the player s next move cannot be generated. This is because (1) the opponent s move is not known, and (2) because the tiles that will be drawn by the player are not known. The second feature is different from games like Bridge. Maven divides the game into three parts, each of which it treats differently. The first part is the initial game or the normal game, governed by the above properties. Maven plays this phase using a one-ply search. That is, it generates all moves and chooses the best looking one. Everything thus depends upon the evaluation function. The evaluation function has the following components. Rack Leave A very important feature is the tiles left behind on the rack, known as the rack leave. Obviously some letters, for example E and T are easy to use because they occur in many words, while letters like Q and Z are more difficult to use. The rack leave has an impact on the score in future moves, and players would not like to leave bad combinations of letters. Thus, they have to trade off current score versus future score. Maven used games played against itself to learn this part of the evaluation function (see Chapter 18 on Machine Learning). It tracks individual tiles and combinations of tiles like duplicated letters, and vowel-consonant combinations. It learned values for these parameters, by completing games with different rack leaves, and recording the future score associated with each combination. The future score is the difference in the score of the side to m