 visit this strategy, known as dependency-directed backtracking in Chapter 9. Meanwhile, let us focus on problem decomposition with backward reasoning. The DFS search formulation above is a bottom-up approach, in which the algorithm synthesizes different combinations of primitive moves, and then tests for the goal being achieved. In this chapter, we explore an alternative approach in which we view problem solving as a top-down process. The main idea is that problems can be decomposed into subproblems. This decomposition process continues till we have problems that are trivial to solve. This could happen when we have a library of simple (primitive) problems and their solutions. This approach assumes that the problems can be decomposed into smaller problems that can be solved independently, in smaller search spaces. Visit Mall The Matrix fi " Piz ul a a ase Bhavan fa Y a Bhuvan Shome Saravana Bhavan . Bhuvan Shome Pizza Hut a ? a i Pizza Hut s, Pizza Ut ;, Saravana Bhavan Al i Saravana Bhavan j Saravana Bhavan Artificial Intelligence: at Saravana Bhavan Pizza Hut Saravana Bhavan Pizza Hut Satavana Bhavan Figure 6.1 A search tree for planning an evening out. The desired plan is marked by the shaded node. Depth First Search will search through from left to right. For the above problem of planning an evening out, we decompose the problem into three parts to be solved independently. They correspond to the three phases of the evening plan. The resulting search tree is depicted in Figure 6.2. Notice that the decomposition happens at the top level in this problem. This is indicated in the figure by connecting the three edges emanating from the root. In general, decomposition could also happen lower down as one breaks down a subproblem further. OR are rs Visit Mall Visit Beach ss, Pizza Hut Saravana Bhavan r i Seven Samurai The Matrix Seen : Bhuvan Shome Figure 6.2 An AND-OR tree. And arcs represent subproblems to be solved individually. Notice that the solution is subtree ra