ting the opponents move, does another k-ply search. If we could have searched the entire tree, the search would have to be done only once. But constrained to search only a part of a tree, we do a series of searches, one every time the program has to make a move. Every subsequent search starts two plies deeper than the previous one, and explores two more plies in the game tree. But, as shown in Figure 8.16, since it searches only below the chosen moves, it only looks at a fixed number of nodes at each level in the game tree. The complexity of algorithm can be depicted by the area of the search tree, which is proportional to the number of nodes in the tree. The figure below gives one an intuitive idea that the series of fixed ply searches explore only a small part of the entire game tree. Assuming that each search looks at P nodes, the game playing program will look at a total of PN 2 nodes during the entire time, where N is the number of moves made by both sides. First call to k-ply search ) FIGURE 8.16 A game playing program does a k-ply look-ahead search for each move. It makes the best move, waits for the opponent to move, and does another k-ply search to decide upon the next move. We now look at the basic algorithm for doing the fixed ply search. The algorithm uses an evaluation function e(J ) when considering the nodes at the frontier. 8.2.1 Algorithm Minimax The algorithm Minimax searches the game tree till depth k in a depth-first manner from left to right. It applies the minimax rule (Figure 8.6) to determine the value of the root node. The following algorithm (Figure 8.17) is a recursive version adapted from (Pearl, 1984). The algorithm uses a test Terminal(node) to determine whether it is looking at a frontier node, and therefore should apply the evaluation function e(J) instead of making a recursive call. A node is a terminal of a leaf node of the game, and will evaluate to one of -Large, 0, Large or it is a node on the horizon, and in that case the evalua