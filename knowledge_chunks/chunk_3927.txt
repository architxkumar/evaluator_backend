 and a way of guaranteeing uniform substitutions throughout a proof. Mechanisms for doing both those things are discussed below. nalive(Marcus, now) t (8, substitution) dead Marcus, now) t T (10, substitution) diec{ Marcus, t,) /\ gi{now, t) T (5, substitution) Pompeiar{ Marcus) \ gi{now, 79) t T (2) gt{now, 79) T (8, substitute equals) gt(1991,79) t T {compute gt} nil Fig. 5.5 One Way of Proving That Marcus Is Dead From looking at the proofs we have just shown, two things should be clear: Even very simple conclusions can require many steps to prove. A variety of processes, such as matching, substitution, and application of modus ponens are involved in the production of a proof. This is true even for the simple statements we are using. It would be worse if we had implications with more than a single term on the right or with complicated expressions involving amis and ors on the left. The first of these observations suggests that if we want to be able to do nontnvial reasoning, we are going to need some statements that allow us to take bigger steps along the way. These should represent the facts that people gradually acquire as they become experts. How to get computers to acquire them is a hard problem for which no very good answer is known. The second observation suggests that actually building a program to do what people do in producing proofs such as these may not be easy. In the next section, we introduce a proof procedure called resolution that reduces some of the complexity because it operates on statements that have first been converted to a single canonical form. 5.4 RESOLUTION As we suggest above, it would be useful from a computational point of view ff we had a proof procedure that carried out in a single operation the variety of processes involved in reasoning with statements in predicate logic. Resolution is such a procedure, which gains its efficiency from the fact that it operates on statements that have been converted to a very convenient standard form