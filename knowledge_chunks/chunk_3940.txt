Predicate Logic We now have an easy way of determining that two literals are contradictorythey are if one of them can be unified with the negation of the other. So, for example, man(x) and >man(Spot) are contradictory, since man(x) and man(Spot) can be unified. This corresponds to the intuition that says that man(x) cannot be true for all x if there is known to be some x, say Spot, for which man(x) is false. Thus in order to use resolution for expressions in the predicate logic, we use the unification algorithm to locate pairs of literals that cancel out. We also need to use the unifier produced by the unification algorithm to generate the resolvent clause. For example, suppose we want to resolve two clauses: 1. man(Marcus) 2. man(x,) \V mortal(x;) The literal man{Marcus) can be unified with the literal man/x\) with the substitution Marcus/z,, telling us that for x, = Marcus, ~man(Marcus) is false. But we cannot simply cancel out the two man literals as we did in propositional logic and generate the resolvent morta/(x,). Clause 2 says that for a given x), either s/nan(x,) or mortal(x,). So for it to be true, we can now conclude only that mortal(Marcus) must be true. It is not necessary that mortal(x,) be true for all x,, since for some values of x,, -man(x,) might be true, making mortal(x,) irrelevant to the truth of the complete clause. So the resolvent generated by clauses 1 and 2 must be mortal(Marcus), which we get by applying the result of the unification process to.the resolvent. The resolution process can then proceed from there to discover whether mortal(Marcus) leads to a contradiction with other available clauses. This example illustrates the importance of standardizing variables apart during the process of converting expressions to clause form. Given that that standardization has bee n done, it is easy to determine how the Using Predicate Logic 117 th ethereal unifier must be used to perform substitutions to create the resolvent. If two instances of the s