tially growing layers. FIGURE 2.24 DFS vs. BFS on a finite tree. If the state space is infinite then DFS could dive down an infinitely long path and never recover! It would then make no sense to talk of time complexity. Let us assume, for analysis, a domain where the search tree is of bounded depth and of constant branching factor. The tree is shown in Figure 2.24, and depicts two cases that are specifically good for the two searches respectively. A goal node on the bottom left will be found rather quickly by a DFS that dives into that area? when it gets going. A goal node in the shallow part of the tree on the right would be found faster by BFS that explores the tree level by level. Basically, the DFS finds nodes on the left side in the search tree faster, while BFS finds nodes closer to the starting node faster. For quantitative analysis, let us look at a search tree in which the goal is always at the same depth d in a search tree with a fixed branching factor b. Of course, this may not be true in real problems but making this assumption will give us some idea of the complexity of the two algorithms for finding goals at depth d. We further assume that the search tree is of bounded depth d. An example of such a domain is the n-queens domain, where in each row a queen can be placed in any of the n columns, and a solution will have queens placed in all the n rows. The goal node can be anywhere from the extreme left to the extreme right. The root node of the search tree is the start node. At level (depth) 1, there are b nodes. At depth 2, there are bxb nodes, and so on. At level d there are b nodes. Also, given a tree of depth d, the number of internal nodes is given by T 1 b-b' ... 54! (b4-1) (b-1) Table (2.1) illustrates the numbers for b 10, and gives us a good idea of how rapidly the search tree grows. At depth 13, there are 1013 leaves and about 1.1 x 1012 internal nodes. An interesting point to note is that the number of internal nodes is significantly smaller t