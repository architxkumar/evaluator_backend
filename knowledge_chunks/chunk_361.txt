 machine, the more is the look-ahead possible in the same time. The more the program looks ahead, the better it is likely to play. Experts hypothesize that even with a simple evaluation function, a program that looks ahead fourteen to sixteen plies will play at a grandmaster level (Newborn, 2003). The extent of look-ahead is determined by the computing resources available. Most commercial programs do an eightor nine-ply search. More sophisticated machines try and harness parallel computing with specialized hardware (Berliner, 1987; Campbell et al., 2002). One does not have to do a fixed look-ahead rigidly. We can write programs to explore critical regions deeper. While playing competitive Chess, one is constrained by the clock. One can then do a flexible amount of look-ahead, depending on the amount of time available. This is typically done using an iterative deepening approach, like the one we studied in Chapter 2. The search component keeps searching deeper and deeper, and when the controlling program needs to play a move, it simply picks the best known move available. 8.2 Game Playing Algorithms The basic procedure for game playing is then the following. Explore the tree up to a finite ply depth. Compute the evaluation function of the nodes on the frontier. Use the minimax backup rule described earlier to determine the value of the partial game tree, and the best move. Make the chosen move, wait for the opponent's move, and then again search for your best move. GamePlay (MAX) 1 while game not over 2 do Call k-ply search 3 Make move 4 Get MIN s move FIGURE 8.15 The top level game playing algorithm makes a call to search algorithm that backs up the evaluation function values from the horizon at k-ply depth. It makes the move that yields the minimax value, and after getting the opponents move, does another k-ply search. If we could have searched the entire tree, the search would have to be done only once. But constrained to search only a part of a tree, we do a seri