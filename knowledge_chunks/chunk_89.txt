t in OPEN. By the time it finishes with these nodes, it has generated the entire next level and stored them in OPEN. Thus, when it enters the next level at depth (d 1), it sees b ") nodes in the OPEN list. A Double circle CLOSED Blank OPEN FIGURE 2.25 The OPEN and CLOSED for DFS and BFS on the tiny search tree. This then is the main drawback of BFS. The size of OPEN grows exponentially with depth. This stands out when one looks at DFS, managing its search with an OPEN list that grows only linearly with depth. a HK A? FIGURE 2.26 With a branching factor of 5, at depth 5, there are 5(5 1) 1 21 nodes in the OPEN to begin with. But as DFS progresses and the algorithm backtracks and moves right, the number of nodes on OPEN decreases. 2.6 Quality of Solution Our formulation of problem solving does not include any explicit cost for the moves or choices made. Consequently, the only quality measure we can talk of is the length of the solution. That is, we consider solutions with smaller number of moves as better. Where BFS loses out on space complexity, it makes up on the quality of the solution. Since it pushes into the search space level by level, the Breadth First Search inspects candidate solutions in increasing order of solution length. Consequently, it will always find the shortest solution. This is a major advantage in many domains. Depth First Search on the other hand, dives down into the search tree. It backtracks if it reaches a dead end, and tries other parts of the search space. It returns the first solution found, which holds no guarantee that it will be the shortest one. Given a search tree with two goal nodes as shown in Figure 2.24, DFS will find the longer solution deeper in the search tree. Thus, it can find a non-optimal solution. On the other hand, since BFS pushes into the search tree, it will always find the shortest solution. So, this is one feature where BFS is better than DFS. In fact, if the search space is infinite, there is a danger that DFS will 