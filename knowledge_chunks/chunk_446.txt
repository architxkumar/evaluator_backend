 The algorithm PC-1 looks at all pairs of variables, irrespective of whether there is an explicit constraint between them or not. This is because the absence of a constraint is equivalent to a universal constraint in which all combinations are allowed. Thus, in each cycle, the algorithm will inspect (n 1)? edges for each of the n variables, expending O(k ) computations in each call to Revise-3. Thus, in each cycle, the algorithm will do O(n k?) computations. Further, in each cycle, in the worst case, we will remove one pair of values a, b from some constraint Ryy. In the worst case then, the number of cycles is O(n2k2), because there are n? relations and each may have k2 elements. Thus in the worst case, algorithm PC-1 will require O(n5k ) computations. Every time a call is made to Revise-3 O(k ), computations are needed. But can we cut down on the number of calls to Revise-3? The answer is indeed yes, and in a manner analogous to AC-3 the algorithm PC-2 only calls Revise when a pair is removed from a relation. When a, b is removed from Ryy, one needs to check again whether a, b was a supporting edge for pairs c, a or c, b , for all c. The algorithm PC-2 described below maintains a queue of triples which it needs to inspect in a manner similar to algorithm AC-3. Pc-2 (X, D, C) 1 queue ( ) 2 for each x., 3 for each x, and x; such that k j, k i, j i 4 enqueue (( (Xp, 2) X), queue) S while not (empty (queu ) ) varfriple dequeue (queue) 7 x Head(Head(varTriple) ) 8 y Head(Head(Tail(varTriple) )) 9 z Head(Tail(varfriple) ) 1 Ry Revise-3(D,, Ri, Ryse ,,) 11 if R,, has changed 12 then for each z such that 4x andz y 13 enqueue (((z, x), y), queue) 14 enqueue (((z, y), x), queue) 15 return (X, D, C) FIGURE 9.19 Like AC-3, the algorithm PC-3 maintains a queue of calls to Revise-3 for each triple of variables. Subsequently, if it removes a pair from a relation, then it checks whether a side of a triangle with a third value is not being broken. The complexity of PC-2 depends up