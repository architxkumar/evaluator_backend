the goal propositions have appeared nonmutex in the latest layer. Or two, the planning graph has levelled off. The empty sets at level zero have been created only to allow a uniform call to ExtendGraph. Note that the two cases are distinct and there is no possibility of both the tests connected by or in step 10 becoming true simultaneously. The algorithm Graphplan is described below. It begins by checking if G is a subset of S. In that case, a plan need not be found. Otherwise, Graphplan calls Planning Graph. If the procedure PlanningGraph returns a planning graph with all goal propositions nonmutex, it is possible, but not necessary, that a valid plan might exist in the graph. We assume a procedure ExtractPlan(G, i, PlanGraph) that either extracts a plan p if there exists one, or returns nix . If the procedure ExtractPlan returns nix at layer i, there are two possibilities. The first is that the shortest plan, which may have parallel actions, has more stages than the layers in the planning graph. To investigate this possibility, Graphplan extends the planning graph one step at a time, checking whether a plan exists at each stage. Observe that this is a kind of iterative deepening behaviour, and always results in the shortest plans being found. As the planning graph is iteratively extended, it levels off at some stage. Let us call this level n. That is Pp, P, and MuP, , MuP,. The second possibility is that a plan does not exist at all, even though the goal propositions occur without mutex relations amongst them. The question then is: when should the algorithm stop extending the graph and terminate with failure to find a plan? Observe that a layer in the planning graph supplies the preconditions for the succeeding layer. Conversely, the layer can be seen as containing the subgoals that need to be solved for the goals in the succeeding layer, and layers beyond that as well. The basic idea in formulating the termination criteria is to identify a layer in the planning g