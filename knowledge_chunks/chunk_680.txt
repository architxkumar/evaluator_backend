 is true then Q(x) holds too . Though x sounds existential in the above reading there is an versally quantified variable. The equivalent statement is For all x such that P(x)... . We will express n statements. antecedents consequent ard chaining picks a rule, whose antecedents have matching facts, and produces matching consec are all orouns dpi nent then this process involves creating a matching ground instance of the modus ponens fo that ground instance '. The variables involved are universally quantified. The p 1 below. .12 Forward chaining in FOL is a two step process. First a relevant instantiation of a rule is created. Then the rule instance is use roduce the consequent. implicit quantifier form of a sentence there are only universally quantified variables. Then, since a ve is universally quantified we do not need to keep the quantifier symbols. The process of con' - into implicit quantifier is also called skolemization after the logician Thoralf Skolem. We still sh between variables and constants, and we do that by adopting some convention. We will adopt the of prefixing a variable name with a question mark. Symbols without the prefix are treated as const All men are mortals is then represented as, Man(?x) Mortal(?x) er convention that is popular is to begin variables with upper case letters and constants with loi his is followed in the programming language Prolog. Whatever the convention we use we still the variable in the rule with the constant in the fact when applying the rule. A simple approach wo gorithm to match a variable with a constant, as is done in rule based systems (see Chapter 6). But general approach, which will allow us to match terms containing an arbitrary number of nested The algorithm is called the unification algorithm, and is described below. bstitution is a set of (variable term) pairs, that signifies the replacement of the variables nding terms. The term should not contain the variable that it is replacing. A substitution is usually de