ntence. In this example, if the auxiliary verb interpretation of have were chosen first and the end of the sentence appeared with no main verb having been seen, the understander would detect failure and backtrack to try some other path. There are two important drawbacks to this approach. The first is that a good deal of time may be wasted saving state descriptions at each choice point, even though backtracking will occur to only a few of those points. The second is that often the same constituent may be analyzed many times. In our example, if the wrong interpretation is selected for the word have, it will not he detected until after the phrase the students who missed the exam has been recognized. Once the error is detected, a simple backtracking mechanism will undo everything that was done after the incorrect interpretation of have was chosen, and the noun phrase will be reinterpreted (identically) after the second interpretation of have has been selected. This problem can be avoided using some form of dependency-directed backtracking, but then the implementation of the parser is more complex. Best Path with Patchup Follow only one path at a time, but when an error is detected, explicitly shuffle around the components that have already been formed. Again, using the same example, if the auxiliary verb interpretation of have were chosen first, then the noun phrase the students who missed the exam would be interpreted and recorded as the subject of the sentence. If the word taker appears next, this path can simply be continued. But if take occurs next, the understander can simply shift components into different slots. Have becomes the main verb. The noun phrase that was marked as the subject of the sentence becomes the subject of the embedded sentence The students who missed the exam take it today. And the subject of the main sentence can be filled in as you, the default subject for imperative sentences. This approach is usually more efficient than the previous two tec