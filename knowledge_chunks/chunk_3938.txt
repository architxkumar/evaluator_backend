tution throughout the literals, giving PYy, y) PL, 2) Now we can attempt to unify arguments v and z, which succeeds with the substitution z/y. The entire unification process has now succeeded with a substitution that is the composition of the two substitutions we found. We write the composition as @y)Q/) following standard notation for function composition. In general, the substitution (4)/a, a,/a,, ...)(b\/b>, bb,....)... means to apply all the substitutions of the rightmost list, then take the result and apply all the ones of the next list, and so forth, until all substitutions have been applied. The object of the unification procedure is to discover at least one substitution that causes two literals to match. Usually, if there is one such substitution there are many. For example, the literals hate(x, y) hate(Marcus, z) could be unified with any of the following substitutions: (Marcus/x,z/y) (Marcus/x,y/z) (Marcus/x, Cuesar/y, Caesar/z) (Marcus/x, Polonius/y, Polonius/z) The first two of these are equivalent except for lexical variation. But the second two, although they produce a match, also produce a substitution that is more restrictive than absolutely necessary for the match. Because the final substitution produced by the unification process will be used by the resolution procedure, it is useful to generate the most general unifier possible. The algorithm shown below will do that. Having explained the operation of the unification algorithm, we can now state it concisely. We describe a procedure Unify(LI, L2), which returns as its value a list representing the composition of the substitutions that were performed during the match. The empty list, NIL, indicates that a match was fpund without any substitutions. The list consisting of the single value FAIL indicates that the unification procedure failed. Algorithm: Unify(LL L2) 1]. If 1 or L2 are both variables or constants, then: (a) f 1 and L2 are identical, then return NIL. (b) Else if ] is a variable, then if 