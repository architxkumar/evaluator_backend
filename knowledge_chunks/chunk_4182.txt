UP to get the arm holding C. The top element on the goal stack is ONTABLE(C), which is already satisfied, so we pop it off. The next element is CLEAR(C), which is also satisfied, so we pop it off. The remaining precondition of PICKUP(C) is ARMEMPTY, which is not satisfied since HOLDING(B) is true. There are two operators that could be applied to make ARMEMPTY true: STACK(B, x) and PUTDOWN(B). In other words, we can either put B on the table or we can put it on another block. Which should we choose? If we look ahead a bit, we see that we ultimately want to get B onto D. It would be most efficient simply to put it there now. Our program could figure this out by comparing the elements of the ADD lists of the competing operators to the rest of the goal stack. If one of the operators has the fortuitous effect of making any of those goals true, it should be chosen. So we choose to apply STACK(B, D) by binding D to x in the STACK operator. This makes the goal stack CLEAR(D) HOLDING(B) CLEAR(D) A HOLDING(B) STACK(B, D) ONTABLE(C) A CLEAR(C) \ ARMEMPTY PICKUP(C) CLEAR(A) A HOLDING(C) STACK(C, A) ON(BD). ON(C, A) A ON(B, D) A OTAD CLEAR(D) and HOLDING(B) are both true. Now the operation STACK(B, D) can be performed, producing the world model ONTABLE(A) A ONTABLE(C) A ONTABLE(D) A ON(B, D) A ARMEMPTY All of the preconditions for PICKUP(C) are now satisfied so it, too, can be executed. Then all of the preconditions of STACK(C, A) are true, so it can be executed. Now we can begin work on the second part of our original goal, ON(B, D). But it has already been satisfied by the operations that were used to satisfy the first subgoal. This happened because when we had a choice of ways to get rid of the arm holding B, we scanned back down the goal stack to see if one of the operators would have other useful side effects and we found that one did. So we now pop ON(B, D) off the goal stack. We then do one last check of the combined goal ON(C, A) A ON (B, D) A ONTABLE(A) A ONTABLE(D) to 