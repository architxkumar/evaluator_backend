Planning (BSSP). Backward reasoning or goal-directed reasoning has been proposed as being fundamental to intelligent behaviour, and we have already visited it while studying goal trees in Chapter 6. It is also the foundation of reasoning with logic, and the backbone of the logic programming language Prolog (Kowalski, 1974; Colmerauer, 1992). We will explore logic and reasoning later in Chapter 12. At this moment, let us focus on the possibility of backward state space planning. One feature strongly in support of such an approach is the fact that goal states are often incompletely specified. That is, one often expresses only what is desired in the final state, rather than a complete description of the final state. For example, at some point of time, one might have the goal of satisfying hunger. Reasoning in a backward fashion, one will only focus on actions that will result in eating something, without worrying about anything else. Similarly, the goal in the planning problem of Figure 7.2 is that block G should be on block A, and block B on block J. Can we focus only on the moves that will achieve these conditions? To do this, we have to first define the notion of regression. This, in some sense, is the opposite of progression. It allows us to move back from a set of goal clauses to a set of subgoal clauses. For example, if in a regressed state the robot were holding block G, and block A was clear, and block B was on block J, then the stack(G, A) action would achieve the goal state of Figure 7.2. Given a goal g, we say that an action a is relevant to g iff (g A effects(a) gv) (9g N effects (a) g) Let preconditions(a) denote the preconditions of action a. Given a goal g, and a relevant action a, one can regress to the goal g as follows. g' g - effects(a) U preconditions(a) That is, from the set of goal facts, remove the effects of the action, and add the preconditions of the action. Let us define a function regress(A, G) that returns the regressed goal over action A w