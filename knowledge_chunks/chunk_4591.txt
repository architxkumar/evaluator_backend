elow: factorial(N, Fact_of_N):- factorial(N, Fact_of_N, 1, 1). factorial(N, Fact_of_N, N, Fact_of_N):-!. factorial(N, Fact_of_N, I, J):- Nextl is +], Nextt is J*Nextl, factorial(N, Fact_of_N,Nextl,Next]). Note that the arity or the number of arguments the predicate (factorial in the present case) can vary. A trace for factorial(3,X) is shown below. First clause factorial(3,X) calls factorial(3,X, 1,1) Factorial(3,X,1,1) The second clause fails as the first and third arguments are not equal. The third clause is thus triggered. NZ Next] = 2, Next J = 2 NY factorial(3,X,2,2}) The second clause fails as the first and third arguments are still not equal. NY Nextl = 3, Next] =6 NY factorial{3,X, 3,6} The second clause succeeds this time as the first and third arguments are not equal and binds the variable X to 6. 25.12 LISTS Lists in PROLOG constitute elements separated by commas and enclosed within square brackets. The elements could comprise of any data type. A list of integers looks like this (2, 4, 8, 10, 12] PROLOG ~ The Natural Language of Artificial Intelligence 509 SPE A RET TAA while that of strings is given below: [jack , jill jane? ]. A list essentially comprises two parts -a Head and a Tail. The former is the first element of the list while the latter is the list comprising all other members. For instance the list of integers (2,4,8,10,12] has the integer 2 as its head and the list [4,8,10,12] as its tail. List is a powerful structure which is why we also have a language LISP which deals with just that. If we wish to make a simple thesaurus of words we could start by adding facts as thesaurus( like , love ). thesaurus( like , fond ). thesaurus( like , similar ). thesaurus( like , akin ). thesaurus( give , offer ). thesaurus( give , bestow ). thesaurus( give , present ), For each synonym a new fact has to be added. This makes the process tedious. Lists provide for a more compact database as thesaurus( like , [love , fond , similar , akin*}). thesaurus( give , [