n of an And-Or problem. In fact, finding the strategy is like solving the game tree as an And-Or problem. Each player has to choose her own moves, the Or choices, and cater to all possible responses by the opponent, the And nodes. With the cost of solving, the And node being the maximum of the costs of solving its children, instead of the sum, the question one might ask is can one use the AO algorithm to play games? One rarely hears of algorithms like AO being used to play games. The answer is that these algorithms could be adapted to play the games if it were possible to reach all the leaf nodes in the game tree. For most interesting games, the trees turn out to be too large to be traversed completely. Games with small trees can be completely solved. For example, the wellknown game of Tic-Tac-Toe (also known as Noughts and Crosses, see Figure 8.11) is known to end in a draw when both players play correctly. But such statements cannot be made for games like Checkers, Chess and Go, because their game trees are too big. That is why these games are still fascinating for us to play. In Chess, for example, many people believe that White, the first to play, has an advantage. But this is only speculation. Let us see why. The starting position in a Chess game? has twenty possible moves for each player. As the game proceeds, the board opens up and the number of choices increases further. Still further in the game as the number of pieces on the board reduce, the number of choices gradually comes down in the end game. It has been estimated that the average branching factor in Chess is thirty five, and that a typical game lasts about fifty moves. This means that the Chess tree has about 35 leaves. This is roughly equal to 10'2 leaves, a number that is difficult even to comprehend. One followed by one hundred twenty zeroes. Let us make a rough estimate of how long it will take to inspect just the leaves, forgetting about the internal tree. Let us assume that we have a fast machi