o compk... the mapping. Thus, a solution based on some algorithm A1 is considered better than one using algorithm A, if the time and space complexity of A1 is less than that of A. Time and Space Complexity Time and space complexities of algorithms may be defined in terms of their best. their average, or their worst-case performance in completing some task. In evaluating different search strategies, we follow the usual convention of considering worst Sec. 9.2 Preliminary Concepts 169 case performances and look for ways to improve on them. For this, we need the 0 (for order) notation. Let! and g be functions of n, where algorithm A has size n. The size can be the number of problem states, the number of input characters which specify the problem or some similar number. Let 1(n) denote the time (or space) required to solve a given problem using algorithm A. We say 'f is big 0 of g" written f = 0(g), if and only if there exists a constant c > 0 and an integer n0, such that f(n) cg(n) for all n n0. Stated more simply, algorithm A solves a problem in at most cg(n) units or steps for all but a finite number of steps. Based on this definition, we say an algorithm is of linear time if it is 0(n). It is of quadratic time if it is 0(n2). and of exponential time if it is 0(2") for some constant k (or if it is Olb A. for any real number b > I). For example, if a knowledge base has ten assertions (clauses), with an average of five literals per clause, and a resolution proof is being performed with no particular strategy; a worst-case prof may require as many as 1125 comparisons (52 X 10(9)! 2) for a single resolution and several times this number for a complete proof. Graph and Tree Representations It is customary to represent a search space as a diagram of a directed graph or a tree. Each node or vertex in the graph corresponds to a problem state, and arcs between nodes correspond to transformations or mappings between the states. The immediate successors of a node are referred t