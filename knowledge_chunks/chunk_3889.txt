of baseball knowledge have concentrated on relatively static, declarative facts. But another, equally useful, kind of knowledge is operational, or procedural knowledge, that specifies what to do when. Procedural knowledge can be represented in programs in many ways. The most common way is simply as code (in some programming language such as LISP) for doing something. The machine uses the knowledge when it executes the code to perform a task. Unfortunately, this way of representing procedural knowledge gets low scores with respect to the properties of inferential adequacy (because it is very difficult to write a program that can reason about another program s behavior) and acquisitional efficiency (because the process of updating and debugging large pieces of code becomes unwieldy). As an extreme example, compare the representation of the way to compute the value of bats shown in Fig. 4.6 to one in LISP shown in Fig. 4.8. Although the LISP one will work given a particular way of storing attributes and values in a list, it does not lend itself to being reasoned about in the same straightforward way 86 Artificial Intelligence ET NS LE ae a aaa as the representation of Fig. 4.6 does. The LISP representation is slightly more powerful since it makes explicit use of the name of the node whose value for handed is to be found. But if this matters, the simpler representation can be augmented to do this as well. Basebail-Player isa: Adult-Male bats: (lambda (x) (prog 0 LI (cond ((caddr x) (return (caddr x)})) (t (setq x (eval (cadr x))) (cond (x (go L1)} (t (return nil)))))) height: 6-1 batting-average: 252 Fig. 4.8 Using LISP Code to Define a Value Because of this difficulty in reasoning with LISP, attempts have been made to find other ways of representing procedural knowledge so that it can relatively easily be manipulated both by other programs and by people. The most commonly used technique for representing procedural knowledge in AT programs is the use of production rules