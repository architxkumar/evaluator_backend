d to ci and (a h ( d) is hound to lxi. With these bindings, the first cond test fails, since lxi is not null. Consequently, the second test is executed. This also fails since el, bound to c, does not equal the car of 1st which is a. The last test of the cond construct is forced to succeed because of the t test. This initiates a recursive call to ncwntciuhcr with (lie new arguments ('I (still hound to c) and the cdi of. 1st which is (h e M. Again, a inalch fails during the ond tests; so another recursive call is made, this time with arguments ci (still bound to c) and lxi now bound to (c (i). When this calf is executed, a match is found in the second cond test so the value of 1st (C d) is returned. Sec.'S.G Pr s Iythpfld An.j' is 3.5 PROPERTy LIST8 AND ARRAYS Property Usts One of the unique and most Useful features of LISP as an Al language is the ability to assign properties to atoms. For example, any object, say an atom which represents a person, can be given a number of properties which in some way characterize the person, such as height, weight, sex, color of eyes and hair, address, profession, family members, and so on. Property list functions permit one to assign such properties to an atom, and to retrieve, replace, or remove them as required. The function putprop assigns properties to an atom. It takes three arguments: an object name (an atom), a property or attribute name, and property or attribute value. For example, to assign properties to a car, we can assign properties such as make, year, color, and style with the following statements: ->(putprop 'car 'ford 'make) FORD -'>(putprop 'car 1988 'year) 1988 '>(putprop 'car 'red 'color) RED ->(putprop 'car 'fourdoor 'style) FOUR-DOOR As you can see, the form of putprop is (putprop object value attribute) where value is returned. The object, car, will retain these properties until they are replaced with new ones or until removed with the remprop function which takes two arguments, 1 the object and its attribute,