t the hest score that can be achieved by an element of SUCCESSORS. For each element SUCC of SUCCESSORS, do the following: (a) Set RESULT-SUCC to MINIMAX(SUCC, Depth + 1, OPPOSITE(Piayer)) This recursive call to MINIMAX will actually carry out the exploration of SUCC. (b) Set NEW-VALUE to - VALUE(RESULT-SUCC). This will cause it to reflect the merits of the position from the opposite perspective from that of the next lower level. (c) If NEW-VALUE > BEST-SCORE, then we have found a successor that is better than any that have been examined so far. Record this by doing the following: {i) Set BEST-SCORE to NEW-VALUE. (ii) The best known path is now from CURRENT to SUCC and then on to the appropriate path down from SUCC as determined hy the recursive call to MINIMAX. So set BEST-PATH to the result of attaching SUCC to the front of PATH(RESULT-SUCC). 5. Now that all the successors have been examined, we know the value of Position as well as which path to take from it. So return the structure VALUE = BEST-SCORE PATH = BEST-PATH When the initial call to MINIMAX returns, the best move from CURRENT is the first element on PATH. To see how this procedure works, you should trace its execution for the game tree shown in Fig. 12.2. The MINIMAX procedure just described is very simple. But its performance can be improved significantly with a few refinements. Some of these are described in the next few sections. 12.3. ADDING ALPHA-BETA CUTOFFS Recall that the minimax procedure is a depth-first process. One path is explored as far as time allows, the static evaluation function is applied to the game positions at the last step of the path, and the value can then be passed up the path one level at a time. One of the good things about depth-first procedures is that their efficiency can often be improved by using branch-and-bound techniques in which partial solutions that are clearly worse than known solutions can be abandoned early. We described a straightforward application of this tech