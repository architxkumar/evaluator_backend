quired to search a path of length d then DCFS has a time complexity given by, T(d) 2 T(d 2) 4 T(d 4) ... k T(d k), where in the last term, d k 1. The reader can verify that the above sums up to 7(d) g(T(d)). In the specific case where T(d) is b with branching factor b, this becomes O(b d). That is, if one were to do divide-and-conquer reconstruction when search is exponential, one has to do an equivalent of d searches instead of one. The basic idea of divide and conquer solution reconstruction was adopted from similar techniques used in dynamic programming methods developed earlier for sequence comparison (Hirschberg, 1975; Myers and Miller, 1988) before memory constraints led researchers to look at A and its variants. 5.9.2 Sparse-Memory Graph Search A variation for pruning of the CLOSED list takes a different approach. The Sparse-Memory Graph Search (SMGS) identifies the boundary of the CLOSED list, as shown in Figure 5.25 (Zhou and Hansen, 2003). The boundary can be defined as those nodes on CLOSED that have at least one neighbour (successor) still on OPEN. This can be done by keeping a counter with every node when it is expanded to keep track of the number of children it has on OPEN. The counter is decremented each time its children are expanded (the node will appear as a child). As long as the counter is greater than zero, the node is on the boundary. When it becomes zero, it goes into the kernel. The nodes of CLOSED that are not on the boundary are in the kernel. One can observe that the nodes in the kernel can only be reached via the nodes on the boundary. It would thus be enough to check for new successors to be on the boundary, to prevent the search from leaking back. The nodes in the kernel can be pruned away. Goal FIGURE 5.25 Boundary nodes in the CLOSED list are enough to prevent search from leaking back. The SMGS also keeps relay nodes for reconstruction of the path like the DCFS. The difference is that it calls a module PruneClosed to prune the CLOSED 