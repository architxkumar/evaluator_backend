N {instance: printing abject: {instance: file-struct extension: init , owner: Bill}} re FILE1 {instance: file-struct extension: init owner: Bill} Jue {instance: file-struct extension: .init owner: Bill} EXT I want to print Bill's -init file. Fig. 15.11 The Result of Parsing with a Semantic Grammar Many ambiguities that would arise during a strictly syntactic parse can be avoided since some of the interpretations do not make sense semantically and thus cannot be generated by a semantic grammar. Consider, for example, the sentence I want to print stuff.txt on printer3. During a strictly syntactic parse, it would not be possible to decide whether the prepositional phrase, on printer3 modified want or print. But using our semantic grammar, there is no general notion of a prepositional phrase and there is no attachment ambiguity. Syntactic issues that do not affect the semantics can be ignored. For example, using the grammar shown above, the sentence, What is the extension of .lisp file? would be parsed and accepted as correct. There are, however, some drawbacks to the use of semantic grammars: e The number of rules required can become very large since many syntactic generalizations are missed. Because the number of grammar rules may be very large, the parsing process may be expensive. After many experiments with the use of semantic grammars in a variety of domains, the conclusion appears to be that for producing restricted natural language interfaces quickly, they can be very useful. But as an overall solution to the problem of language understanding, they are doomed by their failure to capture important linguistic generalizations. Natural Language Processing 305 TANI AACA ISSUE 15.3.2 Case Grammars Case grammars (Fillmore, 1968; Bruce, 1975] provide a different approach to the problem of how syntactic and semantic interpretation can be combined. Grammar rules are written to describe syntactic rather than semantic regularities, But the structures the rules produce corre