tsi move, 9 the last. The main algorithm uses three subprocedures: Make 2 Posswin(p) Got} Returns 5 if the center square of the board is blank, that is, if Board|S} = 2. Otherwese, this function returns any blank noncorner square (2, 4, 6, or 8). Returns 0 if player p cannot win on his next move; otherwise, it returns the number at we square that constitutes a winning move. This function will enable the program tyih w win and to block the opponent's win. Posswin operates by checking. one at a tine, each of the rows. columns, and diagonals. Because of the way values are numbered. if cum tes: an entire row (coiumn or diagonal) to see if it is a possible win by multiplying the cali. of its squares together. If the product is 18 (3 x 3.x 2), then X can win. H the product is * (5 x 5 x 2), then O can win. If we find a winning row, we determine whiv blank, and return the number of that square. Makes a move in square x. This procedure sets Board{n] to 3 if Tarn is odd. er Sif Tush is even. It also increments Turn by one. The algorithm has a built-in strategy for each move it may have to make. It makes the odd-numbered moves if it is playing X, the even-numbered moves if it is playing O. The strategy for each turn is as fo Mows: Turn=1 Turn=2 Turn=3 Turn=4 Turn=5 Go(1) (upper left corner). H Boardj5} ts blank, Gof5), else Go(1). ff Board) 9} is blank, Go(9), else Go(3). If Posswin(X) is not O, then Go(Posswin(X)) {i.e., block opponent s win]. clse Gai Make? Tf Posswin(X) is not 0 then Go(Posswin(X)) Ji.e.. win] else if Posswinf O) is not OQ then Go(Posswin(Q)) fi.e.. block win}. else if Board[7| is blank, then Gii7s. else Goth: {Here the program is trying to make a fork. } 10 Artificial intelligence e Asnaec cnn ORR HNLAE HCTLENNNNNARAN SETS Turn=6 If Posswin(O) is not 0 then Go (Posswin(O)). else if Posswin(X) is not 0, then Go(Posswin(X)), else Go(Make2). Turn=7 if Posswin(X) is not 0 then Go(Posswin(X)). else if Posswin(O) is not 0, then Go(Posswin(Q}), else go anywhere 