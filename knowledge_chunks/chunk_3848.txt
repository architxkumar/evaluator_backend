ing h (D) we make D look so bad that we may find some other, worse solution without ever expanding D. In general, if h might overestimate h, we cannot be guaranteed of finding the cheapest path solution unless we expand the entire graph until all paths are longer than the best solution. An interesting question is, Of what practical significance is the theorem that if A/ never overestimates h then A* is admissible? The answer is, almost none, because, for most real problems, the only way to guarantee that Ai never overestimates A is to set it to zero. But then we are back to breadth-first search, which is admissible but not efficient. But there is a corollary to this theorem that is very useful. We can state it loosely as follows: [e|(4+1) (D]G+1) Fig. 3.5 h Overestimates h Graceful Decay of Admissibility: If h rarely overestimates 4 by more than 6, then the A* algorithm will rarely find a solution whose cost is more than 6 greater than the cost of the optimal solution. The formalization and proof of this corollary will be ieft as an exercise. The third observation we can make about the A* algorithm has to do with the relationship between trees and graphs. The algorithm was stated in its most general form as it applies to graphs. It can, of course, be 5 A search algorithm that is guaranteed to find an optimal path to a goal, if one exists, is called admissible [Nilsson, 1980}. 62 Artificial intelligence simplified to apply to trees by not bothering to check whether a new node is already on OPEN or CLOSED. This makes it faster to generate nodes but may result in the same search being conducted many times if nodes are often duplicated. . Under certain conditions, the A* algorithm can be shown to be optimal in that it generates the fewest nodes in the process of finding a solution to a problem. Under other conditions it is not optimal. For formal discussions of these conditions, see Gelperin [1977] and Martelli [1977]. 3.3.3 Agendas In our discussion of best-first searc