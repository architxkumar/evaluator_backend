es which now constitutes of Ay , M4 , Mo, Ao and Mo, M3 , as shown in Figure 17.15. The reader should verify that these are the four minimal hitting sets for the two conflicts sets we started with. The precise algorithm for updating the set of candidates given a new conflict set is left as an exercise. Figure 17.14 After the first conflict M,, Mz, A is processed, the minimal candidates are M4 , Mp , and A, , while F , M3 , Az and M3, Ap) are out of contention. , Mz, Ms, A, Figure 17.15 After the second conflict A;, Ap, M, M3 is processed, the minimal candidates are shown in the shaded rectangles, while the exonerated ones have thick borders. When we begin with a correctly functioning device, the only (minimal) candidate for diagnosis is . Once a discrepancy is found between the predicted and observed behaviour, and a conflict set generated, a new set of candidates is computed, and , along with possibly a few others is no longer a candidate. Once a candidate is out of contention, it remains out of contention as more data in the form of conflicts is received. The set of exonerated components (or assumptions in the logic model) grows monotonically bottom up in the lattice. One can think of the process of diagnosis as the process of exonerating candidates, till only one (minimal) candidate remains. Conflict Generation The candidate generation algorithm takes conflicts as inputs. A conflict (or a conflict set) is derived from an observation. If the observation has a discrepancy contained in it, then it will lead to a nonempty, conflict set. A conflict set is derived from two ways at arriving at the value of a variable in a system. In the example we have been using, the variables are values at the terminals of some component. The first conflict A,;, M,, Mz is arrived at by observing the discrepancy in the two values at F, in Figure 17.12. One value F, 12, is based on the assumptions Ab(M,), Ab(M2) and 7Ab(A,), which state that the corresponding components are working corr