e that we have overloaded the symbol O to stand both for the numeral 0 and the number 0. Another way we could talk about length is to deal with the reified object length(Object) directly (Russel and Norvig, 2009). The function inches would then take a number as input and return an appropriate of object of type Length. Then we ce uldrsait,com length(Pencil41) inches(5) cms(12.7) This has the advantage that we can directly talk of reified objects like 5 inches as length that in inches measures 5 units, and define predicates like, height(Aditi96, inches(66), year(2008)) One would also find it easier to represent statements like It was a three hour long odyssey . Conversion now will need multiplication inside the brackets. inches(X) cms(X 2.54) One thing we might want to do with measured quantities is to add them, and to compare them. In the first notation one can assert that only same unit measures can be compared. Then since the functions return numbers we can simply make statements like, km(distance(Delhi, Chennai)) km(distance(Delhi, Mumbai)) This is a bit unnatural, since we want to say that Chennai is farther from Delhi than Mumbai is, and we do not want to talk about units of measurement unnecessarily. We can get around this by asserting the following equivalence, (distance(Delhi, Chennai) distance(Delhi, Mumbai)) (km(distance(Delhi, Chennai)) km(distance(Delhi, Mumbai))) The second notation returns objects of the abstract length type, over which we would have to define the ordering as dependent upon the underlying order of numbers, for example as follows. (km(X) km(F)) (X Y) This says, for example, that if 2100 is greater than 1200, then 2100 km is greater than 1200 km, and vice versa. We may also need to define the addition function to reason with situations where quantities need to be added. For example Shyam ran for 3 km and walked another 2 km. How much distance did he cover? In the first notation, addition is defined naturally, and one will assert the facts