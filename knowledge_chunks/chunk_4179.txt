m. At this point, it is useful to exploit some heuristic knowledge. HOLDING(a) is very easy to achieve. At most, it is necessary to put down something else and then to pick up the desired object. But HOLDING is also very easy to undo. In order to do almost anything else, the robot will need to use the arm. So if we achieve HOLDING first and then try to do something else, we will most likely end up with HOLDING no longer true. So we. exploit the heuristic that if HOLDING is one of several goals to be achieved at once, it should be tackled last. This produces the new goal stack CLEAR(A) HOLDING(C) CLEAR(A) A HOLDING(C) STACK(C, A) ONG, D) ON(C, A) A ON(B, D) A OTAD Planning 257 NC This kind of heuristic information could be contained in the precondition list itself by stating the predicates in the order in which they should be achieved. Next we check to see if CLEAR(A) is true. It is not. The only operator that could make it true is UNSTACK (B, A). So we will attempt to apply it. This produces the goal stack ON(B, A) CLEAR(B) ARMEMPTY ON(B, A) A CLEAR(B) \ ARMEMPTY UNSTACK(B, A) HOLDING(C) CLEAR(A) A HOLDING(C) STACK(C, A) ON@G, D) ON(C, A) A ON(B, D) A OTAD This time, when we compare the top element of the goal stack, ON(B, A), to the world model, we see that it is satisfied. So we pop it off and consider the next goal, CLEAR(B). It, too, is already true in the world model, although it was not stated explicitly as one of the initial predicates. But from the initial predicates and the blocks world axiom that says that any block with no blocks on it is clear, a theorem prover could derive CLEAR(B). So that goal, too, can be popped from the stack. The third precondition for UNSTACK(B, A) remains. It is ARMEMPTY, and it is also true in the current world model, so it can be popped off the stack. The next element on the stack is the combined goal representing all of the preconditions for UNSTACK(B, A). We check to make sure it is satisfied in the world model. It will be un