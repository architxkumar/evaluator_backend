start) NIL for all other nodes n do cost(n) repeat Select lowest cost white node n 2m nob to 3 Colour n black 8 for all white neighbours m of n C do if (cost(n) k(n, m)) cost(m) ll then cost(m) cost(n) k(n, m) 12 parent(m) a 13 until 211 nodes are ccloured black FIGURE 5.9 Dijkstra single source shortest path algorithm. We illustrate the algorithm with our tiny search graph shown in Figure 5.10. Note that in the last iteration, a better path to G was found from E. The cost was updated from 11 to 10, and the parent pointer reassigned. The last node to be coloured is G, and the algorithm terminates. The shortest route to any node can be traced back. 5.5 Algorithm A The algorithm A , first described by Hart, Nilsson and Raphael, see (Hart et al., 1968: Nilsson, 1980) combines the best features of B B, Dijkstra s algorithm and Best First Search described earlier in Chapter 3. Both B B and Dijkstra s algorithm extend the least cost partial solution. While the latter is designed to solve a general problem, the former uses a similar blind approach, even though it has a specific goal to achieve. B B generates a search tree that may have duplicate copies of the same nodes with different costs; while Dijkstra s algorithm searches over a given graph, keeping exactly one copy of each node and back pointers for the best routes. Neither has a sense of direction. Best First Search does have a sense of direction. It uses a heuristic function to decide which of the candidate nodes is likely to be closest to the goal, and expands that. However, it does not keep track of the cost incurred to reach that node, as illustrated in Figure 5.11. Best First Search only looks ahead from the node n, seeking a quick path to the goal, while B B only looks behind, keeping track of the best paths found so far. Algorithm A does both. A uses an evaluation function f (node) to order its search. f (n) Estimated cost of a path from Start to Goal via node n. Let f (n) be the (actual but unknown) cost of 