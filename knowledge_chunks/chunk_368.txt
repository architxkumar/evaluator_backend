ed initially with bounds a Large, and B t Large. As search progresses, these bounds come closer, and eventually converge on the minimax value of the tree. At any point, when it is recursively called with bounds a and 8, it returns V(J) if the value lies between the two bounds. Otherwise, it returns a value 8 if J is an Alpha node, and returns a, if J is a Beta node. An Example The following figure shows the subtree in a 4-ply binary game. As in the earlier example, the values of the evaluation function have been filled in randomly. 8 ET Minimax value Recommended move A he 12 Baacuo) Alpin wot Apa ouot FIGURE 8.25 The AlfBeta algorithm evaluates twelve out of the sixteen leaves. It does one b cutoff and two a cutoffs as shown. The minimax value is 8. The reader is encouraged to verify that the minimax value of the game tree is indeed 8, as reported by the AlphaBeta algorithm. This is irrespective of the values that are in the pruned leaves, shown as shaded nodes. Based on the leaves the algorithm has seen earlier in the search, which is in the left part of a tree, some leaves have no influence on the minimax value. The reader is encouraged to try different values in the shaded nodes and verify that the minimax value does not change. Since the cutoffs are dictated by values of nodes seen earlier, the amount of pruning by AlphaBeta algorithm will depend upon the leaves seen earlier. If the better moves for both sides are explored earlier then the window of a-bound and -bound will shrink faster and more cutoffs will take place. In particular, if the node whose value is backed up to the root, and which represents the best moves from both sides, is found earlier, the number of cutoffs will increase significantly. In the above figure, one can observe that the minimax value comes from the right half of the tree. Let us flip the tree about the root by reversing the order of the leaves and run the AlphaBeta procedure on the reversed tree. The resulting cutoffs are shown in Fi