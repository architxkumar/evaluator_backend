nodes on the path or setting back-pointers to ancestor nodes along the path. Breadth-First Search Breadth-first searches are performed by exploring all nodes at a given depth before proceeding to the next level. This means that all immediate children of nodes are explored before any of the children's children are considered. Breadth first tree search is illustrated in Figure 9.7. It has the obvious advantage of always finding a minimal path length solution when one exists. However, a great many nodes may need to be explored before a solution is found, especially if the tree is very full. An algorithm for the breadth-first search is quite simple. It uses a queue structure to hold all generated but still unexplored nodes-. The order in which nodes are placed on the queue for removal and exploration determines the type of search. The breadth-first algorithm proceeds as follows. BREADTH-FIRST SEARCH 1. Place the starting node s on the queue. 2. If the queue is empty, return failure and stop. 3. If the first element on the queue is a goal node g. return success and stop. Otherwise, - - Figure 9.7 Breadth-first search of tree. lie Search and Control Strategies Chap. 9 4. Remove and expand the first element from the queue and place all the children at the end of the queue in any order. 5. Return to step 2. The time complexity of the breadth-first search is 0(b"). This can be seen by noting that all nodes up to the goal depth d are generated. Therefore, the number generated is b + b + . + W which is 0(b"). The space complexity is also 0(b) since all nodes at a given depth must be stored, in order to generate the nodes at the next depth, that is, bd I nodes must be stored at depth d - I to generate nodes at depth d, which gives space complexity of 0(//'). The use of both exponential time and space is one of the main drawbacks of the breadth-first search. Depth-First Search Depth-first searches are performed by diving downward into a tree as quickly as possible. It does this 