edure described in 4 could lead to a problematic situation. One could initialize the counter Cy to tin the action that adds , and start counting down. One could now add a dummy fluent 8 to the precondition of all actions that add w and in the initial state, and include 6 as an add effect. Also, include (at-end 6) as a goal. Introduce another action to delete Bwhen the counter reaches a value 0. However, if is added more than once, it would cause a problem because multiple instances of the counter will exist but the first one which becomes 0 will result in B getting deleted once for all. . The constraint (hold-during t, fo ) requires that be true at level t, and remain true at least till level fg is reached. This can be achieved by modifying the backward search phase by adding the goal starting at level (2 1) till the level t,. First achieve within t,; using counter. Add A to add effect of those actions. when counter is zero also add B. If something deletes , also delete B (?) 10. The constraint (hold-after t ) says that must be true in all levels after t. This can be achieved by adding the fluent to the goal set at each level, until level t is reached. N o oO 10.6.1 Preferences So far, the planning problems we have looked at have goals, and trajectory constraints, that have to be satisfied completely for a plan to be valid. If any goal condition is not satisfied, then the plan is not valid. We call these kinds of goals as strong goals, or strong trajectory constraints. In contrast, we can define planning problems in which we have goals that we would like to satisfy, but we may still accept a plan that fails to satisfy some goal or trajectory constraint. Of course, we would evaluate such a plan as being of lower quality as compared to a plan that satisfies more or all the goals. We call such goals that we are willing to do without if need be, as soft goals or soft constraints or preferences. Preferences are desired goals and trajectory constraints and some preference