blems to a common representation, for example constraint satisfaction, for which existing algorithms can be used. 1. The first two constraints g and (at-end ) are the STRIPS goals that have to be achieved in the final state. 2. The constraint (always ) requires that be true in all states in the trajectory, and can never be deleted. It can be handled by removing all actions that have in their delete list. This can be done in a preprocessing phase. Also, if is not true in the initial state, the planner can return failure immediately. 3. The constraint (sometimes ) requires that there is at least one state in the trajectory in which 9 is true. This can be handled by adding a dummy effect 6 to all the actions that have in their add effects, and adding the constraint (at-end 6). This will ensure that one of the actions is included at least once in the plan. 4. The constraint (within t ) requires that the fluent should appear in the layer number t or earlier. Add a dummy fluent 6 to all the actions that have 9 in their add effects. Modify the backward search procedure to include 6 as a goal when it reaches level f. Another approach that is applied in the forward phase, and does not require modifying the procedure is as follows. One could include a CountDown action that decrements a non-negative counter Cy (a metric fluent). This action would have a counter with a value greater than 0 as a precondition, and a decremented counter as an effect. One could initialize the counter Cg to in the initial state, and start counting down. Exactly one instance of this action will appear as a parallel action in the first t levels in the plan. One could now add a dummy fluent 8 to the precondition of all actions that add and in the initial state, and include 6 as an add effect. Also, include (at-end 0) as a goal. Introduce another action to delete 6 when the counter reaches a value 0. . The constraint (at-most-once ) requires the fluent g be added at most once in the plan. This means tha