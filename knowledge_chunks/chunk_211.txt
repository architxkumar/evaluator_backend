 instead of G and finds the shorter path to G. This happened because it underestimated the cost of reaching the goal through P. The algorithm A is described below. Like the Dijkstra s Algorithm, it uses a graph structure but one which it generates on a need basis during search. It is also called a graph search algorithm. t keeps track of the best route it has found so far to every node on the OPEN and CLOSED, via the parent link. Since it may find cheaper routes to nodes it has already expanded, a provision to pass on any improvements in cost to successors of nodes generated earlier, has to be made. Procedure A () l open List(start) 2 f(start) h(start) 3 parent(start) NIL 4 closed 5 while open is not EMPTY do 7 Remove node n from open such that f(n) has the lowest value 8 Add n to closed 9 if GoalTest(n) TRUE 10 then return ReconstructPath(n) ll neighbours MoveGen(n) 12 for each me neighbours 13 do switch 14 case miopen AND miclosed : 7 new node 15 Add m to open 16 Parent(m) an 17 g(m) g(n) k(n, m 18 f(m) g(m) A(m) ig 20 case m open: 21 if (g(n) k(n, m)) g(m) 22 then parent(m) a 23 g(m) g(n) k(n, m) 24 E(m) g(m) h(m) 25 26 case me closed : like above case 27 aif (g(n) k(n, m)) g(m) 28 then parent(m) a 29 g(m) g(n) k(n, m) 30 f(m) gim) A(m) 31 PropagateImprovement (m) 32 return FAILURE PropagateImprovement (m) 1 neighbours MoveGen(m) 2 for each s neighbours 3 do newGvalue g(m) k(m, 5s) 4 if newGvalue g(s) 5 then parent(s) m g(s) newGvalue 7 if se closed 8 then PropagateImprovement (s) FIGURE 5.14 Algorithm A . The representation used here is different from the nodePair representation introduced in Chapter 2. Instead, an explicit parent pointer is maintained. This has been done because we want to keep only one copy of each node, and reassign parents when the need arises. Consequently, the definition of the ReconstructPath function will change. The revised definition is left as an exercise for the user. In the following example, the node labelled N is about to be expan