cycle. It is computationally the most expensive of the three. The algorithm is given in Figure 9.8. AC-1 (X, D, C) repeat for each xeXx for e ach yeX such that CyyE C D, Revise (D,, dD, Ryy) Dd, Revise (Dy, Dy, Ryy) until no domain is changed return (X, D, C) NO Pe wD a FIGURE 9.8 The algorithm AC-1 takes as input a CSP and returns an equivalent CSP that is arc consistent. It calls algorithm Revise with all edges in the constraint graph till quiescence is reached. Let there be e constraints in the CSP. Given e edges in the constraint graph and at most k values per domain then one cycle of AC-1 has complexity O(ek2). If there are n variables then the maximum number of values is nk, and in the worst case one value is removed per cycle. Therefore, in the worst case, the complexity of AC-1 is O(nek ). If only a few variables participate in constraints then there can be at most 2e variables, two for each constraint. The complexity can then be estimated to be O(e2k ). The algorithm AC-1 blindly applies Revise to all pairs of variables, irrespective of whether their domains have changed or not. The algorithm AC-32 keeps tracks of removal of elements from domains. Only if a value for variable x is removed, does AC-3 look again at other variables connected to x via some edge. 1 queue ( ) 2 for each pair (xy, xj) that participates in a constraint C,; 3 enqueue ((4,, x;), queue) 4 enqueue ((x;, x,), queue) 5S while not (empty (queue) ) varPair dequeue (queue) 7 x Head(varPair) 8 y Head(Tail(varPair)) s D, Revise (Dy, Dy, Ry) 10 if D, has changed 11 then for each z which is connected to x such that z x andz y 12 enqueue ((z, x), queue) 13return (X, D, C) FIGURE 9.9 Like AC-1, the algorithm AC-3 first calls Revise for each pair of variables that participate in a constraint. After the first round however, AC-3 looks at only those domains whose values might have lost support because of the removal of some elements by Revise. Algorithm AC-3 processes each constraint at most 2k time