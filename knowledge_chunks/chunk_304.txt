Plan (pickup (B), stack(B, C), pickup(A), stacx(A, 8)) The reader would have noticed that the algorithm has made some choices in the above execution. Choice points occur when there is more than one way of achieving a goal predicate. For example, the above trace has to find actions to achieve the goal predicate holding(B). This can be achieved either by picking up block B from the table, or by unstacking it from some other block. Which block to unstack it from, would also be a choice point. Likewise, if the robot is holding a block, and the goal predicate being addressed is armempty, it has to decide where to put that block. One approach would be to introduce backtracking here. Another would be to do some secondary reasoning to resolve this choice. For example, one could look at the state to see which action would be appropriate. In the example trace, this would tell us that since block B is on the table, one can assume that nothing will disturb it till the time comes for holding(B) to be made true, the correct action is pickup(B). The choice can also be resolved by looking at the goal set. If, for example, the robot is holding a block (say) M, and the goal has a predicate on(M, N) then a good way to achieve armempty would be to use the action stack(M, N). A different kind of choice is concerned with the order of attempting subgoals. By pushing the subgoals onto the stack one by one, the algorithm is serializing them. The order in which you attempt subgoals is obviously going to affect performance. In the given trace, the algorithm chose to solve for on(B, C) first. This turned out to be a good choice, and after stacking B on C, the algorithm stacked A on B. What if the order had been reversed? The algorithm would have first stacked A on B to reach the state, S onTable(B), onTable(C), clear(A), clear(C), on(A, B), armempty . Then to achieve on(B, C) it would need to stack B on C, for which it would need holding(B), for which it would have to pickup(B), for which it w