he value being considered, the main algorithm needs to be able to restore the values if it backtracks. In the algorithm below, this is done by maintaining copies of al! domains at each level in the search tree. Steps 11-13 in the algorithm restore domains on backtracking to as they were, before this variable was processed. Steps 17-19 make copies when advancing to the next variable. The simplest consistency check is to make sure that no domain of a future variable is made empty. This was illustrated earlier with the 6queen problem in Figure 9.3. The procedure SelectValue-FC is described below. Backtracking-with-LcookAhnead (X, D, C) 1 Ae (()) 2 for ie ilton 3 do D., D, 4 Dip Dz; s iel while 1s ign 7 do a, SelectValue-X(i, A, C) 8 if a, null S then ic i-l 1 A Tail(A) 11 iflsi 2 then for k i l ton 13 do Diy Disary 14 else 1s A Cons(a,, A) 16 iei-ri 17 if ign 18 then for k iton 19 do Dey Dis-asy 20 return Tail (Reverse (A) ) FIGURE 9.35 Backtracking with Lookahead prunes domains of forward variables. When it backtracks, it needs to undo the pruning done at current level. For this, it keeps mains domains for each variable at each level, and restores pruned domains for future variables when it backtracks. The call to SelectValue does not have domains as parameters since we have assumed them to be globally visible. 9.7.1 Forward Checking In the previous example in Figure 9.34, the variable C has two values in the domain. Of these, C b gets precluded when B b is assigned, and C rgets precluded when A ris assigned. The algorithm Backtracking would see this, only when the turn of variable C comes. The forward checking procedure would not have chosen the second assignment B b because it removes values from future domains that are directly conflicting with the value being considered and rejects the value if any future domain becomes empty due to that. The algorithm SelectValue-FC in Figure 9.36 starts off by backing up copies of domains Di, i k n (steps 1-2). The domain Dj con