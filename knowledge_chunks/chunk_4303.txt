 Bill s father. A sequential implementation would try to satisfy the first condition, and then, if that failed, try the second condition. There is no reason, however, why these two paths could not be pursued in parallel.! In AND-parallelism, the portions of a conjunctive goal are pursued in parallel. Consider the clause: infieldfly (x X) :- fly(X), infieldcatchable(X), oceupiedbase(first), outs(zero). In PROLOG, clauses are matched sequentially from top to bottom. If PROLOG programmers write code that depends on this behavior. OR-parallelism may yield undesired results. 336 Artificial Intelligence _ SOREN RU ee NEN CEN TRESTLE ARER BATRA Here, the four conditions can be checked in parallel, possibly leading to a four-fold speedup in processing infieldf1ly queries. Such AND-parallelism is not so straightforward when variables are shared across goals, as in: uncle{X, Y) :- mother (Z,Y), sibling(X,Z). The mother (Z, Y)and sibling (X,2Z) conditions cannot be satisfied independently, since they must instantiate the variable Z in the same manner. Research on parallel logic programming shares the same goal as that on parallel production systems: to permit the efficient execution of high-level, easily written code for AI systems. 16.2.3 Parallelizing Al Algorithms Some problems are more amenable to parallel solutions than others. While nine authors may be able to write a book much faster than one author (if they each write separate chapters), nine women cannot bear a child any faster than one can. Likewise, throwing more processors at an AI problem may not bring the desired benefits. One example of an inherently sequential problem in AI is unification (recall Section 5.4.4). While multiple processors can help somewhat [Vitter and Simons, 1986], formal arguments [Dwork e a/., 1984] show that vast speedups in the unification of large terms are not possible. Many problems can be solved efficiently by parallel methods, but it is not always a simple matter to convert a sequentia