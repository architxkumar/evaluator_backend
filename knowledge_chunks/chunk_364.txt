the best move for MAX. It calls algorithm Minimax with each of its successors and keeps track of which successor yields the best value. Figure 8.19 depicts the tree searched by the algorithm Minimax and BestMove for a synthetic game tree. The tree is a binary tree, with two choices to each player at each level. The values for the evaluation at the 4-ply level have been arbitrarily chosen. BestMove Eee Pane () 2 a s Sse aa SD 5S O OO QO O FIGURE 8.19 The algorithm BestMove calls algorithm Minimax for each of the successors of root, which computes the minimax value of each of them. It then chooses the best successor and returns that as the best move. The Minimax algorithm above is the one that is doing the search. The BestMove algorithm is simply a modification to keep track of the best move found by Minimax. In Exercise 6, the reader is asked to modify the algorithm, so that the moves available to MAX at the next turn (after two plies) are stored along with their backed-up values. We will see in the following section how to exploit this information. The algorithm Minimax finds the best move after searching the entire tree k-ply deep. There are, however, situations when it is not necessary to continue searching. This happens when it is known that searching further does have any scope of improvement. The simplest case is when a winning move has already been found, as shown in Figure 8.20. FIGURE 8.20 When a winning move has been found, the other options need not be explored. 8.2.2 Algorithm AlphaBeta In the above figure, MAX has found a successor that evaluates to Large. Since one cannot hope to improve upon, it does not make sense to search any further. We say that the search tree has been pruned. For pruning to happen, it is not necessary that a winning move has been found. It can also happen that during exploration it becomes clear that a particular child of a node cannot offer to improve upon the value delivered by a sibling. In that case, that node need not be exp