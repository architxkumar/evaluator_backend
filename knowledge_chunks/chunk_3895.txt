potted(agent(John), object(Sue)) Such a representation would make it easy to answer questions such as: Who spotted Sue? But now suppose we want to know: Did John see Sue? The obvious answer is yes, but given only the one fact we have, we cannot discover that answer, We: could, of course, add other facts, such as spotted(x, y) > saw(x, y) We could then infer the answer to the question. An alternative solution to this problem is to represent the fact that spotting is really a special type of seeing explicitly in the representation of the fact. We might write something such as saw(agent(John), object(Sue), timespan(briefly)) In this representation, we have broken the idea of spotting apart into more primitive concepts of seeing and timespan. Using this representation, the fact that John saw Sue is immediately accessible. But the fact that he spotted her is more difficult to get to. The major advantage of converting all statements into a representation in terms of a small set of primitives is that the rules that are used to derive inferences from that knowledge need be written only in terms of the primitives rather than in terms of the many ways in which the knowledge may originally have appeared. Thus what is really being argued for is simply some sort of canonical form. Several A] programs, including those described by Schank and Abelson [1977] and Wilks [1972], are based on knowledge bases described in terms of a small number of low-level primitives. 1 The arguments agent and object are usually called cases. They represent roles involved in the event. This semantic way of analyzing sentences contrasts with the probably more familiar syntactic approach in which sentences have a surtace subject. direct object, indirect object, and so forth. We will discuss case grammar {Fillmore, 1968} and its use in natura] language understanding in Section 15.3.2. For the moment, you can safely assume that the cases mean what their names suggest. 90 Artificial Intelligence P D John< 