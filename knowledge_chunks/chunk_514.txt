bus ?from) (in jeena ?bus)) reffect (and (not (at ?bus ?from)) (at ?bus ?to) (not (at jeena ?from)) (at jeena ?to)))) (:action driveBus4 iparameters (?hus -bus ?from ?to - location) precondition (and (at ?bus ?from) (in aditi ?bus) (in jeena ?bus)) reffect (and (not (at ?bus ?from)) (at 2bus ?to) (not (at aditi ?from)) (at aditi ?to)) (not (at jeena ?from)) (at jeena ?to)))) However, converting actions into aspects can result in a blow-up in the number of actions the planner has to deal with, and an approach to handle them directly would be desirable. One such approach to extend Graphplan to conditional effects was implemented in a planner called IP? (Koehler et al., 1997). The planning graph construction process for IP2 in the way the new proposition layer is constructed. The operator o with conditional effects can be characterized as, prec, : the preconditions add, : the unconditional add effects del, : the unconditional delete effects prec; ... add;, del; : the i conditional effect Like in Graphplan, an instance of the operator is added to the layer Aj, if the preconditions precy are present in the (f 1)" layer Pi nonmutex amongst themselves. The unconditional add effects add, are then added to the j" proposition layer P;, and if any proposition pedel, is present in P; then a delete link is added between the action and p. After that, for every conditional effect (prec; D addj, del;), a proposition pe add; is added to the j "" layer P if the following conditions hold. 1. prec; S P;4 2. All propositions in prec; are nonmutex with each other in P; ; 3. All propositions in prec; are nonmutex with all propositions in prec, in Py When all the goal propositions show up nonmutex in k!" proposition layer, P2 algorithm embarks upon a plan finding search. Here too, it differs a little from Graphplan, in that as it searches backward it also maintains a set of negative goal sets C; in layers j k preceding the last layer, along with subgoal sets G;. These negative goal proposi