 A: on (X, Y) A clear (X) A armempty D: holding (X) A clear (Y) Notice that when one picks up a block X, either with STACK or PICKUP, the operators do not delete the assertion clear(X). When we put it down, the assertion will already exist in the database. This will not cause a problem with the reasoning, and in fact save some computation, and it is anyway not clear what clear(X) would mean when it is being held. An encoding of the blocks world domain in PDDL is given in the accompanying Box 7.1. Observe that the notation used there combines the add list and the delete list into a common set of effects. The facts from the delete list are preceded by a not , to depict that the fact is not true in the resulting state. This is consistent with the PDDL standard that evolved later. Also shown is the coding of a small planning problem. Another important observation is that the goal description may not describe the final state completely. In the above illustration in Figure 7.2, nothing is said about the location of blocks A and J. Likewise, it is not stated what if anything is on B and J. There can be many states in which the given goal conditions will be true. As we will see, this also implies that backward reasoning will have to deal with incomplete state descriptions. Definition We say that a state S satisfies a goal G iff GC S. Box 7.1: The Blocks World Domain in PDDL The blocks world domain may be described using a typed version of PDDL (PDDL3.0) which is given below. This also introduces the notion of variable types. Also note that add list and the delete list from the STRIPS notation is combined into an effects list. (define (domain Blocks) Blocks is a domain dealing with block types (:requirements :typing) (:types block) (:predicates (on ?x - block ?y - block) The predicates used for (onTable ?x - block) describing the situation (holding ?x - block) (clear ?x - block) (armempty) ) Given below are the four kinds of actions defined in the Blocks domain (:action pick