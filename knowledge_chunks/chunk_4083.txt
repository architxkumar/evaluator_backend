th the metaclass are attributes that each instance (i.e., each actual slot) will inherit. Each slot, since it is a relation, has a domain and a range. We represent the domain in the slot labeled domain. We break up the representation of the range into two parts: range gives the class of which elements of the rangemust be elements; range-constraint contains a logical expression that further constrains the range to be elements of range that also satisfy the constraint. /f rangeconstraint is absent, it is taken to be TRUE. The advantage to breaking the description apart into these two pieces is that type checking is much cheaper than is arbitrary constraint checking, so it is useful to be able to do it separately and early during some reasoning processes. The other slots do what you would expect from their names. If there is a value for definition, it must be propagated to all instances of the slot. If there is a value for defauit, that value is inherited to all instances of Weak Slot-and-Filler Structures 199 the slot unless there is an overriding value. The attribute transfers-through lists other slots from which values for this slot can be derived through inheritance. The to-compute slot contains a procedure for deriving its value. The inverse attribute contains the inverse of the slot. Although in principle all slots have inverses, sometimes they are not useful enough in reasoning to be worth representing. And single-valued is used to mark the special cases in which the slot is a function and so can have only one value. Of course, there is no advantage to representing these properties of slots if there is no reasoning mechanism that exploits them. In the rest of our discussion, we assume that the frame-system interpreter knows how to reason with all of these slots of slots as part of its built-in reasoning capability. In particular, we assume that it is capable of performing the following reasoning actions: Consistency checking to verify that when a slot value is a