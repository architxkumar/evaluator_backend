ehind B B is to ignore those regions of a search space that are known not to contain a better solution. We look at an example in which the cost of a move corresponds to the length of an edge in a graph. Then the least cost solution corresponds to the shortest path in the graph. Let the graph in Figure 5.3 represent a tiny search space to illustrate the algorithm. B B begins with the start node S. The partial cost of S is zero. It expands S, generating partial paths S-A with cost 3, S-B with cost 4 and S-C with cost 8. These paths are stored in the list OPEN. S is transferred to list CLOSED, shown shaded in Figure 5.4. B B continues extending the cheapest partial path. It terminates when the goal node is picked for expansion. The example in Figure 5.4 shows Branch Bound extending partial solutions. This is an example of state space search. We have seen earlier (Chapter 3) that when the search space is made up of candidate solutions, we search in the solution space. If the candidate solution is only partially specified then we can think of it as a set of solutions that share the specified part. A refinement operator partitions this set into two sets by specifying another component of the solution. Each (complete) candidate from the set is some complete refinement of the partially specified solution. Search, then involves, decisions amongst the different possible refinements of a given partial solution (Kambhampati, 1997). That is, search involves choosing a refinement of some candidate by specifying more information. It is interesting to note that the state space search algorithms seen earlier are a special case of refinement, in which the partial solution specifies the path from the start node to some node n, and the choice is between different extensions of the partial path. S: Start G: Goal FIGURE 5.3 A tiny search graph. Observe that even though a path to G has been found B B continues by expanding C which is cheaper. Let s say between G, D, and C (cost 10) our al