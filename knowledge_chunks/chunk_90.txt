pushes into the search tree, it will always find the shortest solution. So, this is one feature where BFS is better than DFS. In fact, if the search space is infinite, there is a danger that DFS will go into a never-ending path and never return a solution! Consider the task of finding a pair of two integers m,n which satisfy some given property. Let the moveGen for each state x, y return two states x 1,y and x,y 1 . Let the goal state be 46, 64 and the start state be 0,0 . The reader is encouraged to simulate the problem on paper and verify that DFS would get lost in an infinite branch. One way to guard against this possibility is to impose a depth bound on the search algorithm. This means that the search space is prohibited from going beyond a specified depth. This could be done if for some reason one wanted solutions only within a certain length. 2.7 Depth Bounded DFS (DBDFS) Figure 2.20 shows a depth bounded DFS algorithm. It is different from DFS, in that it takes a parameter for depth bound. Given any node, it calls moveGen only if it is within the given depth bound. The node representation is changed to include depth of node as the third parameter, apart from the parent link, which is the second parameter. The function makePairs is modified appropriately to compute the depth of a node, by adding one to the depth of its parent. The astute reader would have observed that implementing DBDFS would have been simpler with the node representation that stored the complete path. One would just have to look at the length of the node to determine whether one is within the allowable bound. And in addition, the task of reconstructing the path is also simplified. Obviously, various design choices will have to be made while implementing solutions for specific problems. DepthBoundedDFS (start, depthBound) open ((start, NIL, 0)) closed () while not Null (open) do nodePair Head(open) node Head (nodePair) if GoalTest (node) TRUE then return Reconstruct Path Bw (nodePair, closed)