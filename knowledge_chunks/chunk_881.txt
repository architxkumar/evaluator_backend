ngth of the descriptions, as opposed to theorem proving in FOL that can, in the worst case, be intractable. Observe that though there is a recursive element in matching components of the form ALL r d , the algorithm works with normalized expressions which have the recursive definitions made explicit, resulting in correspondingly longer expressions. However, the structure matching algorithm works only for a subset of concepts that can be defined in FOL. Thus, we trade expressivity for computational complexity when we choose to represent concepts in Description Logic. The non-logical elements of the language are of three kinds: concept names, relation names, and constants. The concept forming operators we have used are AND, EXISTS, ALL, and FILLS. The operator EXISTS n r says that the elements of the set (concept) must be related by r to at least n elements. We can define another operator AT-MOST n j that says the elements must be connected to at most n elements (Brachman and Levesque, 2004). It turns out that if we do that then structure matching would no longer work. Consider the class of families, all whose members are wizards and in which there is exactly one child named Harry. Pfamily AND ALL :Member Wiz FILLS :Member harry EXISTS 1 :Child AT-MOST 1 :Child FILLS :Child harry This class would include the Potter family, pFamily AND Pfamily FILLS :Member james FILLS :Member lily Now the Pfamily concept is a subclass of the Wfamily concept in which ail the kids are wizards, Wfamily ALL :Child Wiz and Pfamily Wfamily But it is clear that the structure matching is unable to conclude that the Pfamily is subsumed by the Wfamily (because the Pfamily simply does not have a clause of the type ALL :Child ... ). The subsumption holds because Harry, the only child in the Pfamily class, is a wizard because all members of Pfamily are wizards stated in ALL :Member Wiz . Hence, Pfamily is a type of family in which all the children are wizards. Structure mapping cannot cater to suc