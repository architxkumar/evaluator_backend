oals may have differing amounts of penalties associated with them makes the planning problem an optimization problem of greater complexity. At the same time, researchers started employing artificial intelligence techniques to sophisticated problems. The most spectacular applications have been in space, but interest in autonomous robots, whether in the domestic environments or in the depths of the oceans, offers considerable motivation for applying planning techniques in the real world. These applications demand that planning algorithms be embedded in larger systems which can sense and react in a real world. Such applications require a greater amount of integration of different problem solving techniques. They also demand more robust and efficient knowledge representation and reasoning, which will be our focus in the next few chapters. ) e a Exercises 1. Given the following initial state On(A, C), On(B, D), OnT(C), OnT(D), Clear(A), Clear(B). ArmE and the goal OnT(A), OnT(B) , simulate the Graphplan algorithm on paper and generate a plan. 2. Define the algorithms MutexA and MutexP to determine whether two actions in a layer or two propositions in a layer of the planning graph are respectively mutex. Find all the subgoal sets at the level k-1 for the planning graph in Figure 10.8. 4. Write the procedure RegressGoalSet(G, i, PlanGraph) employed in the ExtractPlan procedure of Figure 10.10. Your procedure should return the set of all subgoal sets that can be regressed to from the given goal set G. Rewrite the ExtractPlan procedure of Figure 10.10, removing the nondeterministic CHOOSE action and employing a backtracking like procedure (see Chapter 9). 6. Define the function SizeSubgoalSets used in the algorithm Graphplan in Figure 10.7. The function should get the value by inspecting the memoized memory mem maintained by ExtractPlan. Given the set of predicates (:predicates (clear ?b) (on-table ?b) (empty ?h) (holding ?h ?b) (on ?b1 ?b2) (hand 7h) (block ?b)) in untyped 