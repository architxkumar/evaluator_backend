ected. The reader should recall that each leaf is an upper bound on the value of a strategy. When it has finished with all the MAX siblings then the (MIN) parent is inserted in OPEN with the label SOLVED. If a SOLVED MIN node is picked by SSS , its MAX parent can be labelled SOLVED, and its siblings removed. This is because its siblings have lower upper bounds (since the MIN node was at the head of OPEN). Contrariwise, when a SOLVED MAX node is picked by SSS , its siblings are added to the OPEN with the same h value. This will be recursively solved by SSS . The algorithm terminates when, like in AO , the root is labelled SOLVED. SSS : The Example Revisited Let us explore how the algorithm SSS arrives at the solution shown in Figure 8.32, redrawn as Figure 8.34 with names assigned to the nodes explored by the algorithm. Initially, the algorithm begins with the root added to the open list. OPEN ( root, LIVE, LARGE ) This is the only node in OPEN, and is a MAX node. It is removed from OPEN and all (both) its successors added to OPEN. These are MIN nodes, and in turn replaced by one child. This process continues (Lines 7-13) till the horizon is reached. The open list now looks like this: OPEN ( A1, LIVE LARGE , B1, LIVE LARGE , C1, LIVE LARGE , D1, LIVE LARGE ) The node at the head is removed and the evaluation function is applied to these four nodes one by one in Line 15. The new value of each node is the one returned by the evaluation function, and they are arranged in a sorted order as shown below. OPEN ( D1, SOLVED, 11 , A1, SOLVED, 10 , B1, SOLVED, 7 , C1, SOLVED, 5 ) SSS (root) 1 open ( root, LIVE, LARGE ) 2 repeat 3 Remove node p J, s, h from head of open 4 if J root AND s SOLVED 5 then return h return when root is SOLVED 6 else if s LIVE 7 then if J is non-terminal 8 then if J is MAX 9 then for j b tol bi branching factor 10 do J-j is the j child of J 11 open Cons( J j, LIVE, h , open) 12 else only first child for MIN node 13 open Cons( Jl, LIVE, h , open) 14 el