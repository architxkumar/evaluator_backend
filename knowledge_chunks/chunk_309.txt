e ll if no such action exists 12 then return FAIL 13 subPlan RecursiveGSP(state, Preconditions(a), actions) 14 searches in the backward fashion 15 if subPlan FAIL 16 then return FAIL 17 else a deterministic version will backtrack 18 state PlanProgress(subPlan, state) 19 progresses State in the forward direction 20 state Progress(a, state) 21 assembles plan in the forward direction 22 plan (plan supPlan- a) Figure 7.11 Recursive GSP illustrates the dual nature of GSP. It considers actions by their relevance, but selects them only on applicability. For simplicity, we write a nondeterministic version with a CHOOSE operator that makes the correct choice. The deterministic version may make a wrong choice, but backtrack to try again. PlanProgress(plan, state) 1 if Empty(plan) 2 then return state 3 else state Progress(Head(plan), state) 4 return PlanProgress(Tail(pian), state) Figure 7.12 Algorithm PlanProgress iteratively progresses over the actions in a plan. As planning proceeds, more actions are added to the plan. Interestingly, there is no constraint on where actions should be added. State space planning algorithms grow linear, partial plans at one end. Plan space methods separate the tasks of selection of an action and its placement in the plan. In addition to the set of actions, the plan representation contains links between actions. The links are of two types. The first, called ordering links, are used to capture ordering information where it is known. The initial plan for example, has a default link (Ag A). to assert that the start action Ag happens before the end action A... The second kind of link, first introduced in a system called NONLIN (Tate, 1977), is called a causal link. A causal link (Aj, P, Aj) between two actions A; and A; can be established when an affect P of action A; is a precondition for action Aj. Action A; is the producer of predicate P, and action A; is the consumer of P. Figure 7.15 illustrates a causal link between the two actions Pickup(A) 