tion tree T0. Sec. 9.7 Summary 185 3. Select a node n that is both on open and a part of T0. Remove n from open and place it on closed. 4. If n is a terminal goal node, label n as solved. If the solution of n results in any of n's ancestors being solved, label all the ancestors as solved. If the start node s is solved, exit with success where 7'0 is the solution tree. Remove from open all nodes with a solved ancestor. S. If n is not a solvable node (operators cannot be applied), label n as unsolvable. If the start node is labeled as unsolvable, exit with failure. If any of it's ancestors become unsolvable because it is, label them unsolvable as well. Remove from open all nodes with unsolvable ancestors. 6. Otherwise, expand node a generating all of its successors. For each such successor node that Contains more than one subproblem, generate their successors to give individual subproblems. Attach to each newly generated node a back pointer to its predecessor. Compute the cost estimate h* for each newly generated node and place all such nodes that do not yet have descendents on open. Next, recompute the values of h* at n and each ancestor of n: 7. Return to step 1 It can be shown that AO* will always find a minimum-cost solution tree if one exists, provided only that h*(n) h(n), and all arc costs are positive. Like A*, the efficiency depends on how closely h* approximates it. 9.7 SUMMARY Search is characteristic of almost all Al problems. We find search in natural language understanding and generation, in machine vision, in planning and problem solvers, in expert systems, in game playing programs, and in machine learning. It should not he too surprising then that much effort has been devoted to finding efficient search strategies. Search strategies can be compared by their time and space complexities using big 0 notation. It is important to determine the complexity of a given strategy before investing too much programming effort, since many search problems are intract