 does not know what should be unstacked from A to achieve clear(A). Furthermore, in the action unstack(?X, A) required for clear(A), the variable ?X can be bound only to G. This is because unstack(?X, A) also results in holding(?X), and the goal set requires holding(G) to be true. However, this connection between the requirements of the two predicates ho ding(G) and clear(A) requires some more sophisticated reasoning. Perhaps some kind of consistency check can force the binding of 2X to G. on(G, A) non(B, J) stack(G, A) stack(B, J) we holding(G) a clear(A) a on(B, J) holding (B) a clear(J) a on(G, A) Neat 7 Ss. pee ae pickup(G) unstack(G, X) unstack(X, A) stack(B, J) AA - What should Unstack would be How can you stack B on be instantiated needed only if clear(A) J and end up holding G to? was not already true. in the resultant state? Figure 7.5 BSSP does not have a concrete state description to work with! The last action stack(B, J) causes a more serious problem. It is meant to achieve the fact on(B, J). But one can notice that the robot arm could not be holding block G (asserted in the given goal) and block B (required for the stack action) at the same time. This shows that the algorithm could be reasoning with collections of facts that are not states. Figure 7.6 illustrates how a sequence of actions that is not a plan could be found by unhindered backward search. We consider a simple problem where in the given state three blocks, A, B and C, are on the table, and the goal is to stack A on B, and B on C. The figure shows a possible trace that backward search, using the regression process, might result in. The reader is encouraged to verify that at each stage of backward search the action chosen is relevant. The reason why progression over states with planning operators works while regression does not, is that the operators are not symmetrical. They are designed to represent actions. An action converts a given state into a successor state. The applicability of the a