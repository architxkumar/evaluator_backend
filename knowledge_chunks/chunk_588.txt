 (at-end 0) as a goal. Introduce another action to delete 6 when the counter reaches a value 0. . The constraint (at-most-once ) requires the fluent g be added at most once in the plan. This means that when it is added once, it should not be possible to add it again. This can be achieved by adding a dummy fluent 6 to the initial state, to the precondition list of all actions that add g, and to the delete list of all those actions. Since 0 is deleted by any action that adds , no other action that adds 9 can be selected since 6 is a precondition for that action. The constraint (sometime-after w) requires that if the fluent is added in some state in the trajectory then w must be added in a state that is later in the trajectory. Observe that one yw can account for multiple occurrences of . The following modifications can be used to satisfy this constraint. Add a dummy predicate 6 to the initial state, as an (at-end 5) goal, to the delete effects of all actions that a 2 add , and to the add effects of all actions that add w. . The constraint (sometime-before g w) says that any occurrence of g in a state must follow a w in a preceding state. This means that if an action adds then an earlier action must have added w. This can be satisfied easily by adding a dummy fluent 6 to the add effects of all actions that add w, and as a precondition for all actions that add 9. The constraint (always-within t w) is like (within t w) except that every time is added to a state then w must be added within t steps. Add a dummy predicate 6 to the initial state, to the delete effects of all actions that add , and to the add effects of all actions that add w. Modify the backward search phase to return failure, if the consecutive states are without 0. However, an attempt to adapt the forward procedure described in 4 could lead to a problematic situation. One could initialize the counter Cy to tin the action that adds , and start counting down. One could now add a dummy fluent 8 to the precond