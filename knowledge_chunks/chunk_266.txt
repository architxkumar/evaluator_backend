ict Set. Also, the matching algorithm will have tried this rule on all 52 cards and selected 48 out of them. If our algorithm is a simple brute force algorithm then in fact, the rule would have tried matching all the data in the working memory before selecting the 48 instances. In the general case, if a rule has K patterns then each of the patterns will have to be tried with each WME. Thus, if there are R rules, each with K and the working memory has M WMEs, the brute force match algorithm will have to do M R K pattern comparisons. And it will have to do that in each Match-Resolve-Execute cycle because the actions of the selected rule make changes in the working memory. It has been empirically observed that the Match component uses up to eighty to ninety percent of computation time in rule based production systems. Therefore, it would make sense to improve upon the efficiency of the Match algorithm. That is precisely what was done by Charles Forgy when he implemented the OPS5 language. He designed a network, called the Rete network that vastly improved the performance of the Match algorithm. Working memory Rules Match atgorithm Conftict set Figure 6.18 The Match algorithm takes the set of rules and the set of working memory elements and generates the Conflict Set. The rules and the working memory are independent representations. 6.6.6 Rete Algorithm Consider the brute force algorithm mentioned above. Schematically, it is a procedure that takes the set of rules and the working memory as an input, and generates the Conflict Set, as depicted in Figure 6.18. The rules and the working memory are stored separately. The match algorithm tries to match all rules with all permutations of WMEs. Matching each rule involves matching a pattern with a WME, which in turn involves testing for matching attributes within each pattern. The Rete' match algorithm (Forgy, 1982) is based on the following observations. 1. Many patterns share the tests to be done. The same pattern may occur 