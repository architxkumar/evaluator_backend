 plausible-move generator, to search until a goal state is found. The depth of the resulting tree (or graph) and its branching factor are too great. In the amount of time available, it is usually possible to search a tree only ten or twenty moves (called ply in the game-playing literature) deep. Then, in order to choose the best move, the resulting board positions must be compared to discover which is most advantageous. This is done using a static evaluation function, which uses whatever information it has to evaluate individual board positions by estimating how likely they are to lead eventually to a win. Its function is similar to that of the heuristic function A In the A* algorithm: in the absence of complete information, choose the most promising position. Of course, the static evaluation function could simply be applied directly to the positions generated by the proposed moves. But since it is hard to produce a function like this that is very accurate, it is better to apply it as many levels down in the game tree as time permits. A lot of work in game-playing programs has gone into the development of good static evaluation functions, A very simple static evaluation function for chess based on piece advantage was proposed by Turing simply add the values of black s pieces (B), the values of white s pieces (W), and then compute the quotient W/B. A more sophisticated approach was that taken in Samuel s checkers program, in which the static evaluation function was a linear combination of several simple functions, each of which appeared as though it might be 'See Berliner { 1979b] for a discussion of some theoretical issues in the design of static evaluation functions. Game Playing 233 significant. Samuel's functions included, in addition to the obvious one, piece advantage, such things as capability for advancement, contro] of the center, threat of a fork, and mobility. These factors were then combined by attaching to each an appropriate weight and then adding the t