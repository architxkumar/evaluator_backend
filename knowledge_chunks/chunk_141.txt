orithm is given below in Figure 4.7. There are many variations that can be done here, by choosing different cooling schedules. Another variation is one in which probabilistic moves are made only for negative gain moves. SimulatedAnnealing() 1 node random candidate solution or start 2 bestNode node 3 T some large value 4 for time 1 to numberofEpocns do while some termination criteria M cycles in a simple case 6 do 7 neighbour RandomNeighbour (node) 8 SE Eval (neighbour) - Eval (node) 9 if Random(0, 1) 1 (1te ?) 10 then node neighbour iL if Eval(node) Eval (pestNode) as then bestNode node 13 T CoolingFunction(T, time) 14 return bestNode FIGURE 4.7 Simulated Annealing makes probabilistic moves in the search space. We use the function Eval instead of h in the style used in optimization. Function CoolingFunction lowers the temperature after each epoch in which some probabilistic moves are made. Function RandomNeighbour randomly generates one successor of the current node, and Random(0,1) generates a random number in the range 0 to 1 with uniform probability. One way that the SA algorithm is different from the many algorithms we have seen is that it does not do local optimization. It does not look around the neighbourhood of a node for the best neighbour. Instead, it generates one successor or neighbour randomly, and then decides probabilistically whether to move to it or not. Thus, it can easily be used in problems where there are a large number of neighbours for a given node. In domains where one is dealing with real-valued variables, there could potentially be an infinite number of neighbours, like on a real hill; but this would not deter one from writing a search algorithm. 4.3 Genetic Algorithms The natural world around us is a manifestation of life. In the world, and including this world itself, things that persist, persist and things that don't, don t (Grand, 2001). We can say that life is made up of forms that persist. We can also say that the goal of life is pers