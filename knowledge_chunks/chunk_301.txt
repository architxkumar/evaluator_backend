constructed. Goal Stack Planning works by pushing the goal description onto a stack. It pushes both the conjunct, as well as each of the individual goal predicates separately. The algorithm pops the element on the top of the stack. If it is a (goal) predicate that is true in the current state then nothing is done and the next element is popped from the stack. If it is a goal predicate that is not true in the current state, a relevant action is pushed onto the stack, followed by the preconditions first the conjunction, and then the individual preconditions. The precondition on the top of the stack becomes the next subgoal to be addressed recursively. In practice, one may have to choose from a set of relevant actions that is pushed onto the stack. In the algorithm described below, this is shown as a nondeterministic choice by a choose operator. In practice, during implementation, this should be a choice point for a backtracking search algorithm which will try out different actions. If all the preconditions of an action are true in a given state, they will get popped away, and the action will be on the top of the stack. In this case, the action is popped and added to the partial plan being grown in a forward manner. The current state progresses over the chosen action, and planning resumes by looking at the top of the stack. If the stack becomes empty, all the goal predicates have been achieved, and a plan is returned. If at any stage the planner cannot find an action to achieve a goal predicate, the algorithm reports failure. We assume a function PushSet(Set, Stack) that takes a set of goal predicates and (a) pushes the conjunction of the predicates onto the Stack, and (b) also the individual goal predicates in some order. This order may be determined heuristically if possible. For example, in the blocks world domain, holding(Block) should be attempted last because it blocks up the robot arm. If it is solved or achieved first then it could be undone while achieving som