ted as new knowledge becomes available. Thus some kind of search process is necessary. How should it be managed? The final problem is that, in general, these theories are not computationally effective. None of them is decidable. Some are semidecidable, but only in their propositional forms. And none is efficient. In the rest of this chapter, we discuss several computational solutions to these problems. In all of these systems, the reasoning process is separated into two parts: a problem solver that uses whatever mechanism it happens to have to draw conclusions as necessary and a truth maintenance system whose job is just to do the bookkeeping required to provide a solution to our second problem. The various logical issues we have been discussing, as well as the heuristic ones we have raised here are issues in the design of the problem solver. We discuss these issues in Section 7.4. Then in the following sections, we describe techniques for tracking nonmonotonic inferences so that changes to the knowledge base are handled properly. Techniques for doing this can be divided into two classes, determined by their approach to the search control problem: Depth-first, in which we follow a single, most likely path until come new piece of information comes in that forces us to give up this path and find another. Breadth-first, in which we consider all the possibilities as equally likely. We consider them as a group, eliminating some of them as newfacts become available. Eventually, it may happen that only one (or a small number) turn out to be consistent with everything we come to know. It is important to keep in mind throughout the rest of this discussion that there is no exact correspondence between any of the logics that we have described and any of the implementations that we will present. Unfortunately, the details of how the two can be brought together are still unknown. 74 AUGMENTING A PROBLEM-SOLVER So far, we have described a variety of logical formalisms, all of whi