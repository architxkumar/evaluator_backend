g the domains of the variables on each side of each constraint. In the algorithm above, the support sets have been initialized outside the loop at step 4 for simplicity. In practice, they will be constructed inside the loop and only for those labels that are parts of constraints. The queue of unsupported labels is also constructed inside the loop. The size of S is also O(ek?), which is also the value of the sum of all counters. Since in the worst case in the while loop of algorithm AC-4 one counter will get decremented in each cycle, there can be at most O(ek2) cycles, and therefore the complexity of AC-4 is O(ek2). Given that the various data structures have to be stored for AC-4, it can be shown that its space complexity is also O(ek?). AC-4 (xX, D, C) 1 queue, S, counter Initialize(X, D, C) 2 while not (empty (queue) ) 3 varVal dequeue (queue) 4 x Head(varVal) Ss a Head(Tail(varVal)) for each label y, b in Sx, a 7 counter(y, b, x) counter(y, b, x) - 1 8 if counter(y, b, x) 0 3 then D, D b 10 enqueue ((y, b), queue) llreturn (X, D, C) Initialize (X, D, C) 1 queue ( ) for each label x, a 3 Sex, a ) 4 for each constraint Ony ( x, yh, Ryy) iS) S for each bE Dy counter(y, b, x) 0 7 for each a D, 8 counter(x, a, y) 0 9 for each be Dy 10 if a, De Ry 11 counter(x, a, y) counter(x, a, y) 1 12 counter(y, b, x) counter(y, b, x) 1 13 Seg, 2 Sey, wp Y , 2 14 Sex, ax Sex, a UV ( r b 15 if counter(x, a, y) 0 16 D, D a 17 enqueue ((x, a), queue) 18 if counter(y, b, x) 0 19 D, D, b 2 enqueue ((x, 2), queue) 2lreturn queue, S , counter FIGURE 9.10 Unlike AC-1 and AC-3, AC-4 operates at the level of labels, or variable value pairs. For this, it has to do elaborate bookkeeping, keeping track of individual edges in the matching diagram, and degree of each vertex looking out for vertices that get isolated. The complexity measures described above are worst case complexities. They are also asymptotic complexities in which the role of constants does not show up in the comparison. It has 