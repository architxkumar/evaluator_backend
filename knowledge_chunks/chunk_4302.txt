g diminishes. 3. Overhead resulting from communication costs among multiple processors can further reduce the benefits of parallelism. Other architectures behave differently with respect to parallel implementation. The brain-style architectures mentioned above are naturally parallel; in fact, simulating them on sequential machines is often prohibitive because of the high degree of parallelism they assume. In Section 16.3, we discuss some other parallel AI architectures. 16.2.2. Parallelizing Al Programming Languages In the last section, we discussed the benefits of parallelizing a particular kind of program, namely a production system interpreter. Other frequently used interpreters in AI include those for the programming languages LISP and PROLOG. Writing parallel programs is a difficult task for humans, and there is some hope that parallel implementations of these languages (perhaps augmented with parallel programming constructs) will make effective speedups more practical, Parallel LISP models include Multilisp [Halstead, 1988], QLISP [Gabriel and Mc Carthy, 1988], and the Puralation Model [Sabot, 1988]. Parallel PROLOG models include Concurrent PROLOG [Shapiro, 1987], PARLOG [Clark and Gregory, 1986], and Guarded Horn Clauses [Ueda, 1985]. Research into parallel logic programming languages was an important focus of the Japanese Fifth Generation project [ICOT, 1984]. Languages like PROLOG immediately suggest two types of parallelism. In ORparallelism, multiple paths to the same goal are taken in parallel. For example, suppose we have the following clauses: uncle(X, ) :- mother(Z,Y }, sibling(X,2). uncle(X, ) :- father(Z, }, sibling(X,2). Then the query ?- uncle (John, Bill) could be satisfied in two different ways since John could be the sibling of Bill s mother or of Bill s father. A sequential implementation would try to satisfy the first condition, and then, if that failed, try the second condition. There is no reason, however, why these two paths could not be 