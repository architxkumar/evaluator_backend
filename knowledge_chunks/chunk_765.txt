he) bike need not only happen due to adversarial action. It could happen due to the tyres coming into contact with a sharp object such as a nail or a pointed stone, which may or may not result in deflation. This could be modeled using the Releases predicate as follows Releases(hitNail(B), inflated(B), T) Now in some models the bike would be inflated and in some it would not. But since ReleasedAt(inflated(bicycle39), t) would happen at whatever time t the bike hits the nail it will no longer be possible to deduce that the bike (tyre) is inflated at a later point of time, and also therefore none of the conclusions that depend upon the fluent being true. This could also be modeled using a random variable Punctured, called a determining fluent, that could take any random value, true or false, as follows (HoldsAt(inflated(B), T) HoldsAt(Punctured, T)) TepninatesshitNail(B), inflated(B), T) . Being a random variable Punctured is not governed by the commonsense law of inertia. Then in some models Punctured will be true and in some it will be false, and one cannot come to a definitive conclusion about whether the bike is inflated or not. Conceptually the first approach says that hitting a nail releases the fluent inflated from the common-sense law of inertia, and thus one cannot infer whether or not it holds after that. The second approach says that there is a variable, which if it happens to be true, will result in the bike tyre getting deflated. Trajectory The Trajectory predicate is used to relate two related fluents one of which is Initiated by some event in a changing world. In the above example assume that along with loc(Person, Place) we have a fluent dist(Person, Place, Distance) in a one dimensional world, where Distance is of the real number sort. Assume that the bicycle riding event has a duration, and during that duration fluent ridingBike(Person) is true. Then we can express the distance the person has travelled at any given time by a function of the speed. Let