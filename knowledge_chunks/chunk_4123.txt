ions require heuristics to define first or best and thus cannot usually be described in a straightforward way without appealing to the heuristics. Operations that are given resource limitations and whose output depends on how effectively those resources can be used. One common example of such an operation is default reasoning, when it is stated in a form such as, Assume x unless 7x can be shown within z inference steps. The semantics of these operations then depend on how the resources happen to be exploited. Of course, we are not saying that operations with these properties should not be done in reasoning programs. They are necessary. We are only saying that they should be within the control of some domain-specific problem solver rather than hidden within a general-purpose black box. 11.2 LOGIC AND SLOT-AND-FILLER STRUCTURES Slot-and-filler structures have proven very valuable in the efficient storing and retrieving of knowledge for AI programs. They are usually poor, however, when it comes to representing rule-like assertions of the form Tf x, y, and z, then conclude w. Predicate logic, on the other hand, does a reasonable job of representing such assertions, although general reasoning using these assertions is inefficient Slot-and-filler representations are usually more semantic, meaning that their. reasoning procedures are more varied, more efficient, and tied more closely to specific types of knowledge. Hayes [1973] and Nilsson [1980] have shown how slot-and-filler structures can be translated into predicate logic. Concepts become one-place predicates, e.g., dog(x), and slots become two-place predicates, e.g., color(canary, yellow). Inference mechanisms like property inheritance can be expressed in logical notation, as a series of logical implications, which can then be manipulated with resolution. Working through a translation of a slot-and-filler structure to logic helps clear up what are often imprecisely specified reasoning methods in these structures. In p