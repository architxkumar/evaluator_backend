which could match Working Memory changes need to be examined. This greatly reduces the number of comparisons required on each cycle. 2. Many rules in a knowledge base will have the same conditions occurring in their LHS. This is just another way in which unnecessary matching can arise Repeated testing of the same conditions in those rules could be avoided by grouping rules which share the same conditions and linking them to their common terms, It would then be possible to perform a single set of tests for all the applicable rules. A description of this linking process is given below. When the rules are first loaded Into the knswleslge base, they are examined and processed by a rule compiler. The compiler checks the LHS conditions and forms an association between rule names and their LHS condition terms. In addition, the ..compiler builds a network structte which connects all rules having common conditions in their LI-IS. The network is then used during run time to locate and test rule conditions which might be satisfied with consistent bindings to new workingmemory clauses figure 10.9 illustrates ho A rules sharing common LHS teriits are grouped together and indexed with these common condition terms. One way to form the associations and indices using LISP is with prapert\ lists. For example. (putprop 'R6 father 'cond-l) (putprop 'R6 father 'cond-2) (putprop 'R12 'father 'cond-l) sets up a link between rules and their LHS conditions, whereas statements like (putprop father (cons R6 (get 'fa'ther 'cond-l) 'cond-1)) link specific LHS terms to all rules which contain the term in th same LI-IS positions When a change is made to working memory, such as the addition of the clause 208 Matching Techniques Chap. 10 eond-1 cond-t father (R6 ((father 7y ?x) (father a '50 cond-2 (grandfather Ofld (R12 (father 2y )x) - - Rt3R23 (male 'yl R13 ((father 'y 'e( (male a( mond-1 cond-1 - - father on ?x "i)l Vcond male (R23 .\\ ((father ?a ?yl. ,; :d: t (brother', ?x - (unt Ie ?z 'yl( F