he example we explored in the last section, all the simple facts were expressed as combinations of individual Predicates, such as: tryassassinate(Marcus, Caesar) This is fine if the number of facts is not very large or if the facts themselves are sufficiently unstructured that there is little alternative. But suppose we want to express simple facts, such as the following greater-than and less-than relationships: get(1,0) 1t(0,1) gt(2,1) 1t(1,2) 2t(3,2) 1t(2,3) Clearly we do not want to have to write out the representation of each of these facts individually. For one thing, there are infinitely many of them. But even if we only consider the finite number of them that can be represented, say, using a single machine word per number, it would be extremely inefficient to store explicitly a large set of statements when we could, instead, so easily compute each one as we need it. Thus it becomes useful to augment our representation by these computable predicates. Whatever proof procedure we use, when it comes upon one of these predicates, instead of searching for it explicitly in the database or attempting to deduce it by further reasoning, we can simply invoke a procedure, which we will specify in addition to our regular rules, that will evaluate it and return true or false. It is often also useful to have computable functions as well as computable predicates. Thus we might want to be able to evaluate the truth of gu(2 + 3,1) To do so requires that we first compute the value of the plus function given the arguments 2 and 3, and then send the arguments 5 and } to gt. The next example shows how these ideas of computable functions and predicates can be useful. It also makes use of the notion of equality and allows equal objects to be substituted for each other whenever it appears helpful to do so during a proof. 106 Artificial Intelligence Consider the following set of facts, again involving Marcus: 1. Marcus was a man. man(Marcus) Again we ignore the issue of tense. . Marcu