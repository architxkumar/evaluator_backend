tatements of the form died(Marcus, date) for some specific value of date. Whatever value of date we use in producing that contradiction is the answer we want. The value that proves that there is a value (and thus the inconsistency of the statement that there is no such value) is exactly the value we want. Figure 5.14(a) shows how the resolution process finds the statement for which we are looking. The answer to the question can then be derived from the chain of unifications that lead back to the starting clause. We can eliminate the necessity for this final step by adding an additional expression to the one we are going to use to try to find a contradiction, This new expression will simply be the one we are trying to prove true (i.e., it will be the negation of the expression that is actually used in the resolution). We can tag it with a special marker so that it will not interfere with the resolution process. (In the figure, it is underlined.) It will just get carried along, but each time unification is done, the variables in this dummy expression will be bound just as are the ones in the clauses that are actively being used. Instead of terminating on reaching the nil clause, the resolution procedure wil] terminate when all that is left is the dummy expression. The bindings of its variables at that point provide the answer to the question. Figure 5.14(fr) shows how this process produces an answer to our question. Unfortunately, given a particular representation of the facts in a system, there will usually be some questions that cannot be answered using this mechanism. For example, suppose that we want to answer the question What happened in 79 A.D.? \ising the statements in Section 5.3. In order to answer the question, we need to prove that something happened in 79, We need to prove dx - event(x, 79) at : died(Marcus, t) = sdied(Marcus, t) =Pompeian(x1) \/ died{x, 79) udied (Marcus, f) 79/t, Marcus/ x, Pompeian(Marcus) | .Pompeian(Marcus) So (a) Pompeian(x;) \/ die