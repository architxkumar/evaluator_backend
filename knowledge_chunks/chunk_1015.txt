ifferent sources of knowledge are necessary for morphological processing. The first is the exicon which has a listing of words and morphemes along with their roles (for example, adding an s gives the plural form of a noun). The second is morphotactics, which is a set of rules that govern which endings go with which words (for example, er can follow do but not be ). The third is a set of rules to allow for change in spelling (for example, fly s should give rise to flies and not flys ). The apparatus needed for morphological processing are concatenation and a mechanism to allow certain combinations and rule out some others based on the characters processed. These can be conveniently captured using a Finite State Automaton (FSA). An FSA makes transition between states driven by a sequence of input symbols. One or more of these states are marked as acceptors, and the automaton is said to have accepted or recognized the string if it ends up being in one of the acceptor states, after all symbols are processed. An extension of this basic idea is that of Finite State Transducers (FST), which output symbols as it makes state transitions. Thus, an FST can be viewed as a mechanism of taking in an input string and generating an output string, and this is ideally suited to the task of morphological processing. The development of morphological processers is often modularized in practice, by adopting the notion of a two-level morphology. The first module takes in a surface form of a word (say birds ) and splits it into possible morphemes ( bird s ). The second module converts these morphemes to root forms and tags identifying their morphological features ( bird N plural). Morphological processing is an essential prerequisite for NLP parsers and Part of Speech taggers, and also for applications like machine translation, question answering and grammar checking. While tasks like Information Retrieval also need a knowledge of morphology in principle, they tend to do away with elaborat