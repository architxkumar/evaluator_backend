herefore, while on the one hand it does pruning only when necessary, thus saving on reconstruction cost; on the other hand, it can create many relay layers, thus being able to tackle larger problems. When the search terminates, there may be several relay layers in the memory. In Figure 5.27 below, we illustrate this with two relay layers. Thus, at the point when search picks the goal node, it also has a Sparse Solution Path to the Start node via the relay nodes. Like the DCFS algorithm, SMGS recursively calls itself with each segment in the Sparse Solution Path to find the Dense Solution Path, the solution required. While DCFS divides the problem into two parts, SMGS may divide it in many parts, depending upon how many times the module PruneClosed is called. In Figure 5.27, the problem has been divided into three segments, one of which has not yet been pruned. Relay layers created each time PINOLE co a) Unpruned CLOSED is S contains the dense path Goal FIGURE 5.27 On termination, SMGS has a Sparse Solution Path to the goal. Of the two search algorithms seen above, DCFS prunes CLOSED as it goes along. The only nodes it keeps are one relay node for each node on OPEN. It does so by modifying the nodes on OPEN to keep only forward-going successors. SMGS does not tamper with OPEN. Instead, it keeps a boundary layer amongst the nodes in CLOSED to prevent search from turning backwards. When a call to PruneClosed is made, this boundary becomes a relay layer. It also introduces the tactic of pruning only when memory is sensed to be running out, and keeps the option of pruning more than once and creating many relay nodes. 5.10 Pruning the OPEN List In the previous section, we looked at a method to prune the CLOSED list. We also observed that it was useful for problems where the problem space only grew polynomially with depth, in which case the list OPEN is generally much smaller, often only growing linearly. However, in general, when problem space grows exponentially, it is t