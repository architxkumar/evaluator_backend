ng(F : facts, R: rules, g : goal) yoalset (9g) oroc () rheta () while gcalSet () do subGoal Head(goalset) goalset Rest (gcalset) if there exists a substitution beta s.t. Apply(beta, subGoa. then proof Cons((Aprly(beta, subGcal), Premise ), else CHOCSE r ((antecedents) (consequent)) R S.t. alfa Unify(consequent, subGoal) if no such rule exists then return FAIL der Is the order in which the programmer writes them! Even then the program may have to backtrac choices. e logic programming the user does not have to worry about the order,in whigthsfatements are m n the burden of finding the correct clauses to resolve to the (non-deterministic) inference engine. Ir - engines are not (yet) smart enough to make the correct choices, and in languages like Prolog or order the statements. This is needed not only for efficiency in terms of number of logical in but often also for termination. A good programmer writes programs that do not get into infinite ic programmer orders her clauses so that the inference engine does not wander down a wild goose loop). gy inverts the notation of writing a rule, with the consequent on the left and the antecedents on th symbol :- to separate the consequent from the antecedents, and a comma to separate the ante problem in FOL written in Prolog like rules would be as follows, es(alice, math). es(alice, stories). es(X, algebra) :- likes(X, math). esTO(X, college) :- likes(X, algebra), likes(X, physics). es(alice, physics) :- likes(alice, stories). J uses capitalized words for variables, and words beginning with lower case letters for constants. consequent if antecedents . For example someone likes to go to college if she likes algebra ; (rule in line 4 above). The advantage of writing the consequent on the left is that given a goal the ir fo go down the program looking at only the first predicate in each line, known as the head of the cle found either it is a fact, or a consequent of a rule. If it is a fact success has been achieved for the gc jiuent