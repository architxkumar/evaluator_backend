ackets 3 while not Empty(open) 4 do n Head(open) initially n (GivenGoal, ()) 5 goal Goal(n) extracts goal from search node n 6 plan Plan(n) extracts plan from search node n 7 open Tail(open) retain other search nodes 4 8 if not Satisfies(givenState, goal) then search further 10 Re set of relevant actions for goal may be empty 11 for each action ae R 12 do p Cons(a, plan) 13 G Regress(a, goal) 14 if Consistent(g) do not add if not consistent is then 16 go List(p, g) 17 open Cons(gp, open) Depth First 8 else if ValidPlan(plan, givenState, givenGoal) 9 then return plan 0 return No plan found Figure 7.8 Backward State Space Search regresses over goals. It validates a plan before returning it. It also assumes a function Consistent to prune away inconsistent subgoals. GSP breaks up a set of goal predicates into individual subgoals and attempts to solve them individually one after another. This approach is also sometimes called linear planning. This refers to the fact that the subgoals are attempted and solved in a linear order . When we implement BSSP with depth first strategy, we are in fact doing something similar. As we will see, this does not always work. In some domains, a subgoal solved earlier may get disrupted by later actions. We saw this depicted in Figure 3.15 for the Rubik s cube. Most human solvers of the cube attempt it as a sequence of subgoals, but end up disrupting them on the way to the final solution. In domains where the goal state is reachable from all states, one can tackle this problem of subgoal interaction by putting in a check to verify that all subgoals have indeed been solved before termination. This check is necessary to take care of subgoal interaction, which is different from the check in BSSP, where it was to determine the validity of the plan constructed. Goal Stack Planning works by pushing the goal description onto a stack. It pushes both the conjunct, as well as each of the individual goal predicates separately. The algorithm pops the e