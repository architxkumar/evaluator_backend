 in our previous example, instead of arbitrarily choosing one order in which to satisfy a set of preconditions, we could leave the order unspecified until the very end. Then we would look at the effects of each of the subsolutions to determine the dependencies that exist among them. At that point, an ordering can be chosen. 13.4 GOAL STACK PLANNING One of the earliest techniques to be developed for solving compound goals that may interact was the use of a goal stack. This was the approach used by STRIPS. In this method, the problem solver makes use of a single stack that B c;|6 contains both goals and operators that have been proposed AL LC} [0 Al 0 to satisfy those goals. The problem solver also relies on a start: ON(B, A) goal: ON(G, A) A database that describes the current situation and a set of ONTABLE(A) ON(B, D) A : ONTABLE(C) A ONTABLE(A) A operators described as PRECONDITION, ADD, and ONTABLE(D) ONTABLE(D) DELETE lists. To see how this method works, let us carry ARMEMPTY : it through for the simple example shown in Fig. 13.4. Fig. 13.4 A Very Simple Blocks World Problem When we begin solving this problem, the goal stack is simply ON(C, A) A ON(B, D) A ONTABLE(A) A, ONTABLE(D) 256 Artificial Intelligence But we want to separate this problem into four subproblems, one for each component of the original goal. Two of the subproblems, ONTABLE(A) and ONTABLE(D), are already true in the initial state. So we will work on only the remaining two. Depending on the order in which we want to tackle the subproblems, there are two goal stacks that could be created as our first step, where each line represents one goal on the stack and OTAD is an abbreviation for ONTABLE(A) A ONTABLE(D): ON(C, A) ONG, D) ON(B, D) ON(C, A) ON(C, A) AON(B,D) AOTAD = ON(C, A) A ON(B,D) A OTAD (1) [2] At each succeeding step of the problem-solving process, the top goal on the stack will be pursued. When a sequence of operators that satisfies it is found, that sequence is applied to the state de