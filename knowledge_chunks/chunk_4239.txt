is need not be the case. Suppose that when the first NP is found, its number is determined and recorded in a register called NUMBER. Then the arcs labeled V could have an additional test placed on them that checked that the number of the particular verb that was found is equal two the value stored in NUMBER. More sophisticated tests, involving semantic markers or other semantic features, can also be performed. 298 Artificial intelligence RL RESTS 15.2.3. Unification Grammars AT'N grammars have substantial procedural components. The grammar describes the order in which constituents oust be built. Variables are explicitly given values, and they must already have been assigned a value before chey can be referenced. This procedurality limits the effectiveness of ATN grammars in some cases, for example: in speech processing where some later parts of the sentence may have been recognized clearly while earlier parts are still unknown (for example, suppose we had heard, The long * * * file printed. ), or in systems that want to use the same grammar to support both understanding and generation (e.g., Appelt [1987], Shieber [1988], and Barnett et al. [1990]). Although there is no clear distinction between declarative and procedural representations (as we saw in Section 6.1), there is a spectrum and it often tums out that more declarative representations are more flexible than more procedural ones are. So in this section we describe a declarative approach to representing grammars. When a parser applies grammar rules to a sentence, it performs two major kinds of operations: Matching (of sentence constituents to grammar rules) e Building structure (corresponding to the result of combining constituents) Now think back to the unification operation that we described in Section 5.4.4 as part of our theoremproving discussion. Matching and structure building are operations that unification performs naturally. So an obvious candidate for representing grammars is some structure on which