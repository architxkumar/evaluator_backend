 (:action dunk :parameters (2p - package ?t -tcilet) :precondition (in bomb ?p) :effect (diffused bemb) ))) The action Dunk will have two instances Dunk (p1, t) and Dunk (p2, t). Each instance will be applicable in the corresponding possible world. CGP constructs a separate planning graph for each possible world, and looks for a solution when the goal set appears nonmutex in all the planning graphs. Figure 10.12 shows the two planning graphs constructed for the possible worlds w, and wp. It then starts a plan finding exercise moving backwards, level by level, in parallel in each planning graph. If it can find a set of actions in each possible world then it returns the union of the plans found. A Diffused(bomb) . In(bomb, p2) p In(bomb, p2) In(bomb, pl) In(bomb, pl) : Diffused(bomb) Diffused(bomb) Ww) Diffused(bomb) aIn(bomb, p2) 7 Sa In(bomb, p2) ri ' In(bomb, pl) 6-------b------------ --- In(bomb, p1) ; Diffised(bomb) Diffused(bomb) FIGURE 10.12 Conformant Graphplan constructs a planning graph for each possible world. It finds that the goal Diffused(bomb) appears in both the planning graphs at level 1, and further that, the two actions achieve the goal. Thus, it returns a plan of dunking both packages. The above example does not have interference between the actions across the different planning graphs. To illustrate that case, we augment our dunking action to have an additional effect that it clogs the toilet. The action, Dunk2, is given below. (:action dunk2 tparameters (2p - package ?t -toilet) precondition (not (clogged ?t)) :effect and (clogged ?t) (when (in bomb ?p) (diffused bomb) ))) The modified dunk action requires that the toilet be unclogged to be applicable, and has an effect that it clogs the toilet. Now the two actions of dunking the two packages are individually applicable in the two planning graphs, which are constructed for the two possible worlds. The real world, on the other hand, is one of the two worlds, w, and wo, but we do not know which. Wh