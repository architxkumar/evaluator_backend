e assume a function ength is available to determing 4ae-tengtbraf a list. Two lists d if they have the same length. The following algorithm is along the lines of the version pres k and McDermott, 1985). y(list,, list-) return SubUnify(list,, list-, ()) rify(list,, list,, theta) if fail e theta then return FAIL if Var(list.) then return VarUnify(list,, list,, theta) if Var(list;) then return VarUnify(list,, list,, theta) if Constant (list,) then if list, list, then return theta else return FAIL if constant (list,) then return FAIL if list, list, ( ) then return theta if Length(list,) Length(list,) then return FAIL else return Append( SubUnify(Head(list,), Head(list,), th SubUnify(Rest(list,), Rest(list.), th rUnity(variable, list, theta) if ExistsIn(variable, list) then return FAIL if (variable value) theta the variable, value p then return SubUnify(list, value), theta) else return Cons((variable, list), theta) .13 The unification algorithm compares the two inputs (lists) element by element making recursive calls where necessary. The ft ents the substitution theta if it is consistent to do so. The function ExistsIn looks for occurrence of the variable in the list tha it. It can be implemented by first flattening the list and then checking for membership. same variable name is repeated in two formulas then it could lead to a problem in the algorithm. Con Ulas, (SmallerOrEqualThan 0 ?z) (SmallerOrEqualThan ?z, (successor ?z)) rst formula says that 0 is smaller than or equal to anything. The second says that any number is smi to its successor. run our unification algoxitam on the two formulas the following will happen. e both inputs are lists of length three, three recursive calls to sub-unify will be made ve firet call the two conctante match and it returns the amonty cihetitition gorithm proceeds as before for tne first wo recursive Call. ine tmMira Call NOW IS aliferent -Varor ?z), ((?z 0)). This time the algorithm returns the unifier theta ((?x (successor ?z) (?z 0)