 ValidPlan(Taii(plan), state, goal) Figure 7.7 Algorithm to verify a plan. Function Satisfies checks whether the state satisfies the goal (that is G S). Function Progress progresses the state over an action. Given the function to check the validity of a plan, we can write a backward state space planning algorithm that will apply this check before termination. In the algorithm described below, we also assume a function Consistent(G) that takes a goal G and checks whether G can be part of a state. Observe that this check does not have to be perfect. We use the check to filter out some inconsistent goals. The more inconsistent goals we can filter out, the faster our search algorithm will perform. But for the sake of correctness, the check should not filter out any consistent goals. The trivial correct case is when Consistent(Goal) always returns true. In this case, it does not filter out any goals, which means the algorithm may waste time over an infeasible sequence of actions. Some work on checking for consistency has been described in (Fox and Long, 1998; Kumashi and Khemani, 2002). In the algorithm below, the search node is a pair made up of the goal to be satisfied, and the current plan. We use two functions, Goal(node) and Plan(node), to extract the goal component and the plan component from a given search node. They return respectively the first member and the second member of the list representing the node. The plan grows in a backward fashion, with the last action being found first. The planning algorithm takes as input the given state, the goal description, and a set of actions that are all possible ground instances of the set of operators for the given domain. One can adapt the algorithm to work with the set of operators itself. Working with instances is simpler for a finite domain. Also, not shown in the algorithm, is the role of a CLOSED list to check for looping. This is left as an exercise. 7.4 Goal Stack Planning The main problem with BSSP is that goal r