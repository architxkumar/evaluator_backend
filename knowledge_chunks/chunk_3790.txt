his contrasts with breadth-first search, where all of the (ree that has so far been generated must be stored. By chance (or if care is taken in ordering the alternative successor states), depth-first search may find ( a solution without examining much of the search space at all. This contrasts with breadth-first search in ! which all parts of the tree must be examined to level before any nodes on level n + 1 can be examined. This is particularly significant if many acceptable solutions exist. Depth-first search can stop when one of them is found. Problems, Problem Spaces, and Search 33 SS RS RESP P RIESE BEND MOR ORS IE AI Advantages of Breadth-First Search Breadth-first search will not get trapped exploring a blind alley. This contrasts with depth-first searching, which may follow a single, unfruitful path for a very long time, perhaps forever, before the path actually terminates in a state that has no successors. This is a particular problem in depth-first search if there are loops (i.e., a state has a successor that is also one of its ancestors) unless special care is expended to test for such a situation. The example in Fig. 2.7, if it continues always chousing the first (in numerical sequence) rule that applies, will have exactly this problem. If there is a solution, then breadth-first search is guaranteed to find it. Furthermore, if there are multiple solutions, then a minimal solution (i.e., one that requires the minimum number of steps) will be found. This is guaranteed by the fact that longer paths are never explored until all shorter ones have already been examined. This contrasts with depth-first search, which may find a long path to a solution in one part of the tree, when a shorter path exists in some other, unexplored part of the tree. Clearly what we would like is a way to combine the advantages ot both of these methods. In Section 3.3 we will talk about one way of doing this when we have some additional! information. Later, in Section 12.5, we wil! d