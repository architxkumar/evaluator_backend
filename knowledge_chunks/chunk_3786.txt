ermanent, while other parts of it may pertain only to the solution of the current problem. The information in these databases may be structured in any appropriate way. A control strategy that specifies the order in which the rules will be compared to the database and a way of resolving the conflicts that arise when several tules match at once. e A tule applier. So far, our definition of a production system has been very general. It encompasses a great many systems, including our descriptions of both a chess player and a water jug problem solver. It also encompasses a family of general production system interpreters, including: * Basic production system languages, such as OPS5 [Brownston et a/., 1985] and ACT* [Anderson, 1983]. More complex, often hybrid systems called expert system shells, which provide complete (relatively speaking) environments for the construction of knowledgebased expert systems. General problem-solving architectures like SOAR [Laird et al., 1987], a system based on a specific set of cognitively motivated hypotheses about the nature of problem-solving. 3 This convention for the use of left and right sides is natural for forward rules. As we will see later, many backward rule systems reverse the sides. Problems, Problem Spaces, and Search 31 All of these systems provide the overall architecture of a production system and allow the programmer to write rules that-define particular problems to be solved. We discuss production system issues further in Chapter 6. We have now seen that in order to solve a problem, we must first reduce it to one for which a precise statement can be given. This can be done by defining the problem s state space (including the start and goal states) and a set of operators for moving in that space. The problem can then be solved by searching for a path through the space from an initial state to a goal state. The process of solving the problem can usefully be modeled as a production system. In the rest of this section, we lo