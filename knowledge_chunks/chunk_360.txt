he key thing is that this value is available from the given board position directly, without having to look ahead. This also illustrates how knowledge can be used to trade off search. One obvious way to play the game now would be to evaluate all the positions that result from the moves one can make, and choose the best one. This would be called one-ply look-ahead and is depicted in Figure 8.13. FIGURE 8.13 A one-ply look-ahead picks the best looking successor. This would be fine if the evaluation function was very good. While it has emerged that grandmasters do store tens of thousands of Chess schemata and evaluate them directly (Sowa, 1983), it is difficult to devise an evaluation function that is good enough to play with one-ply lookahead. In practice, Chess programmers rely on a combination of evaluation and look-ahead. While we cannot write programs to look ahead till the end of the game, we can still do so to look ahead a smaller distance. Figure 8.14 below gives you a feel of the exploding search space with a game tree involving four choices per board position. FOOCOCUGO , Ss FIGURE 8.14 A game tree with a branching factor 4. A three-ply search needs to inspect 64 nodes. The next level will have 256, the one after that 1024, and the next one 4096; trees that are too large to draw on these pages. Most games have an even higher branching factor. oO Look-ahead takes care of the combinatorial aspect of the game, like piece exchanges in Chess, which cannot be captured easily in a heuristic (evaluation) function, while the evaluation function provides a mechanism for evaluating the material and positional properties of nodes at the end of an incomplete look-ahead. The amount of look-ahead would basically depend upon the resources available to the program. The faster the machine, the more is the look-ahead possible in the same time. The more the program looks ahead, the better it is likely to play. Experts hypothesize that even with a simple evaluation function, a pr