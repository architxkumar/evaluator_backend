st, and then apply the rules that are activated. An outline is depicted in Figure 13.8 where we have not considered multiple word senses. If multiple word senses are allowed more sophisticated processing, like backtracking or least commitment strategy, would be needed. We assume that our algorithm retrieves the correct set of rules nondeterministically. We also assume that we have a function Apply(request, cList) that takes an applicable rule, tested by RequestTest, and makes the appropriate modification in the cList, and removes the request from the rList. In that sense rList is treated as a global list. 13.7.2 Case Markers The reader would have noticed that the parsing of the above sentence made use of the order information typical of an active sentence in the English language. This is necessary because English is a language in which the roles of different participants of a sentence are indicated implicitly in the sentence structure. A sentence like The apple was eaten by Amit is an example of a passive sentence marked by the phrase was eaten by and would have a different set of requests associated with it. Moreover, to justify our claim that the language understanding is not critically dependent upon syntax, the parsing algorithm would have to find a best fit semantic role in utterances like eat apple Amit overruling the position requirements. At other times when a semantic match does not occur, for example in the tramp ate the shoe , one has to rely on the syntactic order to fill the shoe into vennnce slot of INGEST. Syntax also plays a key role in making sense of sent DHE Man bites dog or man swallows snake where the semantic roles are not clear. This could possibly be handled in the above aroorrae bypghecking for any pending requests before exiting. A secondary procedure could then relax the semantic matching criteria for activating the pending requests. SimpleSemanticParser (sentence) 1 rList () 2 cList () 3 while not Null (sentence) 4 do nextWord Head(senten