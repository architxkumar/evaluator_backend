ee-Finger Brown is a baseball player, our rule allows us to conclude that his height is 6-1. If, on the other hand, we had asserted a conflicting value for Three Finger had an axiom like Wx, y, z 1: height(x, y) A height(x, z) > y =z, which prohibits someone from having more than one height, then we would not be able to apply the default rule. Thus an explicitly stated value will block the inheritance of a default value, which is exactly what we want. (We'll ignore here the order in which the assertions and the rules occur. As a logical framework, default logic does not care. We'll just assume that somehow it settles out to a consistent state in which no defaults that conflict with explicit assertions have been asserted. In Section 7.5.1 we look at issues that arise in creating an implementation that assures that.) But now, let s encode the default rule for the height of adult males in general. If we pattern it after the one for baseball players, we get Adult-Male(x) : height(x, 5-10) height(x, 5-10) Unfortunately, this rule does not work as we would like, In particular, if we again assert Pitcher(Three Finger-Brown), then the resulting theory contains two extensions: one in which our first rule fires and Brown s height is 6-1 and one in which this new rule applies and Brown s height is 5-10. Neither of these extensions is preferred. In order to state that we prefer to get a value from the more specific category, baseball player, we could rewrite the default rule for adult males in general as: Adult-Male(x) : ~Baseball-Player(x) /\ height(x, 5-10) height(x, 5-10) This effectively blocks the application of the default knowledge about adult males in the case that more specific information from the class of baseball players is available. Symbolic Reasoning Under Uncertainty 155 A AEN IE SII ANN SEERA SE ROSE Unfortunately, this approach can become unwieldy as the set of exceptions to the general rule increases. For example, we could end up with a rule like: Adult-Male(