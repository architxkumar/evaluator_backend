en the current and the goal states, and, as a result, sometimes reasoning backward and sometimes forward. i | i i Representing Knowledge Using Rules 137 senna snsann At AS ASS By separating rules into these two classes, we essentially add to each rule an additional piece of inforination, namely, how it should be used in problem-solving. In the next three sections, we describe in niore detail the two kinds of rule systems and how they can be combined. 6.3.1 Backward-Chaining Rule Systems Backward-chaining rule systems, of which PROLOG is an example, are good for goal-directed problemsolving. For example, a query system would probably use backward chaining to reason about and answer user questions. In PROLOG, rules are restricted to Horn clauses. This allows for rapid indexing because all of the rules for deducing a given fact share the same rule head. Rules are matched with the unification procedure. Unification tries to find a set of bindings for variables to equate a (sub)goal with the head of some rule. Rules in a PROLOG program are matched in the order in which they appear. Other backward-chaining systems allow for more complex rules. In MYCIN, for example, rules can be augmented with probabilistic certainty factors to reflect the fact that some rules are more reliable than others We discuss this in more detail in Chapter 8. 6.3.2 Forward-Chaining Rule Systems Instead of being directed by goals, we sometimes want to be directed by incoming data. For example, suppose you sense searing heat near your hand. You are likely to jerk your hand away. While this could be construed as goal-directed behavior, it is modeled more naturally by the recognize-act cycle characteristic of forwardchaining rule systems. In forward-chaining systems, left sides of rules are matched against the state descriptior. Rules that match dump their right-hand side assertions into the state, and the process repeats. Matching is typically more complex for forward-chaining systems than backward o