ersarial Search
Games, unlike most of the toy problems studied in Chapter 3, are interesting because
they are too hard to solve. For example, chess has an average branching factor of about 35,
and games often go to 50 moves by each player, so the search tree has about 35100 or 10154
nodes(although thesearchgraphhas only about 1040 distinct nodes). Games,likethereal
world,thereforerequiretheabilitytomake somedecision evenwhencalculating theoptimal
decisionisinfeasible. Gamesalsopenalizeinefficiencyseverely. Whereasanimplementation of A searchthatishalfasefficientwillsimplytaketwiceaslongtoruntocompletion,achess
program that is half as efficient in using its available time probably will be beaten into the
ground, otherthingsbeingequal. Game-playingresearchhasthereforespawnedanumberof
interesting ideasonhowtomakethebestpossible useoftime.
We begin with a definition of the optimal move and an algorithm for finding it. We
then look at techniques for choosing a good move when time is limited. Pruningallows us
PRUNING
toignore portions ofthesearch treethatmakenodifference tothefinalchoice, andheuristic
evaluationfunctionsallowustoapproximate thetrueutilityofastatewithoutdoingacom-
plete search. Section 5.5 discusses games such as backgammon that include an element of
IMPERFECT chance; wealso discuss bridge, which includes elements of imperfect information because
INFORMATION
notallcardsarevisible toeachplayer. Finally,welookathowstate-of-the-art game-playing
programsfareagainsthumanopposition andatdirections forfuturedevelopments.
Wefirstconsidergameswithtwoplayers,whomwecall MA Xand MI Nforreasonsthat
willsoonbecomeobvious. MAX movesfirst,andthentheytaketurnsmovinguntilthegame
is over. At the end of the game, points are awarded to the winning player and penalties are
given to the loser. A game can be formally defined as a kind of search problem with the
followingelements: S : Theinitialstate, whichspecifieshowthegameissetupatthestart.
0 PLAYER(s): Defineswhichplayerhasthe