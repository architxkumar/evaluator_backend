TE TT At what level should knowledge be represented? Is there a good set of primitives into which all knowledge can be broken down? Is it helpful to use such primitives? e How should sets of objects be represented? Given a large amount of knowledge stored in a database, how can relevant parts be accessed when they are needed? We will talk about each of these questions briefly in the next five sections. 4.3.1. Important Attributes There are two attributes that are of very general significance, and we have already seen their use: instance and isa. These attributes are important because they support property inheritance. They are called a variety of things in AT systems, but the names do not matter. What does matter is that they represent class membership and class inclusion and that class inclusion is transitive, In slot-and-filler systems, such as those described in Chapters 9 and 10, these attributes are usually represented explicitly in a way much like that shown in Fig. 4.5 and 4.6. In logic-based systems, these relationships may be represented this way or they may be represented implicitly by a set of predicates describing particular classes. See Section 5.2 for some examples of this. 4.3.2 Relationships among Attributes The attributes that we use to describe objects are themselves entities that we represent. What properties do they have independent of the specific knowledge they encode? There are four such properties that deserve mention here: Inverses e Existence in an isa hierarchy Techniques for reasoning about values Single-valued attributes Inverses Entities in the world are related to each other in many different ways. But as soon as we decide to describe those relationships as attributes, we commit to a perspective in which we focus on one object and look for binary relationships between it and others. Attributes are those relationships. So, for example, in Fig. 4.5, we used the attributes instance, isa and team. Each of these was shown in the figure with