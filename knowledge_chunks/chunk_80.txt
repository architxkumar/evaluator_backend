thm reconstructPath below reconstructs the path by tracing these back pointers until it reaches the start node which has NIL as back pointer. ReconstructPath (nodePair, closed) l path List (Head(nodePair) ) parent Second(nedePazir) while parent is not NIL dopath Cons(parent, path) nodePair FindLink (parent, closed) parent Secend(nedePair) return path ANM SB wh FindLink(child, closed) l if child Head(Head(closed)) 2 then return Head(closed) 3 else return Findiink(child, Tail(clesed) FIGURE 2.17 Reconstructing the path from the list of back pointers of each node involves retrieving the parent of the current node all the way back to start whose parent, by definition, is NIL. nodePair is a pair that contains the goal g and its parent node. The functions List, Head, Second, Tail and Cons for the list data structure. In the algorithms in Figures 2.17, 2.18 and 2.20, we also move from the set representation to a list representation. It calls a function removeSeen to prune the list of successors, and makeNodes to prepare the successors in the form for adding them to OPEN. We also make it deterministic by picking the new candidate from the head of the list OPEN, since this is an easy operation for most data structures. 2.3 Depth First Search (DFS) The algorithm DFS given below (Figure 2.18) treats OPEN like a stack. It adds the new candidates at the head of the list. The reason it is called depth first is that from the search tree, it selects a node from the OPEN list that is deepest or farthest from the start node. The candidates are inspected in the last-in-first-out order. This way its focus is on the newer arrivals first, and consequently its characteristic behaviour is that it dives headlong into the search space. Figure 2.19 illustrates the search tree as seen by DFS, represented by the two lists OPEN and CLOSED. DepthFirstSearch() open ((start NIL)) 2 elosed () 3 while not Null(open) 4 do nodePair Head(open) 5 node Head(nodePair) if GoalTest(node) TRUE 7 then return R