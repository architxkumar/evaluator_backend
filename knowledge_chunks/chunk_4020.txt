), the TMS itself does not know anything about the structure of the assertions themselves. (As a result, in our examples, we use an English-like shorthand for representing the contents of nodes.) The TMS s only role is to serve as a bookkeeper for a separate problemsolving system, which in tum provides it with both assertions and dependencies among assertions. To see how a TMS works, let s retum to the ABC Murder story. Initially, we might believe that Abbott is the primary suspect because he was a beneficiary of the deceased and he had no alibi. There are three assertions here, a specific combination of which we now believe, although we may change our beliefs later. We can represent these assertions in shorthand as follows: Suspect Abbott (Abbot is the primary murder suspect.) Beneficiary Abbott (Abbott is a beneficiary of the victim.) Alibi Abbott (Abbott was at an Albany hotel at the time.) Our reason for possible belief that Abbott is the murderer is nonmonotonic. In the notation of Default Logic, we can state the rule that produced it as Beneficiary(x) : Alibi(x) Suspect(x) or we can write it as a backward rule as we did in Section 7.4. If we currently believe that he is a beneficiary and we have no reason to believe he has a valid alibi, then we will believe that he is our suspect. But if later we come to believe that he does have a valid alibi, we will no longer believe Abbott is a suspect. But how should belief be represented and how should this change in belief be enforced? There are various ad hoc ways we might do this in a rule-based system, But they would all require a developer to construct rules carefully for each possible change in belief. For instance, we would have to have a mule that said that if Abbott ever gets an alibi, then we should erase from the database the belief that Abbott is a suspect. But suppose that we later fire a rule that erases belief in Abbott s alibi. Then we need another rule that would reconclude that Abbott is a suspect. The