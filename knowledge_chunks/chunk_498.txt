s levelled off. 1. The procedure to extend the planning graph by one level is described in Figure 10.5. The algorithm ExtendGraph takes as input all sets of data for each layer constructed so far, the index of the layer to be constructed, and the set propositional actions A. The set A may be generated from the start state S and the set of operators O in a pre-processing phase. The algorithm begins by copying the sets for the (j 1)" layer, except the mutexes. This is because the set of propositions and actions are always carried forward. The algorithm then checks if any new actions are applicable (steps 8, 9). If there are, it adds elements to the different sets (steps 10-17). Then in steps 18 to 23, it computes all the mutex relations that hold at the layer in the graph, and returns the planning graph augmented by one layer in the last step. The applicability of actions in the planning graph needs to check that its preconditions are present and that none of the preconditions are mutex with each other. This is done by the procedure ApplicablePG(a,, P; 1, MuP; 1) that takes the action being considered, the previous proposition layer, and the previous proposition mutex layer as input. Note that the test for mutex has both Pm, Py MuP; , or Px, Pm MuP;, for readability, though strictly speaking, one is enough. The functions MutexA and MutexP are left as an exercise for the reader. The first task that algorithm GraphPlan takes up is the construction of the planning graph. The algorithm PlanningGraph described in Figure 10.6 starts off by initializing the layer zero of the planning graph. This contains only one non-empty set and that is Po, which is initialized to the given start state S. The others are initialized to empty lists and the only purpose they serve is as input to the call to ExtendGraph. We assume that the procedure is called only if the initial state is not the goal state. The process of extending the graph (lines 11 and 12) continues till any one of the foll