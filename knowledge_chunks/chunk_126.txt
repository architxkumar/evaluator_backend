t this can also be done with a finite memory. Moves that have been less frequently used could be given preference. Imposing a penalty proportional to the frequency on the evaluation value could do this. Thus, nodes generated by frequent moves would get evaluated lower and lower, and the other moves would get a chance to be chosen. The algorithm TabuSearch described below assumes that the candidate solutions have N components, and changing them gives N neighbours, which can be generated by some move generator function called Change(node, i) that changes the component. The algorithm works with two arrays of N elements. The first called M, keeps track of the tabu list, and is a kind of short term memory. The second called F, keeps track of the frequency of changing each component, and serves as a long term memory. The algorithm also assumes the existence of an Eval(node) function that evaluates a given node, and the resulting values for the neighbours are stored in an array Value. The algorithm written in Figure 3.20 highlights the special aspects of TabuSearch, and hence has explicit array computations. The search features are implicit in the calls to the functions Change and Eval, and the use of the procedure moveTo(Index) that finally makes the move and does the bookkeeping is shown in Figure 3.21. TabuSearch (tr) i for ie lton do M i 0; Fli 0 initialize Choose the current node o zand oz as given best eo while some t: do for i genezate the neighbourhood 3 4 5 7 8 change the i th component then if not on tabu list tabu i NO AllowedValue value i some initial value Allowedindex i BestAllowedValue is best value neighbour that is not on tabu list BestValue is best value amongst all neighbo Of bestValue value i bestindex - 1 for i lton do explore the n if value i is be Inbourhood if value then 28 iff bestAllowedValue oo 30 31 32 33 do if cabu i 34 then nalty(Fli ) 35 3 37 38 for i lton 39 do if value i is better than bestAllowedValue 40 AND tabuli No 42 then bestAllowedva