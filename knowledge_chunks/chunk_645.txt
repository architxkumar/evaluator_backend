e could be many rules of inference in a logic machine, as we shall see Qr. et of premises S and the set of rules R together determine the set of statements that can be added t e set P of provable statements. The set P may be computed as follows. AllRules(S : premises, R : rules) 1 Pes 2 while a new rule re R is applicable 3 do Let C be the consequent of r 4 Pe PU Cc 5 return P .2 A simple procedure to construct the set of all provable statements. It applies a rule and adds it consequent to the set, unt . a . ne domains the set P could be infinite. This means that the above procedure may never end. ctice however one is not always interested ir in computing the entire set P, but rather in answering the ge iw gy ine lg ge le lg ll, dss 2 CULE Ceili azet C be the consequent of r Pe Py C until ge P 9 return TRUE ort ne .3 A simple procedure to test whether a given sentence can be generated by applying rules of inference. observant reader would have noticed the similarity between this procedure and the Simplee in Chapter 2. Like in the search algorithms, the crux of the matter is in making the right choices of plied. Mathematicians, the community most concerned with proofs, are constantly looking for shi gant proofs even of known theorems, when they are not trying to prove newer ones . Another simil le-Search-1 procedure is that the algorithm SimpleProof does not return the solution. As shown ow, the solution is a tree rooted at the statement we want to prove (the Goal) whose leaves its in the set of premises S. Goal .4 Finding a proof involves a sequence of inferences. In each inference a new sentence is added to the set. The procedure termi sentence (Goal) is produced. The proof of the Goal is the tree as shown in the figure. searching for a proof a mathematician might have produced a lot of other statements, which are ni proof (tree) and have been discarded. If one were to automate the procedure then obviously on 1e question as to which rule to apply to what data at ea