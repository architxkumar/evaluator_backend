he PROLOG environment this can be achieved by adding or deleting rules. Recollect the count/] program we used to comprehend recursion. Let s see how we can add the whole program dynamically. The actual program by itself will contain a line of code indicating that the clause for count/1 is dynamic i.e. Issue the following goals \?:-dynamic count/}. }?-assert((count(N):-(N = = 0 -> true; (NI is N-1, write(N1),nl,count(N1})))). Note that the clauses for count/] are within and have been written in a slightly different style. However, you wil! find that the code is semantically the same as the one discussed earlier for count. Once the rule for count has been asserted you may proceed to issue goals that use count such as count(4). The above down counter could be easily retracted and an upcounter asserted in lieu of the same. This would obviously affect the behavior of the main program that uses count during run time. Let s take one last Jook at the implications of such dynamic databases before we jump to the next section. i-dynamic exec_something/l. i-dynamic code_base/I. do:- assert(code_base(assert((exec_something(X }:- write(X),nl)))). This does not just assert code (clauses) but also can form a dynamic database of clauses. Try the following sequence of goals after compiling the above piece of code. 2. do. yes. ? code_base(Code),Code. Code = assert((exec_something(_32868) :- write(_32868))) ?-exec_something( Hello there! ), Hello there! yes t | ; I | | [ | PROLOG - The Natural Language of Artificial Intelligence 515 The numbers that follow the underscore are the unbound variables. With some minor modifications. one could use assert(code_base(assert( (exec_something(another prolog program) } } } ). and accordingly maintain a database of programs in run time. 25.14 INPUT/OUTPUT AND STREAMS PROLOG can read and write terms from one or several files. These thus form the streams of data that are either input (input stream) or output (output stream). The use of some typical b