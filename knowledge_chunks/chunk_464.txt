acktrack free manner, selecting an allowed value for each variable. But such reasoning has a computational cost that may become prohibitive. At the other end is the conceptually simple search algorithm that tries all combinations of values. This too may be computationally too expensive. Somewhere in between lie hybrid approaches that combine search and reasoning, and one has to often find a trade off between the amount of search and propagation an algorithm does. The simplest search algorithm is one that tries all combinations for all values of all variables looking for a solution. Such an algorithm could be implemented as Depth First Search (see Chapter 2). If we implement the algorithm in Figure 2.16 directly, it will test for consistency (the goa Test procedure) only when it has selected values for al! variables. This is a waste of effort since we have the constraints between subsets of variables explicitly available. The algorithm Backtracking described below tests for applicable constraints while selecting values for each variable. If it cannot find a consistent value for a variable then it backtracks at that point itself. In the discussion below, we assume that the variables are named X;, X2, ..., X,, and their domains as Dj, Do, ..., Dp. We assume a procedure SelectValue that selects and returns a value from the domain of the variable that is consistent with the values for the earlier variables chosen. The solution is assembled in the reverse order in an assignment list A. The list A is initialized to a list containing an empty list to prevent a call to the function Tail with an empty list. The algorithm Backtracking makes copies of the domains of all variables and the algorithm SelectValue extracts values out from the copied domain. Note that the copied domain is shrunk inside the SelectValue function, implying that the domain is treated as a global variable, or the call is call-by-name. This is necessary if the algorithm has to backtrack and try another val