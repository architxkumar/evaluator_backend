couple of moves later. It cannot simply play as though it had never made the stupid move. Nor can it simply back up and start the game over from that point. All it can do is to try to make the best of the current situation and go on from there. These three problems theorem proving, the 8-puzzle, and chess illustrate the differences between three important classes of problems: Fig. 2.12 An Example of the 8-Puzzle e Ignorable (e.g., theorem proving). in which solution steps can be ignored * Recoverable (e.g., 8-puzzile), in which solution steps can be undone * Istecoverable (e.g., chess), in which solution steps cannot be undone These three definitions make reference to the steps of the solution to a problem and thus may appear to characterize particular production systems for solving a problem rather.than the problem itself. Perhaps a different formulation of the same problem would lead to the problem being characterized differently. Strictly speaking, this is true. But for a great many problems, there is only one (or a small number of essentially equivalent) formulations that naturally describe the problem. This was true for each of the problems used as examples above. When this is the case, it makes sense to view the recoverability of a problem as equivalent to the recoverability of a natural formulation of it. The recoverahility of a problein plays an important role in determining the complexity of the control structure necessary for the problem s solution. [gnorable problems can be solved using a simple control structure that never backtracks. Such a control structure is easy to implement. Recoverable problems can be solved by a slightly more complicated control strategy that does sometimes make mistakes. Backtracking will be necessary to recover from such mistakes, so the control structure must be implemented using a push-down stack, in which decisions are recorded in case they need to be undone later. Irrecoverable problems, on the other hand, will need to be s