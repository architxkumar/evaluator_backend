ithm Backtracking described earlier in this chapter. A cursory look at Figure 9.34 will reveal that the three subtrees located below the choice of the first variable G w are identical and without a solution. In hindsight, it is clear that given G w (or Evening Visit Mall in Chapter 6), it is futile to explore different combinations of the remaining choices. The question is, can an algorithm have the foresight to skip some of this exploration destined to fail? When the search algorithm reaches a dead end, it needs to undo some of the decisions made and try something different. In the context of CSP, let us say that the algorithm has constructed a compound label a, (X4 V4, Xp Vo, ..., Xx Vg) and is unable to find a consistent value for the (k 1) ' variable. We say that x;,.1 is inconsistent with a,, and x, 1 is a dead-end variable associated with the dead-end assignment a,. An intelligent backtracking algorithm will try and determine the reason for this inconsistency and go back and undo the decision at the culprit variable. We often use the term dependency-directed backtracking for such algorithms. Let us say that the culprit variable is x; where 1 i s k. We say that jumping back to try a different value for x; is safe, if trying a different value for any x; where i j k cannot lead to a consistent value for x, 1. This means that the compound labels a; and aj where i j k are all inconsistent with x,.1;. We say that a jump to x; is maximal, if jumping back to an earlier variable is not safe. An algorithm that performs safe and maximal jumps from dead ends is the BackJumping algorithm. 9.8.1 Algorithm Backjumping The algorithm Backjumping presented by John Gaschnig (1977; 1978) keeps track of the values of past variables that conflict with the current variable. When a dead end occurs for the variable x,41, it identifies the culprit variable x; as the atest variable whose (assigned) value is the first to conflict with some value of X41. The idea is that such a variable i