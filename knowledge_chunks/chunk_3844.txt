found, repeat the following procedure: If there are no nodes on OPEN, report failure. Otherwise, pick the node on OPEN with the lowest f value. Call it BESTNODE. Remove it from OPEN, Place it on CLOSED. See if BESTNODE is a goal node. If so, exit and report a solution (either BESTNODE if all we want is the node or the path that has been created between the initial state 60 Artificial Intelligence asceamobastsoreen aes and BESTNODE it we are interested in the path). Otherwise, generate the successors of BESTNODE but do not set BESTNODE to point to them yet. (First we need to see if any of them have already been generated.) For each such SUCCESSOR, do the following: (a) (b) (c) (d) (e) Set SUCCESSOR to point back to BESTNODE. These backwards links will make it possible to recover the path once a solution is found. Compute g(SUCCESSOR) = g(BESTNODE) + the cost of getting from BESTNODE to SUCCESSOR. See if SUCCESSOR is the same as any node on OPEN (i.e., it has already been generated but not processed). If so, call that node OLD. Since this node already exists in the graph, we can throw SUCCESSOR away and add OLD to the list of BESTNODE s successors. Now we must decide whether OLD s parent link should be reset to point to BESTNODE. It should be if the path we have just found to SUCCESSOR is cheaper than the cusrent best path to OLD (since SUCCESSOR and OLD are really the same node). So see whether it is cheaper to get to OLD via its current parent or to SUCCESSOR via BESTNODE by comparing their g values. If OLD is cheaper (or just as cheap), then we need do nothing. If SUCCESSOR is cheaper. then reset OLD s parent link to point to BESTNODE, record the new cheaper path in g(OLD}, and update f (OLD). If SUCCESSOR was not on OPEN, see if it is on CLOSED. If so, call the node on CLOSED OLD and add OLD to the list of BESTNODE , successors. Check to see if the new path or the old path is better just as in step 2(c), and set the parent link-and g and f values appropriately. Jf