 size, in terms of the number of objects, the number of operators with a fixed number of preconditions, the number of add effects and the layer number. And the planning graph can be constructed in polynomial time (Blum and Furst, 1997). Given that the planning problem is known to be hard (Gupta and Nau, 1992), we can infer that most of the work done by Graphplan is in the plan extraction phase. Two lines of exploration now present themselves. One is to try and make the plan extraction phase as efficient as possible. Some of the ideas from constraint solvers like forward checking can be applied here. In fact, in the following section, we will explore viewing the plan extraction task as a constraint satisfaction problem. The second is to find other ways to exploit the planning graph in other ways. We will also look at methods to use the planning graph to generate heuristics to guide state space search. 10.1.5 STAN One approach to make Graphplan more efficient was implemented in the program STAN (state analysis) reported by Derek Long and Maria Fox (1999). The reader can observe that the first few lines of the ExtendGraph algorithm of Figure 10.5 are devoted to copying information from the previous layer. This incurs a cost both in time and space. Given that both propositions and actions are carried over to succeeding layers, STAN simply keeps one copy of each and keeps track of when the proposition and action was first introduced. Given an initial state and the set of planning operators, the overall set of (ground) actions and propositions is well defined. STAN represents the set of possible ground actions and propositions as bit vectors called the action spike and the fact spike respectively. The rank of an entry in the spike marks its first appearance. A fact rank is a consecutive sequence of fact headers of the same rank. Facts are represented using fact headers arranged according to rank, and the headers contain, 1. aname which is the predicate and arguments that 