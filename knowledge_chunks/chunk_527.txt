n. The distinction between active propositions and inactive ones can be marked by adding another value to the domain of that proposition. This value , read as false or bottom, signifies that the proposition is inactive. In other words, a proposition P is active, if and only if P 1. With this new value added to the domain, all the propositions in all the layers are treated equally and participate in the solution finding process together. In the solution, only the active variables (propositions) are assigned values (producing actions) and the rest are assigned L. Every Active(P) statement in the DCSP is replaced by P L. The constraints introduced in the DCSP are now written as follows, The activity constraint activates the preconditions of the action a chosen for a goal proposition p at level i. Pi a; D Active precond(a)4 Let precond(a) p', p2, ..., p . Then the above activity constraint is written as, pp a, Dp) lap i tla..ap. l If G g", 92, ..., g" is the goal set in the final layer x of the planning graph, the corresponding constraints in the CSP are, Nt LN GALA. ANGEL The proposition mutex (Active(q;) Active(p;)) is encoded as, a gq l A p l)orgat V pat The procedure described above allows us to encode a planning graph into a CSP. But is it necessary to first construct the planning graph and then encode it into a CSP? The answer is no, and it was shown by Peter van Beek and Xinguang Chen, in a system called CPlan, that one can directly encode a planning problem with a bound on the number of layers as a CSP (van Beek and Chen, 1999). We look at a way of encoding a planning problem using the state-variable representation as described in (Ghallab et al., 2004). 10.2.1 CSP from State-Variable Representation We look at an approach to encode a planning problem directly into a CSP using the same example. The state-variable representation uses functions on variables instead of predicates. For example, instead of using the predicate On(x, y), we use a function On(x) and indi