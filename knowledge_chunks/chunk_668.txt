plied) if c First(First (A) ) then return First (A) else return BackChain(Cc, Rest(A)) .8 A simple forward-search proof procedure. Observe that we assume refractoriness: Each rule can only fire once with the same it theorem proving does not backtrack. The CHOOSE operator makes the right choice non-deterministically. We assume that f each rule exist in the form (consequent, list-of-antecedents). The reversed Proof contains a sequence of statements along with a ition is either the rule used to produce that statement, or the string Premise if the statement is a premise. above algorithm we have used the non-deterministic CHOOSE operator that somehow selects th ply at each inference step. In practice any of the search strategies we have used could be employ rministic choice the search does not have to backtrack. This is because an inappropriate inference ntence that is not required for the proof. The set of sentences grows monotonically with each infere an impact though because the task of finding applicable rules becomes more expensive. Combinec some inferences may not be useful and only add to the computations, the choice of the correct rule s the complexity of the proof finding algorithm. This will become critical when we move on to fe first order logic. ard reasoning suffers from the same problem as forward search in planning. It lacks a sense of dir 1 version of the above algorithm is likely to be much more focused. It will be simpler than the backw anning algorithm because the problem of spurious states is not there. It may have to backtrack thou consequent is produced by different rules. The reader is encouraged to write a backward versi jorithm. Rules vs Meta Rules ' inference says that if the antecedents exist in the database then the consequent may be adds nplication a D B says that if a is true then so is B. In fact this is the property used in rule based sys Jin Chapter 6). ve think of the Alf ranference as an implication statement (antecedent D consequent) a