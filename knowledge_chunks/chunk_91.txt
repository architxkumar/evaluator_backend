dedDFS (start, depthBound) open ((start, NIL, 0)) closed () while not Null (open) do nodePair Head(open) node Head (nodePair) if GoalTest (node) TRUE then return Reconstruct Path Bw (nodePair, closed) , closed) if Head(Rest (Rest (nodePair))) depthBound then children MoveGen (node) noLoops - RemoveSeen(children, open, closed) new MakePairs (noLoops, node, Head (Rest (Rest (nodePair)))) open Append(new, Tail (open)) return No solution found else closed Cons (nodePa. BB wo IH Uw ey Bwber MakePairs(list, parent, depth) i if Null(list) 2 then return () 3 else return (Cons (MakeList (Head(list), parent, depth 1)), 4 MakePairs(Tail(list), parent, depth)) FIGURE 2.27 Depth Bounded DFS generates new nodes only within a defined boundary. Performance wise, DBDFS is like DFS on a finite tree. However, given that the depth bound is artificially imposed, the algorithm is not complete in the general case. 2.8 Depth First Iterative Deepening (DFID) The algorithm Depth First Iterative Deepening (DFID) combines the best features of all the algorithms described above. It does a series of depth first searches with increasing depth bounds. Since in every cycle it does a DFS with bound incremented by one, whenever it finds a solution it would have found the shortest solution. In this respect, it is like BFS. New nodes are explored one level at a time. On the other hand, within each cycle it does a DBDFS. Therefore, its memory requirements are those of DFS, that is, memory requirements grow linearly with depth. DepthFizrstiterativedeepening (start) 2 depthBound 1 2 while TRUE 3 do DepthBoundedaDFS (start, depthBouna) 4 depthBound depthBound 1 FIGURE 2.28 DFID does a series of DBDFSs with increasing depth bounds. The high level algorithm described above ignores the possibility of a finite search space with no solution. In that situation, the above algorithm will loop endlessly. The detailed algorithm given below keeps a count of the number of nodes examined in each call of DBDFS. If the c