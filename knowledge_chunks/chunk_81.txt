esented by the two lists OPEN and CLOSED. DepthFirstSearch() open ((start NIL)) 2 elosed () 3 while not Null(open) 4 do nodePair Head(open) 5 node Head(nodePair) if GoalTest(node) TRUE 7 then return ReconstructPath(nodePair, closed) 8 else closed Cons(nodePair, closed) 9 children MoveGen (node) 10 noLoops RemoveSeen(children, open, closed) ai new MakePairs(noLoops, node) 12 open Append(new, Tail(open)) 13 return No solution found RemoveSeen (nodeList, openlist, closedList) if Null(nodeList) then return () else n Head(nodeList) if (OccursIn(n, openList) OR OccursIn(n, closedList)) then return RemoveSeen(Tail(nodeList), openlist, closedList) else return Cons(n,RemoveSeen(Tail(nodeList), openList, closedList) AU BWM Occursin(node, listOfPairs) 1 iff Null(listofPairs) By then return FALSE 3 elseif n Head(Head(listofPairs) 4 then return TRUE 5 else return OccursIn(node, Tail(listoOfPairs)) MakePairs (list, parent) 1 af Null(list) 2 then return () 3 else return Cons (MakeList (Head(list), parent), MakePairs(Tail(list), parent)) FIGURE 2.18 DFS treats OPEN like a stack adding new nodes at the head of the list. The function RemoveSeen removes any nodes that are already on OPEN or CLOSED. The function MakePairs takes the nodes returned by RemoveSeen and constructs node pairs with the parent node, which are then pushed onto OPEN. DFS treats OPEN like a stack. The search tree as seen by DFS OPEN CLOSED (S.NiD) 19) (A.S)B, SVC. S) (GS, Ni)) (Z.A)B. S (C.S)) (A, SS. Nit) (D.E) G. EB. C. )) (E. AWA, S S. Ni) (GBB. SVC. )) (.E)E. AMA, SS. Ni) Again, the search terminates when G is picked. The program reconstructs the path and returns SAEG, which is the path found from to G. The back pointers are: GE, E A, AS FIGURE 2.19 The search tree as seen by Depth First Search. 2.4 Breadth First Search (BFS) Breadth First Search (Figure 2.20), on the other hand, is very conservative. It inspects the nodes generated on a first come, first served basis. That is, the nodes form a queue to be ins