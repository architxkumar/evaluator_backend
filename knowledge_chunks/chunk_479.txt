d. But here the algorithm is compelled to do chronological backtracking. The reason for this is as follows. Let x, be the culprit variable that Backjumping has jumped back to. Now the fact that the algorithm had earlier proceeded beyond x, means that it had found a consistent value for xX,. It is only when it has jumped back to x, that it cannot find another consistent value. The reason it cannot apply the same principle while backtracking from x,, the internal dead end, is that it was consistent with its predecessors (when it went forward) and, therefore, will be consistent with all the prefixes of the predecessors as well. And it cannot find a new culprit by trying the compound label with the remaining values of x, because it might jump over a variable which might have a value consistent with one of the ignored values of x . Hence to be safe, BackJumping steps back to the previous variable. The reader should verify that this happens automatically with the value stored in latest(c), and likewise for its predecessors. In the search tree of Figure 9.34, when the algorithm is unable to choose a value for the variable C, it will jump back to F r, which is the first variable C r came in conflict with. Before that C b would have conflicted with B b, but of the two, F is the latest variable. Since the algorithm has no other value for F (w conflicts with G w), it steps back one step to the variable C. An algorithm that is able to jump back from internal dead ends as well is described below. The algorithm GraphBackjumping decides which variable is a culprit, based on the topology of the underlying constraint graph. In the process, it tends to be more conservative, and its jumps may not be maximal. 9.8.2 Algorithm GraphBackjumping The reason that a chronological step back may not be useful is that the previous variable may not have imposed any constraint on the current dead-end variable. One simple way to infer that the previous variable did not impose a constraint that resu