. If D were to be the leaf dead end that initiated the retreat for some assignment ar to variables C, E, A, Band F then it would jump back to F, and if F had no more values it would now go to C, because that is the latest connected predecessor for both F and D, the node it jumped back from. If on the other hand, G were to be the dead end for an assignment ap to variables C, E, A, B, F and D, the algorithm would jump back to F, and then to E if it had to retreat further, if F was an internal dead end, finally backtracking to C if needed. In the algorithm GraphBackjumping in Figure 9.44, each variable X maintains a set Ty of target variables that it may have to jump back to. This set is initialized to Parents(X) (the parents of X in the given ordering) when search advances to X. Ty Parents(X) GraphBackjumping (X, D, C) 1 Ae (()) 2 iel 3 De D, 4 T, Parents(i) s while lsicgn do a, SelectValue(D, , A, C) 7 if a; null 8 then iCurrent i i i Latest(T:) 10 T, TL UY (Tegyrcens O PrEedecessors (X,)) 11 A JumpTail(A, i, iCurrent) 12 else 13 A Cons(a,;, A) 14 ieiel 15 afigia 16 then D, D, 17 T, Parents (i) 18 xeturn Tail (Reverse (A) ) SelectValue (D, , A, C) while not empty(D, ) do a; Head(D, ) D, - Tail(D, ) af Consistent(A, x; a,) then return a, Oh wWhN xeturn null FIGURE 9.44 The procedure GraphBackjumping is like Backjumping, but maintains a list of target variables 7; it can jump back to from Xj. When the time comes, it jumps to the latest variable in 7; at that point. We assume a function JumpTail(A, i, iCurrent) that rolls back the partial solution by an appropriate amount determined by the two indices i and iCurrent. Let the search jump back from some variable Y fo X. If there is no value remaining in the domain of X then the algorithm will have to jump back from X. The candidate nodes for jumping back to are the nodes in Tx and the nodes in Ty that occur before X in the ordering. Ty Ty U (Ty MPredecessors(X)) We assume a function Predecessors(X) that returns the nodes 