ledge about this sort of thing, the answer is clear. An AI program, however, might decide to try painting first, since any physical object can be painted, regardless of whether it has been sanded. However, as the program plans further, it will realize that one of the effects of the sanding process is to remove the paint. The program wil! then be forced to plan a repainting step or else backtrack and try working on another subgoal first. Proper search control knowledge can prevent this wasted computational effort. Rules we might consider include: e Ifa problem s subgoals include sanding and painting, then we should solve the sanding subgoal first. If subgoals include sealing and painting, then consider what the object is made of. If the object is made of wood, then we should seal it before painting it. Before closing this section, we should touch on a couple of seemingly paradoxical issues concerning control rules. The first issue is called the utility problem (Minton, 1988]. As we add more and more contro! knowledge to a system, the system is able to search more judiciously. This cuts down on the number of nodes it expands. However, in deliberating about which step to take next in the search space, the system must consider all the control rules. If there are many control rules, simply matching them all can be very timeconsuming. It is easy to reach a situation (especially in systems that generate control knowledge automatically) Representing Knowledge Using Rules 145 CN SLR RENT RN RTC in which the system s problem-solving efficiency, as measured in CPU cycles, is worse with the control rules than without them. Different systems handle this problem in different ways, as demonstrated in Section 17.4.4. The second issue concerns the complexity of the production system interpreter. As this chapter has progressed, we have seen a trend toward explicitly representing more and more knowledge about how search should proceed. We have found it useful to create meta-rules that