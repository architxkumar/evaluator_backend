description elements, it is more efficient to consider the many-many match problem, in which many rules are matched against many elements in the state description simultaneously. One efficient many-many match algorithm is RETE, which gains efficiency from three major sources: e The temporal nature of data. Rules usually do not alter the state description radically. Instead, a rule will typically add one or two elements, or perhaps delete one or two, but most of the state description remains the same. (Recall our discussion of this as part of our treatment of the frame problem in Section 4.4.) If a rule did not match in the previous cycle, it will most likely fail to apply in the current cycle. RETE maintains a network of rule conditions, and it uses changes in the state description to determine which new rules might apply (and which rules might no longer apply). Full matching is only pursued for candidates that could be affected by incoming or outgoing data. e Structural similarity in rules. Different rules may share a large number of pre-conditions. For example, consider rules for identifying wild animals. One rule concludes jaguar(x) if mammal(x), feline(x), camnivorous(x), and has-spots(x). Another rule concludes tiger(x) and is identical to the first rule except that it replaces has-spots with has-stripes. If we match the two rules independently, we will repeat a lot of work unnecessarily. RETE stores the rules so that they share structures in memory; sets of conditions that appear in several rules are matched (at most) once per cycle. * Persistence of variable binding consistency. While all the individual preconditions of a rule might be met, there may be variable binding conflicts that prevent the rule from firing. For example, suppose we know the facts son(Mary, Joe) and son(Bill, Bob). The individual preconditions of the rule 3 Conflict resolution is discussed in the next section. 140 Artificial Intelligence al son(x, y) A son(y. z) > grandparent(x, z) can b