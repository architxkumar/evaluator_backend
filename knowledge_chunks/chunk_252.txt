dex i value Wi) array index j i value M Nj modi y 1 value ) modify 2 value N We have used the notation of the language OPS5 (Forgy, 1981), one of the first rule based languages developed at Carnegie Mellon University. The above rule has a name interchange and reads as follows: gule interchange IF there is an element at index i with value N, AND IF theze is an element at index j 1 with value M N THE modify array(i to held M, AND modify array(j to hold Nj Given an array of numbers, this rule will keep firing as long as it sees two numbers that are in an incorrect order, and will only stop when all pairs of elements are in order. While this rule will indeed sort a given array, one cannot make any statement about how efficient it will be in doing so. This is because we do not know which two elements it will look at any given time point. That would depend upon the conflict-resolution strategy adopted by the inference engine (describe below). This rule gives us an insight into a strong point of rule based systems that the same rule can apply to different sets of data doing the same task with each one of them. Identifying what data a rule matches is done at runtime. Thus, based on the kind of processing we want to do, we could write a set of rules that will apply to patterns in any given state. This would imply that we may not have to write MovGen functions for doing state transformation. Instead, the state transformation (or moves) can be composed from rules. We will look at this approach in more detail in Chapter 7 on planning, in which we will use planning operators, which are like production rules, to construct sets of moves to search over. Both the examples above depict rules being used with forward chaining. That is, the left-hand side is used to match the rule and the righthand side, the effect of using the rule. The other direction is also possible. The right-hand side can be used as a match pattern and the left-hand side defines the effect of using the rule. Such 