 which each point corresponded to a situation that might arise. The search started with an initial situation and performed a sequence of allowable operations until a situation corresponding to a goal was reached. Then, in Chapter 3, we described a variety of ways of moving through such a search space in an attempt to find a solution toa | particular problem. For example, the A* algorithm provides a way of conducting a best-first search through a graph representing a problem space. Each node that is examined in the A* algorithm represents a description of a complete problem state, and each operator describes a way of changing the total state description. For simple problems, such as, say, the 8-puzzle, manipulating the complete state description at one time is easy and reasonable. However, for more complicated problem domains, it becomes important to be able to work on small pieces of a problem separately and then to combine the partial solutions at the end into a complete problem solution. Unless we can do this, the number of combinations of the states of the components of a problem becomes too large to handle in the amount of time available. There are two ways in which it is important to be able to perform this decomposition. First of all, we must avoid having to recompute the entire problem state when we move from one state to the next. Instead, we want to consider only that part of the state that may have changed. For example, if we 248 Artificial Intelligence move from one room to another, this does not affect the locations of the doors and the windows in the two rooms. The frame problem, which is the problem of how to determine which things change and which do not, becomes increasingly important as the complexity of the problem state increases. It is not difficult to figure out how the state of the 8-puzzle should change after every move, nor is it a lot of work to record explicitly a new copy of the state with the appropriate changes made. Our rules for moving