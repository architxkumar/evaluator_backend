ious other agents This kind of reasoning is usually called multi-agent planning. The first step, problem decomposition, is essentially the same as it is for single-agent planning systems. Ideally the decomposition results in a set of subproblems that are mutually independent. This is often not possible, however, so various of the techniques that we described in Chapter 13 must be exploited. Once a decomposition has been produced, the subproblems must be allocated to the available agents for execution, At this point, distributed planning differs from single agent planning in the following important ways: Unless all the slave agents are identical, the master agent must have access to models of the capabilities of the various slaves. These models make it possible to allocate tasks to the agents that are best able to perform them. Even if all the slave agents are identical, the master must do load balancing to assure that the overall goal is completed as soon as possible. * Once the tasks have been distributed, synchronization among the slaves is necessary unless all the tasks are completely independent. In single-agent planning, dependencies are usually handled at plan creation time. In a multiple agent system, it is not usually possible to do that, since any such static scheme will be defeated if the various agents take unpredictable amounts of time to perform their tasks. Let us consider this last issue in a bit more detail. Suppose the task is to do spelling correction on a document with several chapters, and then to print it. We can distribute this among several spelling correcting agents and one printing agent. But to get the desired result, we need to ensure that the printing agent does not begin printing any chapter until spelling correction on that chapter is complete. Distributed reasoning systems exploit a wide variety of synchronization techniques to guarantee this, ranging from simple ones (e.g., in which the printing process does not begin until all the sp