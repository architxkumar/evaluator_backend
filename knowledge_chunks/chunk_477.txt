end occurs for the variable x,41, it identifies the culprit variable x; as the atest variable whose (assigned) value is the first to conflict with some value of X41. The idea is that such a variable is likely to be safe and maximal for jumping back to. We illustrate this with an example from the 6-queens problem. Let a search algorithm place five queens as shown in Figure 9.41 before it reaches a dead end. There is no value for the sixth queen. The numbers in the row 6 on the chessboard represent the earliest queen that conflicts with that square. For example, the value 3 in the square 6, b says that queen 3 is the earliest one that conflicts with placing queen 6 on this square. Gaschnig s BackJumping algorithm employs a ratchet variable called atest, for the khvariable that keeps track of the highest such values. In the figure, this value is 4 from the square 6, d . a be de f wy x x x x Ps BL X x tw bw ay latest, 1 3 3 4 4 4 FIGURE 9.41 Gaschnig s Backjumping identifies the culprit as the latest variable that has conflicted with a value being considered. In this figure, there is no value for queen 6. The numbers in row 6 identify the first queen that conflicts that value (column label). The variable latest, is a ratchet that keeps track of the highest such value. Gaschnig s algorithm is like Backtracking, except that when the procedure to select a value is called for the variable x; it either returns a value for that variable, or returns null along with the value for atest;. In the algorithm in Figure 9.42, we assume that the variables atest; is in a global array l atest(i) visible to both procedures. We also assume a function SubLabel(A, k) that returns a prefix of the label constituting of (chronologically) the first k values in a compound label A. When Backjumping calls SelectValue-GBJ with a variable x;, the latter inspects values in the domain Dj one by one, till it finds a consistent value. For each value, it checks for consistency with the prefix of k values