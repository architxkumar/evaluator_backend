 CSP using the same example. The state-variable representation uses functions on variables instead of predicates. For example, instead of using the predicate On(x, y), we use a function On(x) and indicate that (block) A is on B by the statement, On(A) B. On(A) is called a state variable, and it can take a value of type Block. Let S be of type state. The initial state as shown in Figure 10.4 is represented as, On(A, So) B, On(B, So) table, On(C, So) nil, ONT(A, So) 0, OnT(B, So) 0, ONT(C, So) 1, Clear(A, So) 1, Clear(C, So) 1, Clear(B, So) 0, Holding(arm, So) nil The second argument in the above functions is a state identifier. If the planning system reasons only with the current state, the state parameter can be left implicit. We could then describe the state So as, So On(A) B, On(B) nil, On(C) nil, OnT(A) 0, OnT(B) 1, OnT(O) 1, Clear(A) 1, Clear(C) 1, Clear(B) 0, Holding(arm) nil The state is described by a set of state variables On(A), On(B), On(C), OnT(A), OnT(B), OnT(C), Clear(A), Clear(B), Clear(C), and Holding(arm). These variables can take values from their respective domains. For example, Do,(,) B, C, nil , Dona) B, C, nih, Detearla) 0, 1 , and Drolaing (army A, B, C, nil . The values for these variables are either domain objects, which may be typed for example Holding(arm) can take a value of type Block or nil or of a different sort, for example Clear(A) can take a O or 1 value. One can observe that this representation lends itself naturally to posing the planning problem as a CSP. Also observe that we have specified values of variables like Clear(B, So) 0 in the spirit of completely specifying the start state. In the classical representation used by STRIPS, only the propositions that are true needed to expressed. The goal can in turn be represented by a set of constraints. Let us say the goal (again) is simply that A should be on C, and C should be on the table. Assuming that we are looking for a plan of maximum k steps, we expect the following sequence of