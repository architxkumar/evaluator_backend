e reader. The dynamic CSP starts of with an initial set of constraints derived from the goal propositions. These constraints say that the goal propositions are active. Initial State Active On2(A, C), OnT2(C) The goal propositions are regressed to subgoal propositions by a set of activity constraints. Given an action (value), the activity constraint relates the active proposition to its preconditions. The activity constraints are of the form, pj a; D Active precond(a)4 4 For our example, the activity constraints are the following: Activity constraints On2(A, C) Stack(A, C) Active Hold,(A), Clear,(C) OnT2(C) No-op Active OnT,(C) OnT2(C) PtDn(C) Active Hold,(C) The proposition mutexes are encoded in a straightforward manner. If two propositions p and q are mutex in a layer i, they are expressed as, Active(q;) 7(Active(p;)) or (Active(qj) Active(p;)) A simple procedure for solving a DCSP will need to start with assigning values to active variables, and then proceed in a backtracking like manner, considering one new active variable at a time. In the process, new variables may be activated. When the algorithm is applied to the DCSP generated by encoding the planning graph, this process mimics the backward depth-first procedure adopted by Graphplan. Another approach would be to compile the DCSP into a standard CSP. One could then use the different approaches used to solve CSPs (see Chapter 8). Solving this CSP would not be constrained by the backward direction ordering of variable imposed by DCSP. More importantly, separating the encoding (into a CSP) phase from the solving phase means that one can use state of the art CSP solvers. A DCSP marks certain variables (goal propositions) as active. Only the active propositions are assigned values (actions) and participate in the plan. The distinction between active propositions and inactive ones can be marked by adding another value to the domain of that proposition. This value , read as false or bottom, signifies that the propo