. owl:allDifferent owl:distinctMembers rdf:parseType Collection composer rdf:about dimitriShostakovich composer rdf:about ludwigVanBeethoven composer rdf:about solfgangAmadeusMozart composer rdf:about johannSebastianBach" owl:distinctMembers owl:allDifferent OWL also allows cardinality restrictions to be placed in the manner of EXISTS n r and AT-MOST rn f f . This is expressed by owl:minCardinality and owl:maxCardinality. owl:Class rdf:about averageFan" rdfs:subClassof owl:Restriction owl:onProperty rdf:resource " fanOf owl:maxCardinality rdf:datatype xsd;nonNegativeInteger 4 owl:maxCardinality owl:Restriction rdfs:subClassOf owl:Class The above statement says that the class averageFan is made up of elements (people) who are fans of at most 4 elements (people). The thought might have occurred to the discerning reader that OWL requires a considerable amount of overheads in terms of space, and that the XML based syntax is very cumbersome. The response to the second point is that the syntax is meant to be processed by a program and not by a human. Humans will presumably define and build their knowledge bases using some easy to use interface, for example Prot g 28 (see also (Denny, 2002)). The answer to the first question is that OWL is a language for specifying ontologies. It need not be a language for storing ontologies and the instances associated with them. Having a formal specification of the ontology will allow one to reason about it. One can ask questions of the type we had posed in the Description Logic section does an individual belong to a particular class or, does one class subsume another, or is the specification consistent? If ontology will have a large amount of instances or individuals stored with it, then it will be profitable to pursue computationally efficient storage systems. For example, we might want to store an ontology in a relational data base management system (see for example (Pan and Heflin, 2003), (Kraska and R6 hm, 2006), (Rohloff et al., 20