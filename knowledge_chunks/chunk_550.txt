ethod is the use of helpful actions. The set of helpful actions is the set A, in the relaxed plan (Aj, Ao, ..., Am) found by FF. The pruning method used is to consider only the actions in the helpful actions set. The method can be very effective in many situations. Consider for example the planning problem in which there are a hundred blocks A,, Az, ..-, A1oo stacked on another hundred corresponding blocks B,, Bo, ..-, Byoo , and the goal is to achieve On(Az1, Ag). Then the relaxed plan found would have only the action Unstack(Az1, B21) in the first layer of actions, and FF would only consider that and ignore the ninety nine other unstack actions. However, consider the goal On(Bo1, Bg). FF would begin by finding the relaxed plan, ( Unstack(A21, Bo1), Unstack(Ag, Bg) , Pickup(B1) , Stack(Bo,, Be) ) This plan has two helpful actions, and let us say that FF chooses Unstack(Ag, Bg). This results in a new state in which Holding(Ag) and Clear(Bg) are true, and ArmEmpty is false. From this state, there are several relaxed plans possible. The important goal in all these relaxed plans is to achieve ArmEmpty so that Pickup(B21) becomes possible. We look at 3 of the 101 such actions possible, yielding the following relaxed plans. relaxed-plan-1 ( PutDown(Ag) , Unstack(Az;, Bo1) , Pickup(B21) , Stack(B21, Bg) ) relaxed-plan-2, ( Stack(Ag, Az1) , Unstack(A21, Bo1) , Pickup(B21) , Stack(B21, Be) ) relaxed-plan-3 ( Stack(Ag, Bg) , Unstack(Az;, Bo1) , Pickup(B2,) , Stack(B21, Be) ) As far as the relaxed problem is concerned, all three actions PutDown(Ag), Stack(Ag, Az1) and Stack(Ag, Bg) achieve ArmEmpty. The fact that the latter two have undesirable effects is not noticed because those effects are the delete effects which are ignored. Thus, FF cannot see that Stack(Ag, Az1) will delete Clear(A2,) needed for Unstack(A ,, Bo), and Stack(Ag, Bg) will delete Clear(Bg) needed for Stack(Bo1, Bg). As we can see, if FF uses the relaxed-plan-2 or relaxed-plan-3, the set of helpful actions 