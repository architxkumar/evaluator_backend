 to be solvable by straightforward search from the starting state to a winning position. The first of these reasons remains valid and accounts for continued interest in the area of game playing by machine. Unfortunately, the second is not true for any but the simplest garhes. For example, consider chess. e The average branching factor is around 35. In an average game, each player might make SO moves. So in order to examine the complete game tree, we would have to examine 35' positions. Thus it is clear that a program that simply does a straightforward search of the game tree will not be able to select even its first move during the lifetime of its opponent. Some kind of heuristic search procedure is necessary. 232 Artificial Intelligence _ Sassen eer aa saan e Ne RNRRORNISIO SIONAL NARA, One way of looking at all the search procedures we have discussed is that they are essentially generateand-test procedures in which the testing is done after varying amounts of work by the generator. At one extreme, the generator generates entire proposed solutions, which the tester then evaluates. At the other extreme, the generator generates individual moves in the search space, each of which is then evaluated by the, tester and the most promising one is chosen. Looked at this way, it is clear that to improve the effectiveness of a search-based problem-solving program two things can be done: Improve the generate procedure so that only good moves (or paths) are generated. e Improve the test procedure so that the best moves (or paths) will be recognized and explored first. In game-playing programs, it is particularly important that both these things be done. Consider again the problem of playing chess. On the average, there are about 35 legal moves available at each turn. If we use a simple legal-move generator, then the test procedure (which probably uses some combination of search and a heuristic evaluation function) will have to look at each of them. Because the test procedure mu