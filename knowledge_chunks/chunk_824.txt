erse the subtree of all its ancestors, and copy property values from each ancestor. This can also be done in a demand (goal) driven manner. Whenever the fillers of a particular frame are needed, a traversal of all its ancestors will yield the fillers to be inherited. Inheritance of slot fillers is not mandatory. A child frame can override the value it receives from an ancestor and specify its own filler. For example, the frames Penguins and Ostriches would be children or descendants of the frame Birds, but will not inherit the filler Yes for the slot Can-fly . In this manner, we can assert that birds can fly to serve as a default statement, but we can add exceptions to birds like penguins and ostriches. This allows us to make general statements like birds can fly , leaves are green , and mushrooms are edible , without having to commit them to be universal statements. The frame system is a mechanism for organizing knowledge. A consequence of allowing arbitrary slot filler values for frames is that the onus of correctness now lies entirely with the user. The frame system simply serves as a means for economy of expression. Along with economy also comes consistency. If a property value were to be modified, then it needs to be done only in one place. Property values are not usually modified when representing knowledge about the (unchanging) world, for example the living world. In such a world, we can take recourse to a stricter representation mechanism that does not allow a user to make inconsistent statements, but forces her to be logically consistent. For example, we can associate Can-fly property with a class called Flying-creatures and make Flying-Birds , and Bats , its children. Then Flying-birds can be children of Birds , but they inherit the flying property not from Birds but from Flying-creatures . We will explore such Description Logics later in this chapter. Meanwhile, frame systems can be used to represent information rich in abstraction and aggregation. In ad