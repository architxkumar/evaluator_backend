to the next level. Suppose we made move B. Then the opponent must choose among moves E, F, and G. The opponent s goal is to minimize the value of the evaluation function, so he or she can be expected to choose move F. This means that if we make move B, the actual position in which we will end up one move later is very bad for us. This is true even though a possible configuration is that represented by node E, which is very good for us. But since at this level we are not the ones to move, we will not get to choose it. Figure 12.3 shows the result of propagating the new values up the tree. At the level representing the opponent s choice, the minimum value was chosen and backed up. At the level representing our choice, the maximum value was chosen. B Cc D 6] [x] [ (9) (4) (8) (2) 4) ) Fig. 12.2 Two-Ply Search A] (-2) Maximizing ply Minimizing ply F] [es] [x (9) (-6) (0) (0) (-2) OH) 63) Fig. 12.3 Backing Up the Values of a Two-Ply Search Once the values from the second ply are backed up, it becomes clear that the correct move for us to make at the first level, given the information we have available, is C, since there is nothing the opponent can do from there to produce a value worse than -2. This process can be repeated for as many ply as time allows, and Game Playing 235 cane NRS A ERERANERARNR ESOT the more accurate evaluations that are produced can be used to choose the correct move at'the top level. The alternation of maximizing and minimizing at alternate ply when evaluations are being pushed back up corresponds to the opposing strategies of the two players and gives this method the name minimax. Having described informally the operation of the minimax procedure, we now describe it precisely. It is a straightforward recursive procedure that relies on two auxiliary procedures that are specific to the game being played: 1. MOVEGEN(Position, Player) The plausible-move genetator, which returns a list of nodes representing the moves that can be made by Player in Posit