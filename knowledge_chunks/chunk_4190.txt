ktrack prevented it from finding many solutions. The NONLIN program included backtracking, but it also failed to solve many hard problems. Back in our example, the only unachieved precondition left is *CLEAR(A), from the PICKUP(A) step. We can use step addition to achieve it: *ON(x,A) * CLEAR(2) * ARMEMPTY UNSTACK(x, A) 7>ARMEMPTY CLEAR(A) HOLDING(A) AON(x, A) We introduce the variable x because the only postcondition we are interested in is CLEAR(A). Whatever block is on top of A is irrelevant. Constraint posting allows us to create plans that are incomplete with respect to the order of the steps. Variables allow us to avoid committing to particular instantiations of operators. Unfortunately, we now have three new unachieved preconditions. We can achieve ON(x, A) easily by constraining the value of x to be block C. This works because block C is on block A in the initial state. This heuristic is called simple establishment, and in its most general form, it allows us to state that two different propositions must be ultimately instantiated to the same proposition. In our case: x =C in step UNSTACK(, A) There are stil} steps that deny the preconditions CLEAR(C) and ARMEMPTY, but we can use promotion to take care of them: UNSTACK(x, A) STACK(B, C) UNSTACK(x, A) PICKUP(A) UNSTACK(x, A) PICKUP(B) Among the heuristics we have looked at so far, adding a new step is the most problematic because we must always check if the new step clobbers some precondition of a later, already existing step. This has actually happened in our example. The step PICKUP(B) requires ARMEMPTY, but this is denied by the new UNSTACK(x, A) step. One way to solve this problem is to add a new declobbering step to the plan: HOLDING(C) PUTDOWN(C) AHOLDING(C) ONTABLE(x) ARMEMPTY 266 Artificial Intelligence ordered as: UNSTACK(x, A) PUTDOWN(C) ~ PICKUP(B) Notice that we have seen two types of declobbering, one in which an existing step is used to declobber another, and one in which a new declobbering step 