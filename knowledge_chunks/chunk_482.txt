didate nodes for jumping back to are the nodes in Tx and the nodes in Ty that occur before X in the ordering. Ty Ty U (Ty MPredecessors(X)) We assume a function Predecessors(X) that returns the nodes that are before X in the ordering. Note that Ty would likewise have been initialized to Parents(Y) and augmented, if Y were not a leaf dead end. If Y were to be a leaf dead end then Ty would be Parents(Y). Assuming that the nodes are visited in the order Xj, Xp, ..., X, then the index of the node that Backjumping will jump back to from X; is the latest node in 7;, the target set of X;. We assume a function Latest(T) that returns the index of the latest variable from a set T with respect to the given ordering. This making of a more informed leap back from an internal dead end is the way GraphBackjumping is different from Backjumping. Backjumping makes the first jump (from a leaf dead end) that is both safe and maximal, but subsequently moves back one step at a time in the chronological order. GraphBackjumping may be somewhat conservative in the first jump from the leaf dead end, but can make longer jumps from internal dead ends too. Backjumping relies on the actual conflicts of values it has seen. But these apply only to leaf dead ends. GraphBackjumping relies on possible conflicts as indicated by the constraint graph. It treats both internal and leaf dead ends in a similar manner. The only additional thing it needs to do for internal dead ends is to keep track of the parents of future variables it has backtracked from. The algorithm CDBackjumping or Conflict Directed Backjumping relies on the information of actual conflicts, but maintains a target set for jumping back to in the manner of GraphBacktracking. 9.8.3 Algorithm CDBackjumping Conflict Directed Backjumping is an algorithm that is aware of the underlying constraint graph, but determines where to jump back to, based on the actual conflicts that it has recorded. As a result, it can jump back over variables that Gr