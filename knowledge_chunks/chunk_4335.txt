 Table), ON(A, B). The body of the MACROP consists of the four f ' Learning 353 steps just mentioned. In future planning, STRIPS is free to use this complex macro-operator just as it would use any other operator. But rarely will STRIPS see the exact same problem twice. New problems will differ from previous problems. We would still like the problem solver to make efficient use of the knowledge it gained from its previous experiences. By generalizing MACROPs before storing them, STRIPS is able to accomplish this. The simplest idea for generalization is to replace all of the constants in the macro-operator by variables. Instead of storing the MACROP described in the previous paragraph, STRIPS can generalize the plan to consist of the steps UNSTACK(x,, x3), PUTDOWN(x,), PICKUP(x;), STACK(x, x ), where x), x, and x; are variables. This plan can then be stored with preconditions ON(x,, x2), ON(x;, Table) and postconditions ON(x,, Table), ON(x5, x3). Such a MACROP can now apply in a variety of situations. Generalization is not so easy, however. Sometimes constants must retain their specific values. Suppose our domain included an operator called STACK-ON-B(x), with preconditions that both x and B be clear, and with postcondition ON(x, B). Consider the same problem as above: Cc A B| [A B| |c start: ON(C, B) goal: ON(A, B) STRIPS might come up with the plan UNSTACK(C, B), PUTDOWN(C), STACK-ON-B(A). Let s generalize this plan and store it as a MACROP. The precondition becomes ON(x3, x2), the postcondition becomes ON(x,, x3), and the plan itself becomes UNSTACK(x;, x), PUTDOWN(Q;), STACK-ON-B(x,). Now, suppose we encounter a slightly different problem: je! [b A| [D A c B E c B start: ON(E, C) goal: ON(A, C) ON(D, B) The generalized MACROP we just stored seems well-suited to solving this problem if we let x, = A, x) = C, and x, = E. Its preconditions are satisfied, so we construct the plan UNSTACK(E, C), PUTDOWN(E), STACK-ON-B(A). But this plan does not work, The problem is tha