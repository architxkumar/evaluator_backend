esent two orthogonal ways of decomposing the class of major league baseball players. Everyone is-either a pitcher, a catcher, or a fielder (and no one is more than one of these), In addition, everyone plays in either the National League or the American League, but not both. 9.2.3 Slots as Full-Fledged Objects So far, we have provided a way to describe sets of objects and individual objects, both in terms of attributes and values. Thus we have made extensive use of attributes, which we have represented as slots attached to frames. But it turns out that there are several reasons why we would like to be able to represent attributes explicitly and describe their properties. Some of the properties we would like to be able to represent and use in reasoning include: The classes to which the attribute can be attached, ie. for what classes does it make sense? For example, weight makes sense for physical objects but not for conceptual ones (except in some metaphorical sense). Constraints on either the type or the value of the attribute. For example, the age of a person must be a numeric quantity measured in some time frame, and it must be less than the ages of the person s biological parents. A value that all instances of a class must have by the definition of the class. e A default value for the attribute. Rules for inheriting values for the attribute. The usual rule is to inherit down isa and instance links. But some attributes inherit in other ways. For example, /ast-name inherits down the child-of link. Rules for computing a value separately from inheritance. One extreme form of such a rule is a procedure written in some procedural programming language such as LISP. An inverse attribute. Whether the slot is single-valued or multivalued. In order to be able to represent these attributes of attributes, we need to describe attributes (slots) as frames. These frames will be organized into an isa hierarchy, just as any other frames are, and that hierarchy can then be used to s