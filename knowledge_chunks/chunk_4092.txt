e set of competing values for a slot S in a frame F contains all those values that Can be derived from some frame X that is above F in the isa hierarchy e Are not contradicted by some frame Y that has a shorter inferential distance to F than X does Notice that under this definition competing values that are derived from incommensurate frames continue to compete. . Using this definition, let us return to our examples. For Fig. 9.15(a), we had two candidate classes from which to get an answer. But Ostrich has a shorter inferential distance to Fifi than Bird does, so we get the single answer no. For Fig. 9.15(b), we get two answers, and neither is closer to Dick than the other, so we correctly identify a contradiction. For Fig. 9.16(a), we get two answers, but again Ostrich has a shorter inferential distance to Fifi than Bird does. The significant thing about the way we have defined inferential distance is that as long as Ostrich is a subclass of Bird, it will be closer to all its instances than Bird is, no matter how many other classes are added to the system. For Fig. 9.16(b), we again get two answers and again neither is closer to Dick than the other. There are several ways that this definition can be implemented as an inheritance algorithm. We present a simple one. It can be made more efficient by caching paths in the hierarchy, but we do not do that here. Algorithm: Property Inheritance To retrieve a value V for slot S of an instance F do: 1, Set CANDIDATES to empty. 2. Do breadth-first or depth-first search up the isa hierarchy from F following all instance and isa links. At each step, see if a value for S or one f its generalizations is stored. (a) Ifa value is found, add it to CANDIDATES and terminate that branch of the search. (b) If no value is found but there are instance or isa links upward, follow them. (c) Otherwise, terminate the branch. Weak Slot-and-Filler Structures 205 3. For each element C of CANDIDATES do: (a) See if there is any other element of C