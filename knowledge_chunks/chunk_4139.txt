ocedures that are specific to the game being played: 1. MOVEGEN(Position, Player) The plausible-move genetator, which returns a list of nodes representing the moves that can be made by Player in Position. We call the two players PLAYER-ONE and PLAYERTWO; in a chess program, we might use the names BLACK and WHITE instead. 2. STATIC(Position, Player) The static evaluation function, which returns a num ber representing the goodness of Position from the standpoint of Player? As with any recursive program, a critical issue in the design of the MINIMAX procedure is when to stop the recursion and simply call the static evaluation function. There are a variety of factors that may influence this decision. They include: Has one side won? How many ply have we already explored? How promising is this path? How much time is left? How stable is the configuration? For the general MINIMAX procedure discussed here, we appeal to a function, DEEP-ENOUGH, which is assumed to evaluate all of these factors and to return TRUE if the search should be stopped at the current level and FALSE otherwise. Our simple implementation of DEEP-ENOUGH will take two parameters, Position and Depth. It will ignore its Position parameter and simply return TRUE if its Depth parameter exceeds a constant cutoff value. One problem that arises in defining MINIMAX as a recursive procedure is that it needs to return not one but two results: The backed-up value of the path it chooses. The path itself. We return the entire path even though probably only the first element, representing the best move from the current position, is actually needed. We assume that MINIMAX returns a structure containing both results and that we have two functions, VALUE and PATH, that extract the separate components. Since we define the MINIMAX procedure as a recursive function, we must also specify how it is to be called initially. It takes three parameters, a board position, the current depth of the search, and the player to move. So t