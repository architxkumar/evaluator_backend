 subset of any state. For example, the description holding(A) clear(B) A holding(B) A clear(C) in the figure cannot describe a state, because our robot has only one arm and cannot hold two blocks. re Cc TS on(A, B) A on(B, C) The goal state stack(A, B) holding(A) 0 clear(B) on(B, C) 7 stack(B, C) holding(A) clear(B) holding(B) clear(C) fia pickup(A) Search terminates Z because the regressed goal is true in the ontable(A) a clear A) A clear(B) 1 holding(B) a clear(C) given state pickup(B) a B Ic ontable(A) a clear(A) a clear(B) ontable(B) a clear(C) Figure 7.6 The plan pickup(B), pickup(A), stack(B, C), stack(A, B) is not a valid plan. The given state Since we can have action sequences that are not feasible plans, let us define the notion of a valid plan. Definition A planning problem P is defined as a triple (S, G, O) where, Sis set of facts completely describing the given or start state, Gis a set of facts required to be true in a goal state, and Ois the set of operators. The above defines the simplest of planning problems. The simplest notion of a plan is a sequence of actions, each of which is an instance of some operator in O. Definition A sequence of actions I (a4, a9, ..., An) is a valid plan for a problem P, if a, is applicable in the state S, progressing to state Sj, a2 is applicable in the resulting state S;, and so on, yielding the state S, after the action a,, and G S Sp. A simple linear time procedure may be written to verify that a plan N (a4, a2, ..., Ap) is a valid plan, by successively progressing through the sequence of actions and checking whether the final state contains the goal facts G. ValidPlan(plan, state, goal) 1 if Empty(plan) 2 then if Satisfies(state, goal) 3 then return TRUE 4 else return FALSE 3 else state Progress(Head(plan), state) return ValidPlan(Taii(plan), state, goal) Figure 7.7 Algorithm to verify a plan. Function Satisfies checks whether the state satisfies the goal (that is G S). Function Progress progresses the state over an 