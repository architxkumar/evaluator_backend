ible. For example, in the blocks world domain, holding(Block) should be attempted last because it blocks up the robot arm. If it is solved or achieved first then it could be undone while achieving some other subgoal, since the plan is for a one-armed robot. The algorithm for GSP is shown in Figure 7.9. We assume, as is the case with many modern planners, that all instances of the planning operators that match the domain are available, is a set called actions. GSP(givenState, givenGoal, actions) 1 state givenState 2 plane () start with the empty plan 3 stack emptyStack start with the empty stack 4 PushSet(givenGoal, stack) 5 while not Empty(stack) do x Pop(stack) 7 if x actions 8 then plan (plan- x) operator extends plan with x 9 state Progress(x, state) 10 else if x is a conjunct of goal predicates C ll then solvedrlag TRUE 12 for each ge C 13 o if gc state 14 then solvedrlag FALSE 15 if solvedFiag FALSE 16 then PushSet(C, stack) 17 else if x givenState x is an unsatisfied goal predicate 18 then CHOOSE action a that achieves x 19 if no such action exists 20 then return FAILURE 21 Pusn(a, stack) 22 PushSet (Preconditions(a), stack) 23 return plan Figure 7.9 Goal Stack Planning uses a stack to keep pending goals and actions. It picks actions only when it is applicable in the given state, and progresses forward. Let us look at the trace of algorithm GSP on a small problem depicted in Figure 7.6. Let the initial state be: S onTable(A), onTable(B), onTable(C), clear(A), clear(B), clear(C), armempty Let the final state be a tower of A, B and C expressed by on(A, B), on(B, C) . Assume that we execute the algorithm GSP and keep a watch on the push and the pop actions, the plan being assembled, and the current state S as and when it changes. Remember, that PushSet is a function that pushes the set onto the stack, first the conjunct of predicates, and then each one individually. Let us assume that the trace shows us the object being pushed or popped, the plan whenever it is a