) That is, from the set of goal facts, remove the effects of the action, and add the preconditions of the action. Let us define a function regress(A, G) that returns the regressed goal over action A when applied to goal G. The regressed goal represents the minimum set of facts that must be true in a state in which the action can be applied and which would result in a goal state. However, the regression process is not sound, in the sense that the resulting set of predicates may not necessarily represent a state. This can happen because some actions that are relevant according to our definition may not be feasible in practice. This may result in an invalid plan. Figure 7.5 depicts some of the problems that may crop up in backward search. The algorithm begins with the given goal description on(G, A) A on(B, J) for the problem depicted in Figure 7.2. Observe that if a goal predicate is true in the current state then one does not need to look for a relevant action. Two actions are relevant here, stack(G, A) and stack(B, J). The former regresses to a goal holding(G) clear A) A on(B, J), from which four operators are relevant, as shown in the figure. The first, pickup(G), would need block G to be on the table. But since the algorithm is working with incomplete descriptions, it does not know whether this will be so. If block G were on some block then the way to end up holding(G) would be to unstack it from some block, but which one? One way would be to instantiate an instance of unstack for each possible block in the problem. One can see that this will soon lead to an explosion in the search tree. The preferred method is to keep it as a variable, and instantiate it later. Some action to achieve clear(A) would be needed if block A were not already clear. And again, the algorithm does not know what should be unstacked from A to achieve clear(A). Furthermore, in the action unstack(?X, A) required for clear(A), the variable ?X can be bound only to G. This is because unstack(?X,