a basic function required in many match algorithms is to determine if a substring S consisting of fit characters occurs somewhere in a string S 1 of pm characters, In n. A direct approach to this problem is to compare the two strings character-by-character. starting with the first characters of both S1 and S. If any two characters disagree. the process is repeated, starting with the second character of S1 and matching again against S character-by-character until a match is found or disagreement occurs again. This process continues until a match occurs or Si has no more characters. Let i and j be position indices for string S1 and k a position index for S. We can perform the substring match with the following algorithm. Sec. 10.4 Matching Like Patterns 199 i:=O while i(n-m+1) do begin i:=i+1; j =i; k:-1; while S,(jl=S211k) do begin it km writeln(success') also do begin :j+1;.k:=k4-1 end end end writeln('fail') end. This algorithm requires m(n - rn) comparisons in the worst case. A more efficient algorithm will not repeat the same comparisons over and over again. One such algorithm uses two indices, i and j, where i indexes (counts) the character positions in S1 and is set to a "match state" value ranging from 0 tom (like the states in a finite automaton). The state 0 corresponds to no matched characters between the strings, while the state I corresponds to the first letter in S, matching character i in S2. State 2 corresponds to the first two consecutive letters in S2 matching letters i and i + I in S1 respectively, and so on, with state m corresponding to a successful match. Whenever consecutive letters fail to match, the state index is reduced accordingly. We leave the actual details as an exercise. Matching Graphs Two graphs O and G match if they have the same labeled nodes and same labeled arcs and all node-to-node arcs are the same. More generally, we wish to determine if C2 with m nodes is a subgraph of G with n nodes, where n m. In a worst case match, this wil