valent. But in some problems, backward reasoning can lead to breaking up the problem into smaller parts that can be tackled independently, leading to smaller search spaces. Consider, for example, the task of designing a treat for your friend. The moves could be choosing from different activities, and the goal could be an evening plan acceptable to your friend. Let us say that the evening plan constitutes three phases. You start with some activity, followed by a movie and dinner. Let the options be, Evening Visit Mall Visit Beach Movie The Matrix Artificial Intelligence: Al Bhuvan Shome Seven Samurai Dinner Pizza Hut Saravana Bhavan where the above productions represent the choices for each phase. Let us say that the forward search program traverses the tree shown in Figure 6.1 before terminating. Your friend is happy with a walk on the beach followed by the movie The Matrix , and dinner at Saravana Bhavan, as shown by the leaf node in grey in the figure. One can inspect the tree in some order, but observe that it is fruitless to search in the left subtree, which has Visit Mall as the activity. But a depth first search will end up doing exactly that, spending time searching the entire subtree below Visit Mall, before moving to the right half of the search tree. When it fails in one subtree below, it backtracks to the Jast choice made and tries the next subtree. That is, it does chronological backtracking. One problem with chronological backtracking that DFS does is that it simply goes back to the last choice point and tries the next option. If after trying the first combination (Visit Mall, The Matrix, Pizza Hut), the algorithm somehow knew that the culprit for failure was the Visit-Mall choice, it would backtrack directly to trying the next option at that level. We will visit this strategy, known as dependency-directed backtracking in Chapter 9. Meanwhile, let us focus on problem decomposition with backward reasoning. The DFS search formulation above is a bottom-up 