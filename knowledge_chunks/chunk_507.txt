 12, a recursive call is made to ExtractPlan. f the recursive call finds a subplan, it is appended to the actions that generated the subgoal set and returned as a plan. If the subplan was nix then while loop looks at the next subgoal set. If all goal sets are exhausted, the (calling) goal set is memoized and Extractplan returns nix (steps 15, 16). ExtractPlan (G, i, PlanGraph) 1 setoOfSubgoalSets RegressGoalSet(G, i, PlanGraph) 2 setOfSubgoalSets FilterMemoized(setOfSubgoalSets, i-1, mem) 3 if empty(setOfsubgoalSets) 4 then mem Memoize(G, i, mem) 5 return nix while not empty(setOfSubgoalsets) 7 sGoal First (setOfSubgoalSets) 8 setOfSubgoalSets Rest (setOfSubgoalSets) 9 actions First(sGoal) 10 subGoals Second(sGoal) 11 if i 1 then return actions 12 subPlan ExtractPlan(subGoals, i-1, PlanGraph) 13 if subPlan nix 14 then return append(subPlan, actions) 1S mem Memoize(G, i, mem) 1 return nix FilterMemoized (setOfSubgoalSets, i, mem) for each subGoalSet setOfSubgoalSets subGoals Second(subgoalSet) iff Memoized(subGoals, i, mem) then remove subGoalSet from setOfSubgoalSets return setOfSubgoalSets Oewwe FIGURE 10.10 The procedure ExtractPlan does a backward depth first search from a given layer. We assume the function RegressGoalSets that regresses to the previous layer. If a call to ExtractPlan succeeds, it returns a plan. Otherwise it returns nix and also marks the goal set it was called with as failed in that layer. We also assume functions Memoize which adds to the memory of failed goalsets mem, and Memoized that checks whether a goalset exists in it. The algorithm Graphplan is guaranteed to find a plan that is shortest in the number of stages in the plan, where a stage consists of one or more independent actions. It has been argued that the planning graph is polynomial in size, in terms of the number of objects, the number of operators with a fixed number of preconditions, the number of add effects and the layer number. And the planning graph can be constructed in pol