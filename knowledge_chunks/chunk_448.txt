P is i-consistent, it does not mean that it is ( 1)-consistent as well. 9.4.2 i-consistency The algorithms for path consistency give us a clue of how to write algorithms for higher order consistency. The notion of consistency for a constraint network is that any consistent compound label for i 1 variables can be extended by one more variable. The network is said to be strongly i-consistent if it is also j-consistent for all j i. We can write a generalized consistency implementation algorithm by writing a generalized Revise-I algorithm as shown in Figure 9.20. For each variable z in the domain, the generalized i-consistency algorithm IC-1 looks at all subsets of variables of size i 1 to test if al! consistent instantiations of size i 1 can be extended by a value from the domain Dz. Ic-1 (X, D, C) 1 repeat 2 for each z x 3 for each S , Xg, ., Xin C X 8.t. each x, Z 4 Ry Revise-I (S x,, Xo, Xz , 2) S until no relation is changed return (X, D, C) Revise-I (S X,, 4g, mm, Xz-yhe z) for each (a,, 22, .., ;-,)ER, delete true for each ce D,; if (a), 2, .., j-., ) is consistent then delete false if delete true then remove (a), 42, ..., ;-.) From Rs 8 return R, NYHU BP WDY FIGURE 9.20 The algorithm Revise- takes as input a set of (i 1) variables and a distinct variable x; and identifies those labels that cannot be consistently extended. The generalized - consistency algorithm described here applies a brute force method to trim all sets S of variables of size (i 1) that cannot be extended with values from ai variables not in S. Note that the relation Rs may be a universal relation to start with when it is not mentioned explicitly. It is clear that we have moved beyond binary relations and have started inspecting larger compound labels for consistency. In fact even when we are looking at node consistency and arc consistency, we may have to look at relations of larger arity if we are to implement 1consistency and 2-consistency respectively. Let us look at an example to see why th