and states could be organized into a RETE network for efficient matching. We also discussed matching frames and scripts in Section 4.3.5. Something similar is required for CBR, since the number of cases can be very large. The data structure for the case itself is also important. A case is usually stored as a monolithic structure, although in some variations, cases can be stored piecemeal. The former strategy is efficient when it is possible to obtain almost-perfect matches; the latter strategy is better in complex problem-solving domains. The result of the retrieval process is usually a set of cases. The next step is to take the best case and adapt it to the current situation. One method for choosing the best case is the use of preference heuristics [Kolodner, 1989]. Here are some examples: Goal-Directed preference Prefer cases that involve the same goal as the current situation. Salient-Feature Preference Prefer cases that match the most important features, or those that match the largest number of important features. Specificity Preference Prefer cases that match features exactly over those that match features generally. Frequence Preference Prefer frequently matched cases. Recency Preference Prefer recently matched cases. Ease-of-Adaptation Preference Prefer cases with features that are easily adapted to new situations. Since even the best case will not match the current situation exactly, it will have to be adapted. At the simplest level, this involves mapping new objects onto od ones (e.g., Steak onto Hair, and Rare onto Short). When old cases represent entire problem-solving episodes, adaptation can be quite complex. CHEF [Hammond, 1986] is an example of a case-based planner, a program whose cases are actually complete plans for solving problems in the domain of cooking. CHEF s case library is augmented with a plan-modification library indexed by plan types and change types. CHEF first looks at the retrieved plan and sees if it satisfies the current goals. If 