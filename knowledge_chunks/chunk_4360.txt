ain knowledge, we find that moving the pieces to a different part of the board is still bad for Black. We can also determine that other pieces besides knights and queens can participate in fork attacks. In reality, current EBL methods run into difficulties in domains as complex as chess, so we will not pursue this example further. Instead, let s look at a simpler case. Consider the problem of learning the concept Cup [Mitchell et a/., 1986]. Unlike the arch-learning program of Section 17.5.1, we want to be able to generalize from a single example of a cup. Suppose the example is: Training Example: owner(Object23, Ralph) \ has-part(Object23, Concavity12) \ is(Object23, Light) \ color(Object23, Brown) / ... Clearly, some of the features of Object23 are more relevant to its being a cup than others. So far in this chapter, we have seen several methods for isolating relevant features. These methods all require many positive and negative examples. In EBL we instead rely on domain knowledge, such as: e Domain Knowledge: is(x, Light) A has-part(x, y) \ isa(y. Handle) liftable(x) has-part(x, y) \ isa(y, Bottom) A is(y, Flat) > stable(x) has-part(x, y) A isa(y, Concavity) \ is(y, Upward-Pointing) > open-vessel(x) We also need a goal concept to operationalize: * Goal Concept: Cup x is a Cup if x is liftable, stable, and open-vessel. Operationality Criterion: Concept definition must be expressed in purely structural terms (e.g., Light, Flat, etc.). Given a training example and a functional description, we want to build a general structural description of a cup. The first step is to explain why Object23 is a cup. We do this by constructing a proof, as shown in Fig. 17.15. Standard theorem-proving techniques can be used to find such a proof. Notice that the proof Cup(Object23) I ] liftable(Object23) | open-vessel(Object23) Stable(Object23) is(Object23, Light) has-part(Object23, Concavity2) has-part(Object23, Handle 16) isa(Concavity12, Concavity) isa(Handie16, handie) isa(Concavi