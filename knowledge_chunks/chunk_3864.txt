it. We can state this procedure more precisely as follows: Algorithm: Constraint Satisfaction I. Propagate available constraints. To do this, first set OPEN to the set of all objects that must have values assigned to them in a complete solution. Then do until an inconsistency is detected or until OPEN is empty: (a) Select an object OB from OPEN. Strengthen as much as possible the set of constraints that apply to OB. (b) If this set is different trom the set that was assigned the last time OB was examined or if this is the first time OB has been examined, then add to OPEN all objects that share any constraints with OB. (c) Remove OB from OPEN. 2. If the union of the constraints discovered above defines a solution, then quit and report the solution. 3. If the union of the constraints discovered above defines a contradiction, then return failure. 4. If neither of the above occurs, then it is necessary to make a guess at something in order to proceed. To do this, loop until a solution is found or all possible solutions have been eliminated: (a) Select an object whose value is not yet determined and select a way of strengthening the constraints on that object. (b) Recursively invoke constraint satisfaction with the current set of constraints augmented by the strengthening constraint just selected. This algorithm has been stated as generally as possible. To apply it in a particular problem domain requires the use of two kinds of rules: rules that define the way constraints may validly be propagated and rules that suggest guesses when guesses are necessary. It is worth noting, though, that in some problem domains guessing 70 : Artificial Intelligence Saa S may not be required. For example, the Waltz algorithm for propagating line labels in a picture, which is described in Chapter 14, is a version\of this constraint satisfaction algorithm with the guessing step eliminated. In general, the more powerful the rules for propagating constraints, the less need there is for guessi