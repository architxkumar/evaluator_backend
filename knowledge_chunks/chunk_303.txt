that pushes the set onto the stack, first the conjunct of predicates, and then each one individually. Let us assume that the trace shows us the object being pushed or popped, the plan whenever it is augmented, and the state after the most recent action is popped. The trace of the algorithm will then look like the following: S onTabie(A), onTable(B), onTable(C), clear(A), clear(B), clear(C), armempty Plan ( ) push on(A, 8B) a on(B, C) push -0n(A, 8B) choice: tackle on(B, C) first and then on(A, B) push 0n(B, C) pop on(B, C) push -stack(B, C) an action to achieve on(B, C) push clear(C) a holding(B) preconditions of stack(B, C) push holding (B) push clear(C) pop clear (C) true in the given (start) state pop holding (B) push pickup (8) this is a choice point push onTable(B) a armempty a clear (8) push armempty push onTable (3) push clear (8B) pop clear (3B) pop onTable(B) pop armempty pop onTable(8) a armempty a clear (B) pop pickup (B) S onTable(A), onTable(C), clear(A), clear(B), clear(C), holding(B) Plan (pickup (B)) pop clear(C) a holding(B) pop stack(B, C) S onTable(A), onTable(C), clear(A), clear(B), on(B, C), armempty Plan (pickup(B), stack(B, C)) pop on(A, 8)) push stack(A, 3) push clear(B) a holding(A) push holding (A) push clear (8B) pop clear (B) pop holding (A) push pickup (A) this is a choice point push onTable(A) a armempty a clear (A) push armempty push clear(A) push onTable(A) pop cnTable (A) pop clear (A) pop armempty pop cnTable(A) a armempty a clear (A) pop pickup (A) S enTable(C), clear(A , clear(8), on(B, C), holding(A) Plan (pickup(B), stacx(B, C), pickup (A)) pop clear(B) a holding (A) pop stacx(A, 8) S enTable(C), clear(A), on(B, CC), on(4, 38), armempty Plan (pickup(B), stacx(B, C), pickup(A), stack(A, B)) pop con(A, B) a cn(B, C) Stacxempty Return Plan (pickup (B), stack(B, C), pickup(A), stacx(A, 8)) The reader would have noticed that the algorithm has made some choices in the above execution. Choice points occur when there is more than one wa