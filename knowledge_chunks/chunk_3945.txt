ompeian(x,) \/ died{x2,79) erupted voicano,79) -morta(x,) \V ~bom(xg, tf) \V 7h t, 150) \/ deaatxg, tp) now = 2008 nalive(x,, 3) \/ 7deaa{x,, ts) deackx, t,) \/ alivelx, &) 10. died xg ts) \V Gti, te) \V deadl xe, f5) Prove: -alive( Marcus, now) DNR ROMS 2o sf. alive (Marcus, now) 9a Marcus |x4, now/ts ~dead (Marcus, now) 40 NL arcu fx. now /ts dead (Marcus, ts) \/ gt (now, ts) 5 ee 79fts =Pompeian (Marcus) \/ sgt (now, 79) NN ubsttute equals Pompeian (Marcus) \/ ~g(2008, 79) NL rece Pompeian (Marcus) 2 ee Fig. 5.12 Using Resolution with Equality and Reduce Using Predicate Logic 121 Recail that the final step of the process of converting a set of formulas to clause form was to standardize apart the variables that appear in the final clauses. Now that we have discussed the resolution procedure, we can see clearly why this step is so important. Figure 5.11 shows an example of the difficulty that may arise if standardization is not done. Because the variable y occurs in both clause f and clause 2, the substitution at the second resolution step produces a clause that is too restricted and so does not lead to the contradiction that is present in the database. If, instead, the clause afather(Chris, y) had been produced, the contradiction with clause 4 would have emerged. This would have happened if clause 2 had been rewritten as amother(a, b) \/ woman(a) In its pure form, resolution requires all the knowledge it uses to be represented in the form of clauses. But as we pointed out in Section 5.3, it is often more efficient to represent certain kinds of information in the form of computable functions, computable predicates, and equality relationships. It is not hard to augment resolution to handle this sort of knowledge. Figure 5.12 shows, a resolution proof of the statement nalive(Marcus,now) based on the statements given in Section 5.3. We have added two ways of generating new clauses, in addition to the resolution rule: Substitution of one value for another to which it i