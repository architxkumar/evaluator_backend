 construct arguments both in favor of P and opposed to it. Then some additional knowledge is applied to the arguments to determine which side has the stronger case. Let s look at backward reasoning first. We will begin witb the simple case of backward reasoning in which we attempt to prove (and possibly to find bindings for) an expression P Suppose that we bave a knowledge base that consists of the backward rules shown in Fig. 7.2. Suspect(x} <- Beneficiarx) UNLESS Alibi{x} Alibixy Somewhere EIse(x) Somewhere Else{x) Registered Hotel{x, y) and Far Awayly) UNLESS Forged Registery) Alibix) Defends(x, y) UNLESS Lies(y) Somewhere Else(x) Picture OKx, y) and Far Awayly) Contradiction() TRUE UNLESS 4x: Suspect(x) Beneficiary (Abbott Beneficiary Babbitt) Beneficiary Cabot) Fig. 7.2 Backward Rules Using UNLESS Assume that the problem solver that is using this knowledge base uses the usual PROLOG-style control structure in which rules are matched top to bottom, left to right. Then if we ask the question? Suspect{x), the program will first try Abbott, who is a fine suspect given what we know now, so it will return Abbott as its answer. If we had also included the facts Registered Hotel(Abbott, Albany) Far Away(Albany) then, the program would have failed to conclude that Abbott was a suspect and it would instead have located Babbitt. As an alternative to this approach, consider the idea of a debate. In debating systems, an attempt is made to find multiple answers. In the ABC Murder story case, for example, all three possible suspects would be considered. Then some attempt to choose among the arguments would be made. In this case, for example, we might want to have a choice rule that says that it is more likely that people will lie to defend themselves than to defend others. We might have a second rule that says that we prefer to believe hotel registers rather than people. Using these two rules, a problem solver would conclude that the most likely suspect is Cabot. Backward rul