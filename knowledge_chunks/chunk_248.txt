es. It will refine one of them, and then propagate the new values back up again. In the process if the subproblems of a given node are SOLVED nodes then it may also propagate SOLVED label back. The algorithm will terminate when the SOLVED label is backed up right up to the root. Thus, the algorithm for solving the goal tree, known as the AO algorithm (Martelli and Montanari, 1978; Nilsson, 1980), has the following cycle: Starting at the root, traverse the graph along marked paths till the algorithm reaches a set of unsolved nodes U. Pick a node rn from U and refine it. Propagate the revised estimate of n up via all ancestors. If for a node all AND successors along the marked path are marked SOLVED, mark it SOLVED as well. If a node has OR edges emanating from it, and the cheapest successor is marked SOLVED then mark the node SOLVED. Terminate when the root node is marked SOLVED. The detailed algorithm given in Figure 6.9 below has been adopted from (Rich and Knight, 1991). 6.3.1 An Example Trace of AO Let us look at a complete example depicting the progress of the AO algorithm on a synthetic problem. We begin with a version of a problem where the heuristic function is not a lower bound on the actual cost of solving each node. In the following example (Figure 6.10), assume that the SOLVED nodes all have an associated cost zero. The labels on the nodes are heuristic values. Let the cost of every arc in the graph be one. This means that the cost of solving a node is dependent only on the number of arcs leading from it to SOLVED nodes. A cursory glance at the figure reveals that the heuristic function shown in the figure is quite wild. It definitely overestimates the cost of solving nodes specially the ones closer to SOLVED nodes. Figures (6.11 continued in 6.12) show the progress of the AO algorithm. At each stage, the algorithm goes down the marked path and expands the node shown in bold. The backed-up values in the nodes are the best known cost estimates for that nod