st order logic. Unlike in classical logic, however, predicates in planning such as on(C, D) can be true at one time instance, and false at another. Such predicates are also known as fluents. It was natural that the first approaches to planning too borrowed from logic, and viewed planning as an exercise in theorem proving (Green, 1970). Classical reasoning with first order logic does not allow for assertions to be withdrawn. Once an assertion is true, it remains true. There is no notion of time and change. For example, the Pythagoras theorem is true, independently of time. This is fine in the world of mathematics. In a world where an agent is trying to bring about change, one has to have a mechanism for representing situations. For example, in the start state in the illustration above on(C, D) is true. If pick up (or unstack) C and place it on J then on(C, J) will become true. What shall one do with the assertion on(C, D), now that it is no longer true? One way to handle the problem is to introduce time as a parameter, and have every predicate time stamped. Then on(C, D, to) would mean that block C is on block A at time fo. Then one can have another fact on(C, J, t2) that states that C is on J at time ty. At time t,, the arm is holding J, represented by holding(J, t,). One would also have to describe goals using variables for time. In Figure 7.2 for example, one would have to describe the goal as there is some time at which on(G, A, t) and on(B, J, t) are simultaneously true. However, this creates an enormous book-keeping problem of carrying forward facts as time moves on. For example, ontable(B) and all other unchanging facts will need to be asserted afresh as being true at each time step. How do we know that if a fact like ontable(B, t,) is true then ontable(B, to) will be true as well? This is the well known Frame Problem introduced by John McCarthy (McCarthy, 1969) . This problem can be solved by adding the so called frame axioms , which explicitly specify that a