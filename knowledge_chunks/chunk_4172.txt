tes and instead simply update a single database of predicates so that it always describes the current state of the world. For example, if we start with the situation shown in Fig. 13.1, we would describe it as ON(A, B) A ONTABLE(B) \ CLEAR(A) After applying the operator UNSTACK(A, B), our description of the world would be ONTABLE(B) A CLEAR(A) A CLEAR(B) A HOLDING(A) This is derived using the ADD and DELETE lists specified as part of the UNSTACK operator. Simply updating a single state description works well as a way of keeping track of the effects of a given sequence of operators. But what happens during the process of searching for the correct operator sequence? If one incorrect sequence is explored, it must be possible to return to the original state so that a different one can be tried. But this is possible even if the global database describes the problem state at the current node of the search graph. Ali we need to do is record at each node the changes that were made to the global database as we passed through the node. Then, if we backtrack through that node, we can undo the changes. But the changes are described exactly in the ADD and DELETE lists of the operators that have been applied to move from one node to another. So PUTDOWN(A) we need only record, along each arc of the search graph, the operator 3 | Global database at this point that was applied. Figure 13.3 shows a small example of such a search = QNTABLE(B) A tree and the corresponding global database. The initial state is the one CLEAR(A) A shown in Fig. 13.1 and described in STRIPS form above. Notice that CLEAR(B) we must specify not just the operator (e.g., UNSTACK) but also its ONTABLE(A) arguments in order to be able to undo the changes later. Fig. 13.3 A Simple Search Tree Now suppose that we want to explore a path different from the one we have just shown. First we backtrack through node 3 by adding each of the predicates in PUTDOWN s DELETE list to the global database and deleting each of th