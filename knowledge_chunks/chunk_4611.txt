 ESRF c S ERNE 2 * BR BRDL Fig. 25.3 The Static Control Now add an Edit control in a similar manner below the static control. Double click and the same kind of window that appeared before will pop up. Change the ID to 2 and the remove the Caption and click OK. Finally add a button control to the dialog beneath the edit control, change the ID and Caption to 3 and OK respectively in a similar manner. The output is shown in Fig. 25.4. You may now see how the dialog would look like during run time by clicking on the Test button on the Tool box. Resizing and moving of these controls can be easily done using the mouse. Generating the code for this is simple. Just click on Export and you will see the code in Dialog Code (sometimes referred to as IE) window. Cut and paste this code into a new file within the WIN-PROLOG environment. You will note that a clause for the predicate new_dialog has been generated. This dialog can be used only after it has been invoked by a call to this clause viz. | ?- new_dialog. The dialog is now ready for use by a program. You will of course have to display the window using the predicate wshow/2 with the window name and number as its arguments. The dialog will also require a handle for which the predicate window_handler/2 with arguments viz. the dialog name and the handle name, is to be invoked. Inspect the code below to see how things work. More importantly look at what the event handlers do by correlating the use of the dialog (typing, moving the cursor, etc.) with the handler code. Most of this part is based on Windows programming. Compile and issue the goal start_dialog. Use the dialog and interpret the handlers. One typical handler clause is described below. Based on this, the others can be easily comprehended. 526 Artificial Intelligence fe Impadt xpert] Fig. 25.4 The Final Dialog start_dialog:~ new_dialog, wshow(new_dialog,t), window_handler(new_dialog, new_dialog_handler). new_dialog_handler((new_dialog,2),Win Msg, Data,Result):- Win Ms