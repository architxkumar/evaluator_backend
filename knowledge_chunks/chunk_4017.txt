t explicitly depended on it, leaving everything else that has happened in the meantime intact. This is exactly what dependency-directed backtracking does. Symbolic Reasoning Under Uncertainty 161 39 RO, SAMA VENT ORATOR EE SDE SERN, As an example, suppose we want to build a program that generates a solution to a fairly simple problem, such as-finding a time at which three busy people can all attend a meeting. One way to solve such a problem is first to make an assumption that the meeting will be held on some particular day, say Wednesday, add to the database an assertion to that effect, suitably tagged as an assumption, and then proceed to find a time, checking along the way for any inconsistencies in people s schedules. Jf a conflict arises, the statement representing the assumption must be discarded and replaced by another, hopefully noncontradictory, one. But, of course, any statements that have been generated along the way that depend on the now-discarded assumption must also be discarded. Of course, this kind of situation can be handled by a straightforward tree search with chronological backtracking. All assumptions, as well as the inferences drawn from them, are recorded at the search node that created them. When anode is TY day = Wednesday Try day = Tuesday determined to represent a contradiction, sim After many steps, Repeat same time-finding ply backtrack to the next node from which there conclude that ire process an again decide : 7 only time ail people on 2 p.m. for all of the remain unexplored paths. The assumptions and are available is 2 p.m. same reasons. their inferences will disappear automatically. The drawback to this approach is illustrated in try to find a room | Try to find a room Fig. 7.4, which shows part of the search tree of | a program that is trying to schedule a meeting. FAIL SUCCEED To do so, the program must solve a constraint (A special conference has all the rooms . : 1 . nd ti satisfaction problem to find a day and time at booked on