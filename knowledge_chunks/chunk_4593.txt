Tail, [1,2,3,4]). Though (c) and (d) can be achieved using other techniques they have been stated here to emphasize the functionality of the same predicate. Member of a list member(X,{X\_]). member(X,{_|Tail]):-member(X, Tail). The clauses for member accept the member to be verified as the first argument and the list as the second argument. The first clause states X is member of the list if X is the Head of that list. The second clause states else check to see if X is the member of the tail of the list. The member predicate in some PROLOG versions may be built into the compiler. Yet understanding the way it is written is important. The member predicate can also be used to extract the individual members of a given list as in the goal member(X,[2,3,4,5]). Append a list to another The clauses for append are given below. append({].L,L). append({X1L1 ], L2,{X\L3]):- append(L1,L.2,L3). The first argument, which is a list, is appended to the second, also a list, to give the third which is the appended version. _* . PROLOG - The Natural Language of Artificial Intelligence S11 RNa RCNIRTELEARSTAN ICAU AMER ITRAA ic The first clause states that If the list to be appended is an empty list then output the other list as the appended one. The second clause may seem to confuse us initially! It takes the Head of the list X to be appended and adds it to the Head of the output (appended) list, ({XIL3/), and calls append recursively with the Tail of the list to be appended, the list to which it is to be appended and L3 as its arguments. Note that 3, the tail of the output list, gets values only while the unwinding of the recursive loop occurs. Inspect the trace below to comprehend the working of append. append ({1,2],{4,5,6],0). Li = [2] = [4,5,6] L3 is free 2={] L2 = [4,5,6} L3 is free NY L = [4,5,6] The first clause succeeds here binding L_ for the last recursive call thus triggering the unwinding. Vv X=2 Li={} 12 = [45,6] L3 = [4,5,6] L3 is bound { X=] L1 = [2] L2 = [4,56] L3 = [2.