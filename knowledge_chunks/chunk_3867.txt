s. : The constraint propagator now observes that: N=3,since N=E+1. e R=8or9, since R +N (3) + Cl (1 or 0) =2 or 12. But since N is already 3, the sum of these nonnegative numbers cannot be less than 3. Thus R+ 3 + (Oor 1) = 12 and R=8or9. 2+D=Yor2+D=10+ Y, from the sum in the rightmost column. Again, assuming no further constraints can be _nitial State SEND generated, a guess is required, Suppose C1 is chosen to +MORE guess a value for. If we try the value 1, then we eventually MONEY teach dead ends, as shown in the Fig.. When this M=1 happens, the process will backtrack and try Cl = 0. 52bor8 sor0 A couple of observations are worth making on this N=Eor Et192N=E+1 process. Notice that all that is required of the constraint C2=1 propagation rules is that they do not infer spurious w R? constraints. They do not have to infer all legal ones. For example, we could have reasoned through to the result E=2 that C] equals 0. We could have done so by observing that for Cl to be 1, the following must hold: 2+ D = 10 N=3 + Y. For this to be the case, D would have to be 8 or 9. Re a 2+D = 10+Y But both S and R must be either 8 or 9 and three letters cannot share two values. So Cl cannot be 1. If we had c1=0 C1=1 realized this initially, some search could have been avoided. But since the constraint propagation rules we | 2+D=Y 2+D = 10+ N+R = 10+E D=8+y Y used were not that sophisticated, it took some search. R-9 Whether the search route takes more or less actual time | 5-8 than does the constraint propagation route depends on how long it takes to perform the reasoning required for constraint propagation. A second thing to notice is that there are often two kinds of constraints. The first kind is simple; they just list possible values for a single object. The second kind is more complex; they describe relationships between or among objects. Both kinds of constraints play the same role in the constraint satisfaction process, and in the cryptarithmetic example they were treated id