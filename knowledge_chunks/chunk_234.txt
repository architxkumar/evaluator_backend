ned away most layers from the beam. Instead of backtracking chronologically, the algorithm instead exploits the beam stack that maintains fipin and fax Values for all layers. It simply regenerates the layer it is required to backtrack to using the finin and finax values to guide the (forward) regeneration process. One has to be careful though that one begins with a finite value of the upper bound U. Otherwise, it is possible that the algorithm may go into a loop, exploring the same nodes again and again on an undirected graph (see Exercise 5.11). This happens because the algorithm is not maintaining a complete boundary layer that would prevent search from leaking back to nodes seen earlier. However, selecting an appropriate U value will check this looping. The g-value of a node in the loop increases with each repetition. Once the fvalue becomes greater than U, then search will break out of the loop. Observe that the solution reconstruction with divide and conquer process will also require memory. One can opt to reconstruct the solution when backtracking is to be done. That is, the solution reconstruction is delayed till an opportune moment. In the meantime, the algorithm can simply keep track of the best solution found (remember it continues to look for better solutions) and use its cost to update the upper bound to a tighter value. Divide and Conquer Beam Stack Search is thus a complete and admissible search that has almost constant space requirement. The algorithm can explore deep search spaces without running into space problems. The larger the beam width w, the less likely is the need for backtracking, and one can thus choose a larger beam width w. 5.12 Discussion In this chapter, we have explored algorithms for finding optimal cost solutions when the moves have an associated cost. Starting with the uninformed and conservative Branch Bound algorithm (or Dijkstra s Algorithm), we added a heuristic function to exert a pull towards the goal on the search frontier. 