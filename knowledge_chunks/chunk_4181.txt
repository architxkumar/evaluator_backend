tituted for x, it is important that the same one be matched to each of the x s. Thus it is important that each time a variable is introduced into the goal stack, it be given a name distinct from any other variables already in the stack. And whenever a candidate object is chosen to match a variable, the binding must be recorded so that other occurrences of the same variable will be bound to the same object. How should our program choose now between alternative land alternative 2? We can tell that picking up C (alternative 1) is better than unstacking it because it is not currently on anything. So to unstack it, we would first have to stack it. Although this could be done, it would be a waste of effort. But how could a program know that? Suppose we decided to pursue alternative 2 first. To satisfy ON(C, x), we would have to STACK C onto some block x. The goal stack would then be CLEAR(x) HOLDING(C) CLEAR(x) A HOLDING(C) STACK(C, x) CLEAR(C) ARMEMPTY ON(C, x) A CLEAR(C) \ ARMEMPTY UNSTACK(C, x) CLEAR(A) A HOLDING(C) STACK(C, A) ONG, D) ON(C, A) A ONG, D) A OTAD But now notice that one of the preconditions of STACK is HOLDING(C). This is what we were trying to achieve by applying UNSTACK, which required us to apply STACK so that the precondition ON(C, x) would be satisfied. So we are back to our original goal. In fact, we now have additional goals as well, since other predicates have also heen added to the stack. At this point, this path can be terminated as unproductive. If, however, block C had been on another block in the current state, ON(C, x} would have been satisfied immediately rith no need to do a STACK and this path would have led to a good solution. ' j j | : | | | | Planning 259 saree eneenememmeneimenmnneeenl Now we must return to alternative t, which used PICKUP to get the arm holding C. The top element on the goal stack is ONTABLE(C), which is already satisfied, so we pop it off. The next element is CLEAR(C), which is also satisfied, so we pop it off. The