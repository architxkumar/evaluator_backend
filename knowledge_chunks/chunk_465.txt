s shrunk inside the SelectValue function, implying that the domain is treated as a global variable, or the call is call-by-name. This is necessary if the algorithm has to backtrack and try another value. Assuming that the domains are represented as lists, the algorithm in Figure 9.32 simply chooses the value at the head of the list. Later, we will look at variations that apply some reasoning to filter values not likely to succeed. Backcracking (X, D, C) 1ae (()) 2i 1 3 De D, 4 while l1 icgno s do a, SelectValue(D, , A, C) if a, null 7 then i i-il 8 A Tail(A) S else 1c A Cons(a,, A) 11 2teaaiel 12 if ign 13 then DD, D, 14return Tail (Reverse (A) ) SelectValue (D,", A, C) 1 while not empty(D, ) 2 do a, Head(D, ) 3 De Tail(D, ) 4 if Consistent(A, x, a,) S) then return a, return null FIGURE 9.32 The algorithm Backtracking explores the domains in a depth first manner. However at each stage, it calls the procedure Consistent(A, aj) to check that the value being chosen is consistent with the compound label assembled so far. We also assume the list processing functions Head, Tail and Cons. Initializing A with a list containing one element, in this case the empty list, is simply to prevent a call to Tail with an empty list. The return statement is modified to leave out this element. It returns an empty list if there is no solution. If SelectValue cannot find a value, it returns null which prompts the calling procedure to backtrack to look for another value for the previous variable from the values remaining in the copy of its domain (steps 7 and 8). Observe that if an appropriate amount of (directional) consistency has been enforced before calling algorithm Backtracking there would be no backtracking. Backtracking to the previous choice point (variable) is termed chronological backtracking. A little later we look at approaches to jumping back to variables that may have been the cause of inconsistency that resulted in the backtracking. Observe that every time it moves forward