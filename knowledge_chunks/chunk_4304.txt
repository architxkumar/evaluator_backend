84] show that vast speedups in the unification of large terms are not possible. Many problems can be solved efficiently by parallel methods, but it is not always a simple matter to convert a sequential algorithm into an efficient paralle! one. Some Al algorithms whose parallel aspects have been studied are best-first search [Kumar et al., 1988], alpha-beta pruning {Hsu, 1989], constraint satisfaction [Kasif, 1986], natural language parsing [Thompson, 1989], resolution theorem proving [Cheng and Juang, 1987], and property inheritance [Fahlman, 1979]. 16.2.4 Custom Parallel Hardware Finally, we must ask how these parallel algorithms can be implemented in hardware. One approach is to code an algorithm in a programming language supported by a general-purpose parallel computer. Another approach is to build custom paralle! hardware that directly implements a single algorithm. This last approach has led to striking performance increases, as demonstrated in the SPHINX [Lee and Hon, 1988] speech recognition system, where real-time performance was achieved through the use of a beam search accelerator [Bisiani ef al., 1989], and in the DEEP THOUGHT chess machine [Hsu, 1989], which uses a parallel tree-search algorithm for searching game trees. 16.3 DISTRIBUTED REASONING SYSTEMS In all of our discussions of problem-solving systems until now, we have focused on the design of single systems. In this section, we expand our view, and look at distributed reasoning systems. We define a distributed Teasoning system to be one that is composed of a set of separate modules (often called agents since each module is usually expected to act as a problem-solving entity in its own right) and a set of communication paths between them. This definition is intentionally very vague. It admits systems everywhere along a spectrum that ranges from tightly coupled systems in which there is a completely centralized control mechanism and a shared knowledge base to ones in which both control and knowledg