rst a little later. The algorithm Graphplan can be seen to operate in three stages. In the first stage, the initial planning graph is built and if the goal propositions have appeared then it attempts to extract a plan (lines 2-7). If the ExtractPlan procedure returns nix , the algorithm incrementally extends the graph looking for a solution till it levels off (lines 8-15). When it does level off, it marks that level in the variable n, and computes the size of the set of sets of subgoals (lines 12-15). At this stage, this value will be 1 because the subgoal set is the original goal set G here. Finally, in the third phase (lines 16-21), Graphplan continues extending the planning graph looking for a plan. This happens till the termination condition is reached in line 21 where it reports failure. If at any time in phases 2 and 3 ExtractPlan returns a plan, the algorithm skips both these phases and terminates with the plan. The plan that algorithm Graphplan returns has the following structure, T (fa44, ) At ph 421, ---) Aaghs (834, 41 ABp s 1 Amts ) Amsh) That is, it contains m ordered sets of actions. The first set (a4, ..., 4p contains actions that can be executed in parallel in stage one, the second set a91, ..., gq in stage two, and so on. If one desired a linear plan then the set for each stage can be linearized in any order. 10.1.4 Extracting the Plan When the planning graph reaches a level that contains all the goal propositions G in the newest layer with no mutex relations amongst them, it is time to check whether a plan can be extracted from the planning graph. At this stage, we have the goal propositions and the start propositions nonmutex. It remains to be checked whether there exists a plan m ( a44, ..., Ap , a21, --5 aq , 34, ---1 A3rh, s Amt Amsh)s such that the set of actions at every layer a,4, ..., xz are applicable and non mutex, and that the goal propositions have support from the last set of actions, including the No-op actions. Graphplan (start S, go