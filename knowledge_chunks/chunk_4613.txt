dow - Message - Data - Result),nl,ttyflush, window_handler(Window,Message.Data,Result). new_dialog_handler((new_dialog,2), Win Msg, Data,Result):- Win Msg = msg_mousemove, 1 wtext((new_dialog.!), You are doing well - continue! ), window_handler(new_dialog,Message,Data,Result). The handler takes in the first argument (control_handler,JD), and returns the message from the window (Win Msg) and the data and result pertaining to the dialog/window. Based on the message or event returned, which in the present case is a movement of the mouse, the next part of the code is executed. wte.xt/2 facilitates treading or writing of text onto or from a control. Jt has two arguments the controi handle and its ID and the 528 Artificial Intelligence text to be written or read from the control. If the text is a variable, it reads the text on the control; else it places the text on it. The window_handler/4 is called again to effect a cyclic process and to maintain the event driven actions. Its first argument is the dialog handle and the second the message. The third and fourth pertain to the data and the result respectively. Both these provide information specific to the window. Note the outputs reflected on the console due to the last clause of the dialog handler. Observe the mouse movement and events and the actual messages (Win Msg) received by the program. You could use these for enhancing the event handling process. SUMMARY This chapter introduced the concept of programming in PROLOG. Most of the key issues in PROLOG programming have been covered to facilitate the reader to kick-start the process of writing code for AI programs. In this chapter we have revisited the concept of an agent and discussed ways to implement real agents using LPA s Chimera Agent system. The creation and use of dialogs in the WIN-PROLOG system have also been discussed. EXERCISES 1. A family tree is always something many of us would want to maintain. Try using PROLOG to code a family tree wherein you could qu