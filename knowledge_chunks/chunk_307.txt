ts to a wrong set of actions then it would need to be able to go back to the choice point and choose another action. Thus for completeness, backtracking in the backward phase would be necessary. We can think of the GSP algorithm as doing depth first search on an ANDIOR goal tree. Pushing into the stack is like generating the tree. A goal predicate is solved if it occurs in the current state. An action node (AND node) is solved if all its children (preconditions of the action) are solved. An OR node represents a choice of actions for achieving a goal predicate. We will revisit this algorithm in the chapter on reasoning with logic, as backward chaining, the foundation of the programming language Prolog (see Chapter 12). The theorem proving algorithm searches for supporting statements in the backward direction, but commits to inferences in the forward direction. A recursive version (Figure 7.11) of the GSP algorithm adapted from (Ghallab et al., 2004) illustrates the dual nature of GSP search, and its relation to an ANDIOR tree. It uses a function PlanProgress(P, S), shown in Figure 7.12, that progresses a given state S over a plan P by successively progressing over its actions. 7.5 Plan Space Planning The planning approaches described above reason with states. The planner is basically looking at a state and a goal. If the state satisfies the goal then it terminates. Otherwise, it makes a search move over the state space looking for actions to add to the plan. An alternative view is to consider the space of all possible plans, and search in this space for a plan. We will call such approaches as plan space planning. Most algorithms in this category represent a plan as actions arranged in a partial order, and hence we also use the term partial order planning. Unlike in the state space methods described above, there is no restriction on the order in which actions are added to the plan. Since state space methods focus on the state, or on the goal which is a partial state d