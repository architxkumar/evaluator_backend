e set of actions at every layer a,4, ..., xz are applicable and non mutex, and that the goal propositions have support from the last set of actions, including the No-op actions. Graphplan (start S, goal G, actions A) if Gc S then return ( ) PG PlanningGraph (S, G, A) PlanGraph First (PG) i Second (PG) leveled Third(PG) if leveled true then return no plan exists m ExtractPlan(G, i, PlanGraph) while m nix and not leveled ieitil PlanGraph ExtendGraph (i, A, PlanGraph) m ExtractPlan(G, i, PlanGraph) if (Pz. P; and MuP,.. MuP.) then leveled true nei S, SizeSubgoalSets(i, n, Plangraph) BPRODRIKHUBwWWH HO B nN PRE Ob Ww 1 while m nix 1? ieitil 18 PlanGraph ExtendGraph (i, A, PlanGraph) mM ExtractPlan(G, i, PlanGraph) S, SizeSubgoalSets(i, n, Plangraph) if s, ,., then return no plan exists aCe Sms Ne return 7 FIGURE 10.7 Algorithm Graphplan begins by calling procedure PlanningGraph to construct the initial planning graph. PlanningGraph returns a triple from the three components which are extracted using the (assumed) functions First, Second and Third. From here on, Graphplan calls ExtractPlan and extends the planning graph, till either the termination criterion is reached or a plan is found. The function SizeSubgoalSets can be computed by inspecting the memory of failed goal sets maintained by ExtractPlan. One way of looking at the plan existence question is to ask whether the goal propositions have support from a nonmutex set of actions. If yes then the combined preconditions of these actions can be viewed as a regressed subgoal set, which can be solved recursively. In fact, this is the approach taken by the algorithm Graphpian. It is possible that there is more than one combination of actions supporting the goal set, leading to different possible subgoal sets that the procedure must explore. Figure 10.8 shows two possible ways in which the given goal set p4, Ps, p7 can be regressed to a set of subgoals at the preceding layer. Let G, be the goal set at the kK" layer. Let G