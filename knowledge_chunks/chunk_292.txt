ion progress(A, S) that returns the successor state when action A is applied to state S. Given the progress(A, S) function, the search algorithms in Chapter 2 can easily be used. They will, however, suffer from the same drawbacks. The main one being that the search space generated will be huge, and that the search algorithm will have no sense of direction. The given state in Figure 7.2 is described by the following collection of facts: AE, ontable(B), on(A, B), clear(A), ontable(E), on(D, E), on(C, D), clear(C), ontable( ), on(H, ), on(G, H), on(F, G), clear(F), ontable(J), clear(J), ontable(O), on(N, O), on(M, N), on(L, M), on(K, L), clear(k), ontable(Q), on(P, Q), clear(P) . In the given state, one instance of the Pickup operator is applicable, generating the action Pickup(J). Several instances of the Unstack operator are generated. Each of the actions does a small change in the world, and many actions are applicable in turn in the changed world. Figure 7.4 illustrates the fact that the search space generated by FSSP is huge. Looking at the full problem, one can notice that it includes actions that have nothing to do with achieving the goal. Bile 1 fs Jolla C Unstack(C, D) a s ee Unstack(P, Q) Putdown(F) Fa A Stack(F, A) yy Stack(F, C) Stack(F, G) bf Stack(F, J) Stack(F, K) Stack(F, P) Figure 7.4 The search space generated by FSSP is huge. 7.3 Backwards State Space Planning Like the uninformed search algorithms seen earlier, FSSP is oblivious of the goal, and simply explores the set of all future states possible in some predetermined order. One way to take the goal state into account is to start searching backwards from the goal. That would make the reasoning purposeful and deliberative, focused towards the goal, or teleological. This is known as Backward State Space Planning (BSSP). Backward reasoning or goal-directed reasoning has been proposed as being fundamental to intelligent behaviour, and we have already visited it while studying goal trees in Chapter 6. I