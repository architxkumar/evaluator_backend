icted in this chapter maintain an OPEN list of candidate states. In some domains, the description of a move may need much less space than the description of a state. Show how the DFS algorithm can be modified by storing a list of move pairs in the list OPEN. Each move pair consists of a forward move and a backward move, to and fro to a successor. What is the space complexity of the resulting algorithm? How can the same technique be applied to BFS? What is the resulting complexity? . Show the order in which DFID applies goalTest to the nodes of the above graph. What is the path it finds? What is the effect of not maintaining the CLOSED list in DFID search? Discuss with an example. Will the algorithm terminate? Will it find the shortest solution? . Show that the effort expended by DFID is the same as its constituent depth first searches. Which of the following is more amenable to parallelization? DFS, BFS, or DFID? Justify your answer. Explain with reasons which search algorithms described in this chapter will be used by you for the following problems: (a) A robot finding its way in a maze. (b) Finding a winning move in a chessboard. (c) Finding all winning moves in a chessboard. (d) A sensor trying to route a packet to another sensor (Assume the network topology is known. Hint: Sensors are limited memory devices.) Justify your answers with a description of your search primitives and state definitions for each problem. 1 In an alternate version of the problem, if the missionaries outnumber the cannibals, they will convert them. 2 Incidentally, while we have assumed in both DFS and BFS that the search picks up the leftmost of siblings, this is really determined by the order in which moveGen generates them. It is merely easier and more convenient for us to visualize the two algorithms searching from the left to the right. Heuristic Search Chapter 3 " the search algorithms described in Chapter 2, the only role that the goal node plays is in testing whether the candidate 