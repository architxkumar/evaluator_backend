generates two new arcs, the ones to G and to H. Propagating their f values backward, we update f of B to 6 (since that is the best we think we can do, which we can achieve by going through G). This requires updating the cost of the AND arc B-C to 12 (6+ 4 + 2). After doing that, the are to D is again the better path from A, so we record that as the current best path and either node E or node F will be chosen for expansion at step 4. This process continues until either a solution is found or all paths have led to dead ends, indicating that there is no solution. In addition to the difference discussed above, there is a second important way in which an algorithm for searching an AND-OR graph must differ from one for searching an OR graph. This difference, too, arises from the fact that individual paths from node to node cannot be considered independently of the paths through other nodes connected to the original ones by AND arcs. In the best-first search algorithm, the desired path 66 Artificial Intelligence AFSL Ce ONS RNR ERATOR Before step 1 Before step 2 [A] 5) Al 6) OLS. B Cc] D (3) (4) (5) Before step 3 Before step 4 (4) (4) Fig. 3.8 The Operation of Problem Reduction . from one node to another was always the one with the lowest cost. But this is not always the case when searching an AND-OR graph. Consider the example shown in Fig. 3.9(a). The nodes were generated in alphabetical order. Now suppose that node J is expanded at the next step and that one of its successors is node E, producing the graph shown in Fig. 3.9(b). This new path to E is longer than the previous path to E going through C. But since the path through C will only lead to a solution if there is also a solution to D, which we know there is not, the path through J is better. Unsolvable Unsolvable Fig. 3.9 A Longer Poth May Be Better There is one important limitation of the algorithm we have just described. It fails to take into account any interaction between subgoals. A simple example of this fai