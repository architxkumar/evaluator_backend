orm the given state into the goal state via a sequence of moves, the heuristic function has to basically estimate how much of that required transformation still needs to be done for a given state. In other words, it is some kind of a match function that computes some similarity measure of the current state with the goal state. Such a heuristic function will be domain dependent, and will have to be included into the domain functions, along with the moveGen and goalTest functions described in Chapter 1. In later chapters, we will also look at the notion of domain independent heuristic functions. These functions estimate the distance to the goal by solving a relaxed version of the original problem. The relaxed problems are such that they are simpler to solve, typically being linear or polynomial in complexity. They typically give us a lower bound on the distance to the goal. Traditionally, the heuristic function is depicted by h(n), where rn is the node in question. The fact that the heuristic value is evaluated with respect to a goal state is implicit, and, therefore, the heuristic value should be seen to be for a given problem in which the goal has been specified. To incorporate heuristic values in search, the node-pair representation used will have to be augmented with the heuristic value, so that a node in the search tree will now look like, searchNode (currentState, parentState, heuristicValue) We illustrate the idea of heuristic functions with a few example problems. In a route finding application in a city, the heuristic function could be some measure of distance between the given state node and the goal state. Let us assume that the location of each node is known in terms of its coordinates. Then a heuristic estimate of distance could be the Euclidean distance of the node from the goal node. That is, it estimates how close to the goal the current state is Euclidean distance: - 2 2 A) Goat Xn) O'Goat Yn) Note that this function gives an optimistic estimate of di