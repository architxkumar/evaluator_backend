ed and rejects the value if any future domain becomes empty due to that. The algorithm SelectValue-FC in Figure 9.36 starts off by backing up copies of domains Di, i k n (steps 1-2). The domain Dj contains values for x; that have not been pruned by earlier variables. The algorithm picks one value and prunes inconsistent values from future domains (steps 6-16). At any point, if any domain becomes empty the algorithm aborts and resets domains it has pruned (steps 12-15), and tries another value (steps 3-6). If after pruning all domains they still are non-empty, the algorithm returns the selected value for x; Observe that the domains Dj, i k n that are globally visible may have been pruned in the process, and will be copied when the algorithm Backtracking-with-LookAhead will move to the next variable (steps 12-13 of Figure 9.35). SelectValue-Fc (i, A, C) 1 for ke itlton 2 do C,, Dy, 3. while not empty(D,,) 4 do a, Head(D,,) Di, Tail(D,,) notEmptyDomain true 7 keait l 8 while notEmptyDomain and k n S do for all be D, 1c if not Consistent(A, x, a,, x, b) 11 then remove b from D., 12 if Empty(D,,) 13 then notEmptyDomain false 14 for 7 itltok 15 do Dy: C,; 16 else k k l . 17 if notEmptyDomain 18 then return a, 19 return null FIGURE 9.36 The algorithm Backtracking explores the domains in a depth first manner. However at each stage, it calls the procedure Consistent(A, aj) to check that the value being chosen is consistent with the compound label assembled so far. We also assume the list processing functions Head, Tail and Cons. We look at the algorithm working on the problem in Figure 9.33. Figure 9.37 below depicts the matching diagram for the CSP. Processing the nodes in the given order GDBFEAC, algorithm Backtracking-with-LookAhead begins by calling SelectValue-FC with variable G. SelectValue-FC assigns w to G, and prunes the value w from the domains of E and F, the variables that G participates in constraints with. Next, the variable D is taken up, and the value g selec