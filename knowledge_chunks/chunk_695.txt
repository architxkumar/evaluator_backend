 V xz (LessThan(x, z)) can be replaced by? , (LessThan(1, 1) V LessThan(1, 2) V LessThan(1, 3)) A (LessThan(2, 1) V LessThan(2, 2) V LessThan(2, 3)) A (LessThan(3, 1) V LessThan(3, 2) V LessThan(3, 3)) that that the constituent formulas are not necessarily true. like Vx y LessThan(successor(x), y) D LessThan(x, y) will get replaced by (LessThan(successor(1), 1) D LessThan(1, 1)) A (LessThan(successor(1), 2) D LessThan(1, 2)) A (LessThan(successor(1), 3) LessThan(1, 3)) (LessThan(successor(2), 1) D LessThan(2, 1)) (LessThan(successor(2), 2) D LessThan(2, 2)) (LessThan(successor(2), 3) D LessThan(2, 3)) (LessThan(successor(3), 1) 2 LessThan(3, 1)) (LessThan(successor(3), 2) LessThan(3, 2)) (LessThan(successor(3), 3) D LessThan(3, 3)) 1e can see this can become cumbersome, and one has also to worry about definitions of func r(x), which is not defined for the number 3. However whenever one can convert a set of for onal logic one can rely on the fact that the proof procedures are decidable. They will terminate one w )L on the other hand allows us to talk of infinite sets, and it is in reasoning with infinite sets that the decidable lurks. The procedure may keep trying out a never ending sequence of bindings. ok at an example to illustrate the fact. Given the set of (true) formulas, over the domain of natural nui xV y LessThan(succesor(x), y) D LessThan(x, y) xVy LessThan(x, y) D LessThan(successor(x), successor(y)) xLessThan(0, successor(x)) goal LessThan(successor(successor(0)), successor(successor(successor(0)))) one can indeec 1 of the null clause, because the formula is true. This is left as an exercise. However given a goal tl example LessThan(successor(0), successor(0)) the procedure may never end, generating a seq as shown below, 1 (LessThan (successor ?x,) ?y,) V (LessThan ?x, ?y4) 1 (LessThan ?x2 ?y2) V (LessThan (successor ?x ) (Successor ?y2)) essThan 0 (successor ?x3)) 1 (LessThan (successor 0) (successor 0))) negated goal 1(LessThan 0 0)) 2,4, 2x2 0, ?y 2 0 