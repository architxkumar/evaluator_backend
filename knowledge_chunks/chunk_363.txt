ction e(J) instead of making a recursive call. A node is a terminal of a leaf node of the game, and will evaluate to one of -Large, 0, Large or it is a node on the horizon, and in that case the evaluation function e(J) will be applied. Not shown in the algorithm is the implementation of the test for terminal node. It will need incorporation of a depth parameter k, perhaps passed along with the node, decremented at each recursive call. It will become zero when the node is on the horizon. This is left as an exercise (number 5) for the reader. Minimax (j) 1 To return the minimax value V(j) of a node j 2 if Terminal (j) 3 then return V(j) . (j) 4 else for i .1 to b b is the branching factor Ss do Generate j; the i successor of j 7 V(jz) ..Minimax(j,) recursive call 8 ifi-sl 9 then CV(j) .V(j.) 10 else if j is MAX 11 then CV(j) Max(CV(j), V(3.)) 12 else CV(j) Min(cV(j), V(3,)) 13 return V(j) CV(j) FIGURE 8.17 The M NIMAX algorithm recursively calls itself till it reaches a terminal node. A terminal node is either a leaf of the game tree or a node at depth k. The algorithm does a k-ply search from left to right. Note that the recursive calls are of decreasing ply depth. One will need to keep track of depth of a node. In the above algorithm, the minimax value is returned but not the best move that leads to that value. Since the objective is to play the game, the following version returns the best move. It calls the above Minimax algorithm for each successor of the root, and keeps track of the best move as well as the best board value. BestMove (7) 1 To return the best successor b of a node j 2 b NIL 3 value -LARGE 4 for ie 1ltob s do V(j7;) Minimax (j:) if V(j,) value 7 then value V(j:) 8 be 3; 9 return b FIGURE 8.18 The algorithm BestMove accepts a board position and returns the best move for MAX. It calls algorithm Minimax with each of its successors and keeps track of which successor yields the best value. Figure 8.19 depicts the tree searched by the algorithm Minimax a