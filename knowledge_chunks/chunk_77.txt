 an exit. FIGURE 2.12 In a maze, one can only see the immediate options. Only when you choose one of them do the further options reveal themselves. Box 2.3 for a note on the limited visibility in search. The key to not getting lost endlessly in a maze is to mark the places where one has been. We can follow a similar approach by maintaining a list of seen nodes. Such a list has traditionally been called CLOSED. It contains the list of states we have tested, and should not visit again. The algorithm Simple Search 2 (SS-2) in Figure 2.13 incorporates this check. It does not add any seen nodes to OPEN again. To prune the search tree further, one could also specify that it does not add any successors that are already on OPEN as well. This would lead to a smaller search tree in which each node occurs exactly once. SimpleSearch () 1 cpen start 2 closed 3 while open is not empty 4 do Pick some node n from open Ss open cpen n closed closed u n 7 if GoalTest(n) TRUE e then return n g else cpen open U MoveGen(n) closed lGreturn FAILURE FIGURE 2.13 Algorithm SimpleSearch2. The search tree generated by one possible execution of the algorithm is shown below. The CLOSED list is depicted by shaded nodes and the OPEN list by dotted circles. SS-2 picks some node N from OPEN and adds it to CLOSED. If Nis Goal, it returns N, Else it adds unseen successors of N to OPEN Let us say SS-2 picks G from OPEN and terminates FIGURE 2.14 SS-2 visits each node only once and finds the goal. The second problem with the above program is that it returns the goal state when it finds it. This is not always problematic though. There are problems in which we are only interested in finding a state satisfying some properties. For example, the n-queens problem in which we simply need to show a placement of n queens on an n x n chessboard such that no queen attacks (as defined by rules of the game) any other queen. We can call such problems as configuration problems. The other kinds of problems, that we call