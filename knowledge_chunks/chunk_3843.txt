hosen node, applies the heuristic function to them, and adds them to the list of open nodes, after checking to see if any of them have been generated before. By doing this check, we can guarantee that each node only appears once in the graph, although many nodes may point to it as a successor. Then the next step begins. This process can be summarized as follows. Algorithm: Best-First Search 1. Start with OPEN containing just the initial state. 2. Until a goal is found or there are no nodes left on OPEN do: (a) Pick them best node on OPEN. (b) Generate its successors. (c) For each successor do: (i) If it has not been generated before, evaluate it, add it to OPEN, and record its parent. (ii) If it has been generated before, change the parent if this new path is better than the previous one. In that case, update the cost of getting to this node and to any successors that this node may already. have. The basic idea of this algorithm is simple. Unfortunately, it is rarely the case that graph traversal algorithms are simple to write correctly. And it is even rarer that it is simple to guarantee the correctness of such algorithms. In the section that follows, we describe this algorithm in more detail as an example of the design and analysis of a graph-search program. 3.3.2 The A* Algorithm The best-first search algorithm that was just presented is a simplification of an algorithm called A*, which was first presented by Hart et al. [1968; 1972]. This algorithm uses the same / , g, and A functions, as well as the lists OPEN and CLOSED, that we have already described. Algorithm: A* 1. Start with OPEN containing only the initial node. Set that node s g value to 0, its A value to whatever it is, and its f value to A + 0, or h . Set CLOSED to the empty list. 2. Until a goal node is found, repeat the following procedure: If there are no nodes on OPEN, report failure. Otherwise, pick the node on OPEN with the lowest f value. Call it BESTNODE. Remove it from OPEN, Place it on CLOSE