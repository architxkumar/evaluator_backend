o (Posswin(O)). else if Posswin(X) is not 0, then Go(Posswin(X)), else Go(Make2). Turn=7 if Posswin(X) is not 0 then Go(Posswin(X)). else if Posswin(O) is not 0, then Go(Posswin(Q}), else go anywhere that is blank. Turn=8 If Posswin(O) is not 0 then Go(Posswin(O)), else if Posswin(X) is not 0, then Go(Posswin(X , else go anywhere that is blank. Turn=9 Same as Tum=7. Comments This program is not quite as efficient in terms of time as the first one since it has to check several conditions before making each move. But it is a lot more efficient in terms of space. It is also a lot easier to understand the program s strategy or to change the strategy if desired. But the total strategy has still been figured out in advance by the programmer. Any bugs in the programmer s tic-tac-toe playing skill will show up in the program s play. And we still cannot generalize any of the program s knowledge to a different domain, such as three-dimensional tic-tac-toe. Program 2 This program is identical to Program 2 except for one change in the representation of the board. We again represent the board as a nine-element vector, but this time we assign board positions to vector elements as follows: 8 3 4 1 5 9 6 7 2 Notice that this numbering of the board produces a magic square: all the rows, columns, and diagonals sum up to 15. This means that we can simplify the process of checking for a possible win. In addition to marking the board as moves are made, we keep a list, for each player, of the squares in which he or she has played. To check for a possible win for one player, we consider each pair of squares owned by that player and compute the difference between 15 and the sum of the two squares. If tbis difference is not positive or if it is greater than 9, then the original two squares were not collinear and so can be ignored. Otherwise, if the square representing the difference is blank, a move there will produce a win. Since no player can have more than four squares at a time, there w