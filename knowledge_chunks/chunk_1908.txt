rence. For example, the
340 Chapter 9. Inference in First-Order Logic
goal Xis4 3 succeedswith Xboundto7. Ontheotherhand,thegoal 5is X Y fails,becausethebuilt-in functions donotdoarbitrary equationsolving.5 Therearebuilt-inpredicatesthathavesideeffectswhenexecuted. Theseincludeinput output predicates and the assert retractpredicates formodifying theknowledge
base. Suchpredicateshavenocounterpartinlogicandcanproduceconfusingresults forexample,iffactsareassertedinabranchoftheprooftreethateventually fails. Theoccurcheckisomittedfrom Prolog sunificationalgorithm. Thismeansthatsome
unsoundinferences canbemade;thesearealmostneveraprobleminpractice. Prologusesdepth-first backward-chaining search withnochecks forinfiniterecursion.
Thismakes itvery fast when given theright setof axioms, but incomplete when given
thewrongones.
Prolog sdesignrepresentsacompromisebetweendeclarativenessandexecutionefficiency inasmuchasefficiencywasunderstood atthetime Prologwasdesigned.
9.4.3 Efficient implementationoflogicprograms
The execution of a Prolog program can happen in two modes: interpreted and compiled.
Interpretation essentially amounts to running the FOL-BC-ASK algorithm from Figure 9.6,
with the program as the knowledge base. We say essentially because Prolog interpreters
containavarietyofimprovementsdesigned tomaximizespeed. Hereweconsideronlytwo.
First, our implementation had to explicitly manage the iteration over possible results
generated by each of the subfunctions. Prolog interpreters have a global data structure,
a stack of choice points, to keep track of the multiple possibilities that we considered in
CHOICEPOINT
FOL-BC-OR. This global stack is more efficient, and it makes debugging easier, because
thedebuggercanmoveupanddownthestack.
Second,oursimpleimplementationof FOL-BC-AS Kspendsagooddealoftimegener-
atingsubstitutions. Insteadofexplicitlyconstructingsubstitutions, Prologhaslogicvariables
that remember their current binding. At any point in time, every variable in t