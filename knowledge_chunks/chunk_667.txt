tology, then the sentence (a 8) will always take the same truth valu (na V B). Hence, either of the two could be replaced by the other without any loss. We can verify ice is a tautology by constructing a truth table. ever one can construct a tautological equivalence one can define a valid rule of substitution. The picts some of the commonly used rules of substitution. ( Vv ) (a A a) B) (B Vv a) - B) (B A ) vBvyn (av (BV yy) AB AN ( A (Pay) A B) ( v -f) (BV NN) ((aA B) V (aA YY) (BAN) (( V B) A (aV p) true) true false) true) false) false ) false ' 30) true B) (-B 70) B) (na Vv B) B) ((a B) A (BD )) AB) Y) ( (Br) idempotence of v idempotence of A commutativity of v commutativity of A associativity of v associativity of A DeMorgan s Law DeMorgan s Law distributivity of A o distributivity of Vv o contrapositive implication equivalence exportation absurdity .7 Some commonly used substitution rules. At any place in a sentence the left hand side may be replaced by the right hand si Forward Reasoning wing algorithm is a refinement of the procedure in Figure 12.3. The algorithm SimpleProofProcedure premises S, a set of instantiations R of the rules? applicable, and the goal statement. It search lirection till it produces the goal statement or no rules are applicable. At each stage it leaves a trail which is used to reconstruct the Proof. then return FAIL Pe PU consequent applied Cons(r, applied) return ReconstructPrcof(g, P, applied) istructProof(G : goal, Si premises, A: applied) goalset (G) proof () while goalSset () do next Head(goalset) goalSet Rest(goalSet) if next S then rule BackChain(next, A) antecedents Second rule) goalset Append(antecedents, goalset) procf Cons((next, rule), proof) else procf Cons((next, Premise ), proof) return proof schain( : consequent, A: rules applied) if c First(First (A) ) then return First (A) else return BackChain(Cc, Rest(A)) .8 A simple forward-search proof procedure. Observe that we assume refractoriness: Each rule can only fire once w