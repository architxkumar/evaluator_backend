, but we relax a number of PROLOG S design constraints, leading to more flexible rule-based architectures. Programming in PROLOG has been explained in more detail later in Chapter 25. 6.3. FORWARD VERSUS BACKWARD REASONING The object of a search procedure is to discover a path through a problem space from an initial configuration to a goal state. While PROLOG only searches from a goal state, there are actually two directions in which such a search could proceed: Forward, from the start states Backward, from the goal states The production system model of the search process provides an easy way of viewing forward and backward reasoning as symmetric processes. Consider the problem of solving a particular instance of the 8-puzzle. The fules to be used for solving the puzzle can be written as shown in Fig. 6.2. Using those rules we could attempt to solve the puzzle shown back in Fig. 2.12 in one of two ways: Assume the areas of the tray are numbered: 1 2 3 4 5 6 7 8 9 Square 1 empty and Square 2 contains tile n > Square 2 empty and Square 1 contains tile Square 1 empty and Square 4 contains tile n Square 4 empty and Square 1 contains tile 7 Square 2 empty and Square 1 contains tile 7 > Square t empty and Square 2 contains tile n Fig. 6.2 A Sample of the Rules for Solving the 8-Puzzle Reason forward from the initial states. Begin building a tree of move sequences that might be solutions by starting with the initial configuration(s) at the root of the tree. Generate the next level of the tree by finding all the rules whose /eft sides match the root node and using their right sides to create the new Representing Knowledge Using Rules 135 RED LE RAEI TN ESTEE SEEIOLES NSN LLL TALE DERAILED configurations. Generate the next level by taking each node generated at the previous level and applying to it all of the rules whose left sides match it. Continue until a configuration that matches the goal state is generated. Reason backward from the goal states. Begin building a tree of