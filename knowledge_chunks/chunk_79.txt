6 if GoalTest(h) TRUE 7 then return Reverse (n) fa else closed clesed uv rh g successors MoveGen(h) closed) 16 successors successors Mapcar(open) ll open open n 12 for each s in successors 13 do Add Cons(s,n) to cpen l4return FAILURE FIGURE 2.15 Algorithm SS-3 stores the path information at every node in the search tree. The path information stored in the node could also be exploited to check for looping. All that the algorithm would need to do is to check if the new candidate states are not in the path already. While the pruning of nodes will not be as tight as our algorithm above, it would require lesser storage since the set CLOSED will no longer be needed. We also remove those successors that are already on OPEN. Figure 2.16 shows the OPEN and CLOSED list for the tiny search problem for the algorithms SS-2 and SS-3. The search tree as seen by SS-2 SS-3 maintains entire path information at each node on OPEN in the OPEN CLOSED search tree. 0 The search tree as seen by SS-3 (ABO) ) OPEN CLOSED (BCE) (SA) ( ) O (CDE) (SAB) (AS) BS) (CS) ) (CGE) (DABS) (BS) (CS) EAS) (AS) SS-2 terminates when G is (CS) QBS) (EAS) AS) picked and found to be the (CS) (GDBS) EAS) ( BAS) goal. Again, the search terminates when G is picked. The program retums G. But now the program reverses the path and retums SBDG, which is the path found from S to G. FIGURE 2.16 The search trees as seen by SS-2 and SS-3. In SS-3, OPEN contains paths and CLOSED contains states. Next, we modify our search function such that both OPEN and CLOSED store node pairs, representing a node and its parent node in the search tree. Now, all nodes in the search tree have the same structure. We will, however, need to do more work to return the path found. Each node visited has a back pointer to its parent node. The algorithm reconstructPath below reconstructs the path by tracing these back pointers until it reaches the start node which has NIL as back pointer. ReconstructPath (nodePair, closed) l path List (Head(nodeP