hat the unification procedure failed. Algorithm: Unify(LL L2) 1]. If 1 or L2 are both variables or constants, then: (a) f 1 and L2 are identical, then return NIL. (b) Else if ] is a variable, then if 1 occurs in L2 then return {FAIL}, else return (L2/L1). (c) Else if 2 is a variable then if L2 occurs in L1 then return {FAIL}, else return (L1/L2). (d) Else retum {FAIL}. 116 Artificial Intelligence SRE m C ERAN 2. If the initial predicate symbols in Zi and 2 are not identical, then return { FAIL). If LI and L2 have a different number of arguments, then return {FAIL}. 4. Set SUBST to NIL. (At the end of this procedure, SUBST will contain all the substitutions used to unify L\ and 2.) 5. For i < 1 to number of arguments in L1: (a) Call Unify with the /th argument of L! and the ith argument of 2, putting result in S. (b) If S contains FAIL then return {FAIL}. (c) If 5 is not equal to NIL then: (i) Apply S to the remainder of both 1 and 2. (ii) SUBST : = APPEND(S, SUBST). 6. Return SUBST. The only part of this algorithm that we have not yet discussed is the check in steps 1() and 1(c) to make sure that an expression involving a given variable is not unified with that variable. Suppose we were attempting to unify the expressions fsx) FBO),8@)) If we accepted g(x) as a substitution for x, then we would have to substitute it for x in the remainder of the expressions. But this leads to infinite recursion since it will never be possible to eliminate x. Unification has deep mathematical roots and is a useful operation in many AI programs, for example, theorem provers and natural language parsers. As a result, efficient data structures and algorithms for unification have been developed. For an introduction to these techniques and applications, see Knight [1989]. 5.4.5 Resolution in Predicate Logic We now have an easy way of determining that two literals are contradictorythey are if one of them can be unified with the negation of the other. So, for example, man(x) and >man(Spot) 