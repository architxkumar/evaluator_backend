ze N. If it is less than K then the entire case base is returned, sorted on similarity with the query Q. Otherwise, the first K cases are inserted into R. The rest of the cases are compared with Q sequentially, and if found to be better, replace the lowest similarity case in R. SequentialKNN(g : query, CB: case base, k: retrieval size, n: case base size) 1 if kk2n then return Sort,.,(CB Re ) Sim(case;, g) , R) ) fori (k 1 ton do se Sim(case;, g) if s ksim g then Re Insert ( case,, s , Rest(R)) 10 kSim Second( First (R)) 2 3 3 4 S ksime 6 7 8 9 11 return Reverse (R) Insert (newPair, list) 1 if Second newPair) S Second First(list)) 2 then return Cons(newPair, list) 3 else return Cons(First(list), Insert(newPair, Rest(list ) FIGURE 15.14 The Sequential KNN retrieval algorithm maintains a sorted list of K cases. When it finds a better case, it removes the first case with lowest similarity and inserts the new one in its correct place. In the above algorithm, we have used the list functions First to return the first element of a list (called car in Lisp), Second to return the second element (defined as (car(cdr list)) in Lisp), Rest to return the tail of a list (called cdr in Lisp), and the Lisp function Cons that adds a new element to the head of a list. The function Insert adds a new pair to the list in its sorted place. The retrieval set contains a set of K cases that have the highest similarity with the query Q. The algorithm given here is for the second criteria, or the KNN retrieval. This is the most commonly used criteria. The reader is encouraged to modify the algorithm for the other two criteria. The complexity of the algorithm is linear in the number of cases, because each case is inspected once. It is also linear in the size of the retrieval set K, because insertion may involve comparison with K cases in R. Finally, it is dependent on the complexity of similarity computation. The similarity of each case with the query is computed once. Sequential retrieval work