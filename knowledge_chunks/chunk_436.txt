e first round however, AC-3 looks at only those domains whose values might have lost support because of the removal of some elements by Revise. Algorithm AC-3 processes each constraint at most 2k times, where k is the size of the domain of each variable. This is because it looks at a pair (or constraint) again, only if a value has been removed from one of the domains at its two ends. Since there are e binary constraints, the complexity of AC-3 is O(ek?). The factor k? as before comes from the complexity of Revise. While AC-3 is more efficient that AC-1, it turns out that it is still not optimal. This is because when it relooks at a pair of variables, it inspects their entire domain. One can do better by keeping track of which values may have lost their support and only processing those values (Mohr and Henderson, 1986). In order to do this, however, additional data structures have to be maintained. The algorithm operates at the level of labels. Each label x, a must have a supporting value for each constraint that the variable x participates in. The following data structures are used. Support set S. S is set of sets named S ,, a , one for each variable value pair x, a . For each variable-value pair (or label) x, a , the support set contains a list of supporting labels. Sex, a y, b YE X, bEDy, and a, b ERy t The support set S can be constructed by inspecting the pairs of variables for each constraint. Given e constraints and domain sizes k, this step is O(ek?). Counter array counter. For each label x, a , the counter array maintains the number of supports from a variable y. If this value becomes Zero, it means that the value a has to be removed from Dy. counter(x, a, y) number of values in Dy that support x, a The counter array can be constructed along with S, adding a constant amount of computation for each label. A queue queue of labels without support that need to be processed. The resulting algorithm AC-4 is given in Figure 9.10. We separate the initial setting up