 on the number of constant terms the could hind with. \ke Ul'.&i defined variables as a function of their domains, nominal, ordinal, binary, and interval. Next, we considered various measures that could be used in assessinz the likeness or proximity of two or more objects. These included Euclidean distance. probabilistic measures, qualitative measures, various similarity measures, and fu,i measures. We then examined matching algorithms for exact matches where the structures were required to be identical, be transformable, or be capable of binding to pattern variables with certain constraints. We also considered partial matching problems and saw two examples in which partial matches were more realistic than exact matches. Fuzz y matching procedures for objects were also described and appropriate measures presented. Finally, we concluded the chapter with a description of an important matching algorithm used in the OPS programming languages. This is the RETE algorithm which takes advantage of the fact that the contents of working memory change little from cycle to cycle, and many rules share the same conditions in their LHS. By properly indexing predicates and rules and saving match information. RETE is able to eliminate exhaustive matching on every cycle and update the conflict set only as needed. EXERCISES 10.1. Indicate whether or not consistent substitutions can t made which result ill matches for the following pairs of clauses. If substitutions can be made. given example, tit valid ones. a.P(a.f(x,b).gtt(a.y)Lz). P(a.f,yf.g(f(x.yflc) b. P(a,x) V Q(b,y,fty)) V R(x,y). P(x,a) V Q(f(y).y.b) V R(y.x) C. R(a,b,c) V Q(.v,z) V P(f(a,x,b I, P(z) V O(x.y,b) V R(x.y,z) 10.2. State what variable bindings. if any, will make the following lists match IS210 Matching Techniques Chap. 10 a. (abc (d a) 0, (7x b C Id 7y1 ?z) b. ('x a b Ic dl x), lie 0 a b y e I) c. lx y a b C Id e)). (a Ii Ii (0) a b c z) 10.3. Write a LISP function called "match" that takes two arguments and retur