), onTable(C), clear(A), clear(C), on(A, B), armempty . Then to achieve on(B, C) it would need to stack B on C, for which it would need holding(B), for which it would have to pickup(B), for which it would have to achieve clear(B), for which it would have to unstack(A, B) and put it somewhere. It would have thus undone the subgoal on(A, B) achieved earlier. We have addressed this problem by adding the full goal conjunct in the stack. After achieving on(B, C) the algorithm will reach the state S onTable(A), onTable(C), clear(A), clear(B), on(B, C), armempty and again look at the conjunct on(A, B)Aon(B, C). At this point on(B, C) is true but not on(A, B). Now it will pickup A and stack it on B to find the plan (pickup(A), stack(A, B), unstack(A, B) putdown(A), pickup(B), stack(B, C), pickup(A), stack(A, B)). It did solve the problem, but found a suboptimal plan. Another place that ordering is imposed is in the order in which the preconditions are pushed onto the stack. For the action pickup(?X) the preconditions are onTable(?X), clear(?X) and armempty. It makes sense to push armempty first, and hence tackle it later. If armempty is addressed first then the second precondition will need to disrupt it because the robot arm has to be used anyway. If for example clear(?X) is done last then that would be achieved by unstacking something from ?X, which would mean holding(? X) would be true and armempty would have got disrupted. Likewise, the preconditions of stack(?X, ?Y) are holding(?X) and clear(?Y). For a similar reason holding(?X) should be done later, and hence pushed first. While in the above problem it was possible to find a subgoal ordering to solve them linearly, this may not always be the case. A seemingly similar problem (see Figure 7.3) known as the Sussman s Anomaly, demonstrates that even in simple problems in the blocks world, the subgoals may not be serializable (Sussman, 1975). That is, there is no ordering of subgoals where when each of the subgoals is solv