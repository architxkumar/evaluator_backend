n a lazy fashion, only when there is a goal that needs to be evaluate ery time inference or backward chaining. Backward chaining is the more commonly used approach directed. One makes inferences only to test the given goal statements, even though the response an in the assertion time inference for smaller databases. An advantage of query time inferences is s the inferences that are required, and that the data base does not bloat up with true but t S. forward chaining and backward chaining are unable to find proofs where reasoning by cases is s resolution method is not only complete for FOL, it also has the added advantage that it works of inference. The resolution method was been very popular for writing automatic theorem provers, t ty can be quite high. In practice one has to attenuate the complexity by carefully feeding in the rul Once we do that, our theorem provers can treat logic as a programming language. The SLD resolt uses turns out to be backward chaining in disguise, and is the basis of the programming languag scidability of FOL is reflected in the fact that one can write programs in Prolog, and other languages owerful, that never terminate. al reasoning is concerned with making incontrovertible inferences. We can build sound and com; chines. But G del s incompleteness showed that we cannot build more powerful logic machines that it and complete. But is that a roadblock for artificial intelligence? After all human beings are able to t der statements like defining the principle of mathematical induction ?. The counter question we c: an beings consistent? Perhaps if we can give up the requirement of consistency we might be able s that can stumble upon, and serendipitously hold on to, a higher order truth. al reasoning is important. There is no doubt about it. But is completeness equally important? After al been able to decide the Goldbach conjecture, written in a June 7, 1742 letter to Euler, and which : 2ems that every number that is greater than 2 is the s