e actions once a card is to be played expressed as followed. (pe update-top-card (played card c player p suit 3s ) (cavd-rank card c player p suit s ) (highest-card card c player p suit s ) ay (remove 3) (mccify 2 played yes ) Notice that the patterns on the LHS just need be enough to identify the concerned WME and access its relevant attributes. The pattern (card-rank ...) above is used to spot the relevant card and modify its attribute played to value yes, and one needs only enough information to pinpoint the WME. Two actions have been introduced above. The first one says that the WME matching the pattern 3 of this matching instance of the rule should be removed or deleted. The second one says that in the corresponding matching WME for pattern 2, the value of the played attribute is to be set to yes . This will, of course, overwrite the earlier value of no before the card was played. The above rule could equivalently be written as, (pe update-top-card (played card c player p suit s ) pe (card-rank card c player p suit s ) ho (highest-card card c player p suit s ) (remove po ) (mecify he played yes) ) This uses names for patterns instead of their sequence number. Apart from the three actions make, modify and remove introduced here, the language also has actions for doing arithmetic computations (compute ...) and input output actions (openfile ...) (closefile ...), (write ...), (accept ...), (erlf), etc. The reader is encouraged to consult the book by Brownston et al. (1985) for more details. 6.6.3 Inference Engine The inference engine goes through the following cycle: 1. Match For each rule, find all matching instances. The output of the MATCH routine is known as the Conflict Set (CS). If the CS is empty then the program exits. The Conflict Set is a made up of elements of the form (rulename timestamp, timestampo... timestamp,). Where the timestamp; is the sequence number used to identify the WME matching the corresponding pattern in the rule. That is, the Conflict 