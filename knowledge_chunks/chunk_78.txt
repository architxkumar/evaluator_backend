eens on an n x n chessboard such that no queen attacks (as defined by rules of the game) any other queen. We can call such problems as configuration problems. The other kinds of problems, that we call planning problems, are those in which we need a sequence of moves or the path to the goal state. Clearly, our program is inadequate for the latter kind of problems. One simple approach is to explicitly keep track of the complete path to each new state. We can do this by modifying the state representation (in the search algorithm only) to store a list of nodes denoting the path. In order to work with the same domain functions moveGen and goalTest, we need to modify our algorithm. Simple-Search-3 (SS-3) incorporates this change (see Figure 2.15). After picking the node from OPEN, it extracts the current state H. It tests H with goa Test and generates its successors using moveGen. When the goal node is found, all that the algorithm needs to do is to reverse the node to get the path in the proper order. The function mapcar in Figure 2.15 takes a list of lists as an argument and returns a list containing the heads of the input lists. The function cons adds a new element to the head of a list. In some problems, the path information can be represented as part of the state description itself. An example of this is the knight s chessboardtour problem given in the exercises. One could start by representing the state as a 10 x 10 array in which the centre 8 x 8 sub-array, initialized to say 0, would be the chessboard. The starting state would be a square on the chessboard labelled with 1, and subsequent squares could be labelled in the order in which the knight visits them. SimpleSearch3 () 1 cpen (start) 2 closed 3 while open is net empty 4 do Pick some node n from cpen 5 A Head(n) 6 if GoalTest(h) TRUE 7 then return Reverse (n) fa else closed clesed uv rh g successors MoveGen(h) closed) 16 successors successors Mapcar(open) ll open open n 12 for each s in successors 13 do Add C