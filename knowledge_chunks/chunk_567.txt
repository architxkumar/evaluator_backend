illustrated in the Chapati action for fluent cooking-on). There could be other actions that require this fluent as an overall condition. For example, a LightMatch action may produce the fluent light, which might be needed for searching for something or the OperateCoalMine action described in (Coles at al., 2008) that keeps a mine operational that is needed for the MineForCoal action. Concurrency may also be required for a particular planning problem when one is to plan with deadlines. For example, if one is to cook twenty chapatis in the cooking problem then it may be necessary to cook them two at a time on the two stoves. In other words, exploiting concurrency can result in plans with the shortest makespan, and may be necessary if there is a bound on the allowed makespan. It is the required parallelism that motivates us to look for new planning algorithms. If one were interested in plans that were sequential, then one could simply collapse the durative actions into instantaneous ones, introduce duration as a metric fluent, and look for an optimal plan using the methods described earlier. 10.5.1 Temporal Planning Graphs In Temporal Graphplan (TGP), Smith and Weld (1999) adapted the Graphplan algorithm to plan with a simplified form of durative actions. They assume that (1) all preconditions hold at the start, (2) preconditions not affected by the action itself hold throughout its execution, and (3) effects are defined only at the end of the action. The bi-level planning graph constructed by TGP avoids duplication of multiple layer representation in the manner described above for STAN. As Smith and Weld argue, a bi-level graph makes even more sense for temporal planning, since there is no intrinsic notion of sequencing of layers, because different actions can have different durations. The labels for actions and propositions are not layer numbers but real values indicating start times. Given that different actions executing at the same time may span different time int