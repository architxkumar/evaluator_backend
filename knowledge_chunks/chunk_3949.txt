 need to prove dx - event(x, 79) at : died(Marcus, t) = sdied(Marcus, t) =Pompeian(x1) \/ died{x, 79) udied (Marcus, f) 79/t, Marcus/ x, Pompeian(Marcus) | .Pompeian(Marcus) So (a) Pompeian(x;) \/ died(x,, 79) -died(Marcus, t)\/ died (Marcus, f) NF, Marcus/x, Pompeian(Marcus) \/ died (Marcus, 79) ~Pompeian(Marcus) =died{Marcus, 79) (b) Fig. 5.14 Answer Extraction Using Resolution 124 Artificial Intelligence and to discover a value for x. But we do not have any statements of the form event(x, y). We can, however, answer the question if we change our representation. Instead of saying erupted(volcano, 79) we Can say event(erupted(volcano), 79) Then the simple proof shown in Fig. 5.15 enables us to answer the question. This new representation has the drawback that it is more complex than the old one. And it still does not make it possible to answer all conceivable questions. In general, it is necessary to decide on the kinds of questions that will be asked and to design a representation appropriate for those questions. nevent(x,79) \/ event(x, 79) event (erupted (volcano),79) erupted (voicano)x event (erupted (voicano),79) Fig. 5.15 Using the New Representation Of course, yes-no and fill-in-the-blank questions are not the only kinds one could ask. For example, we might ask how to do something. So we have not yet completely solved the problem of question answering. In later chapters, we discuss some other methods for answering a variety of questions. Some of them exploit resolution; others do not. 5.5 NATURAL DEDUCTION In the last section, we introduced resolution as an easily implementable proof procedure that relies for its simplicity on a uniform representation of the statements it uses. Unfortunately, uniformity has its price everything looks the same. Since everything looks the same, there is no easy way to select those statements that are the most likely to be useful in solving a particular problem. In converting everything to clause form, we often lose valuable he