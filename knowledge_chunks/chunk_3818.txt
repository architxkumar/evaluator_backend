t often arises when the search process operates as a tree walk. On the third level, the node (0, 0) appears. (In fact, it appears twice.) But this is the same as the top node of the tree, which has already been expanded. (0.0) Those two paths have not gotten Us anywhere. So we would like to eliminate them and continue only along the other branches. i The waste of effort that arises when the same node is generated (4,0) [{0.3) - more than once can be avoided at the price of additional bookkeeping. Instead of traversing a search tree, we traverse a ay 4 ay directed graph. This graph differs from a tree in that several paths may come together at a node. The graph corresponding to the tree of Fig. 2.18 is shown in Fig. 2.19. Any tree search procedure that keeps track of all the nodes that have been generated so far can be converted to a graph search procedure by modifying the action performed each time a node is generated. Notice that of the two systematic search procedures we have discussed so far, this requirement that nodes be kept track of is met by breadth-first search but not by depth-first search. But, of course, depth-first search could be modified, at the expense of additional storage, to retain in memory nodes that have been expanded and then backed-up over. Since all nodes are saved in the search graph, we must use the following algorithm instead of simply adding a new node to the graph. Fig. 2.19 A Search Graph for the Water jug Problem Algorithm: Check Duplicate Nodes 1. Examine the set of nodes that have been created so far to see if the new node already exists. 2. If it does not-simply add it to the graph just as for a tree. 3. If it does already exist, then do the following: (a) Set the node that is being expanded to point to the already existing-node corresponding to its successor rather than to the new one. The new one can simply be thrown away. (b) If you are keeping track of the best (shortest or otherwise least-cost) path to each node, then check to