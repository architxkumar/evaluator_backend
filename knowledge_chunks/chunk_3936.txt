mes so restricted that NL there is no way it can be true. This is indicated by the generation of the empty a WQ 7Q clause. To see how this works, let s look again at the example. In order for proposition NS rt 2 to be true., one of three things must be true: -P 7Q, or R. But we are assuming SY that 7R is true. Given that, the only way for proposition 2 to be true is for one of two things to be true: ~P or -Q. That is what the first resolvent clause says. But Fig. 5.8 Resolution in proposition | says that P is true, which means that =P cannot be true, which leaves Propositional only one way for proposition 2 to be true, namely for 7@ to be true (as shown in Logic the second resolvent clause). Proposition 4 can be true if either ~T or Q is true. But since we now know that 7Q must be true, the only way for proposition 4 to be true is for 37 to be true (the third resolvent). But proposition 5 says that 7 is true. Thus there is no way for all of these clauses to be true in a single interpretation. This is indicated by the empty clause (the last resolvent). 5.4.4 The Unification Algorithm In propositional logic, it is easy to determine that two literals cannot both be true at the same time. Simply look for L and =L In predicate logic, this matching process is more complicated since the arguments of the predicates must be considered. For example, man(John) and ~man(John) is a contradiction, while man(John) artd sman(Spot) is not Thus, in order to determine contradictions, we need a matching procedure that compares two literals and discovers whether there exists a set of substitutions that makes them identical. There is a straightforward recursive procedure, called the unification algorithm, that does just this. The basic idea of unification is very simple. To attempt to unify two literals, we first check if their initial predicate symbols are the same. If so, we can proceed. Otherwise, there is no way they can be unified, regardless of their arguments. For example, the two