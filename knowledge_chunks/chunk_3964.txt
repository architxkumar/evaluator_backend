redicate coming before the rules for that predicate so that the facts can be used immediately if they are appropriate and the rules will only be used when the desired fact is not immediately available. In this example, there are no facts with this predicate, though, so the one rule there is must be used. Since the rule will succeed if both of the clauses on its right-hand side can be satisfied, the next thing the interpreter does is to try to prove each of them. They will be tried in the order in which they appear. There are no facts with the predicate pet but again there are rules with it on the right-hand side. But this time there are two such rules, rather than one. All that is necessary for a proof though is that one of them succeed. They will be tried in the order in which they occur. The first will fail because there are no assertions about the predicate cat in the program. The second will eventually lead to success, using the rule about dogs and poodles and using the fact poodle (fluffy) . This results in the variable X being bound to fluffy. Now the second clause small (X) of the initial rule must be checked. Since X is now bound to fluffy, the more specific goal, small (fluffy), must be proved. This too can be done by reasoning backward to the assertion poodle (fluffy). The program then halts with the result apartmentpet (fluffy). Logical negation () cannot be represented explicitly in pure PROLOG. So, for example, it is not possible to encode directly the logical assertion Vx: dog(x) > acat(x) Instead, negation is represented implicitly by the lack of an assertion. This leads to the problem-solving strategy called negation as failure [Clark, 1978]. If the PROLOG program of Fig. 6.1 were given the goal ?- cat(fluffy). 134 Artificial Intelligence MRA A EINE TTA OES ETNIES IE SLOAN IT TNE SEE TES it would retum FALSE because it is unable to prove that Fluffy is a cat. Unfortunately, this program returns the same answer when given the goal even though the prog