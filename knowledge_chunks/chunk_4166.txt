ler going backward, most planning systems work primarily in a goal-directed mode in which they search backward from a goal state to an achievable initial state. 250 Artificial Intelligence In the next several sections, a variety of planning techniques are presented. Ail of them, except the last, are problem-solving methods that rely heavily on problem decomposition. They deal (to varying degrees of success) with the inevitable interactions among the components that they generate. 13.2 AN EXAMPLE DOMAIN: THE BLOCKS WORLD The techniques we are about to discuss can be applied in a wide variety of task domains, and they have been. But to make it easy to compare the variety of methods we consider, we should find it useful to look at all of them in a single domain that is complex enough that the need for each of the mechanisms is apparent yet simple enough that easy-tofollow examples can be found. The blocks world is such a domain. There is a flat surface on which blocks can be placed. There are a number of square blocks, all the same size. They can be stacked one upon another. There is a robot arm that can manipulate the blocks. The actions it can perform include: e UNSTACK(A, B) Pick up block A from its current position on block B. The arm must be empty and block A must have no blocks on top of it. * STACK(A, B) Place block A on block B. The arm must already be holding and the surface of B must be clear. PICKUP(A) Pick up block A from the table and hold it. The arm must be empty and there must be nothing on top of block A. PUTDOWN( A) Put block A down on the table. The arm must have been holding block A. Notice that in the world we have described, the robot arm can hold only one block at a time. Also, since all blocks are the same size, each block can have at most one other block directly on top of it.! In order to specify both the conditions under which an operation may be performed and the results of performing it, we need to use the following predicates: ON(A, B} Blo