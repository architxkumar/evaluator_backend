nning through all of them at every step of the search would be hopelessly inefficient. It is not always immediately obvious whether a rule s preconditions are satisfied by a particular state. Sometimes there are easy ways to deal with the first of these problems. Instead of searching through the rules, use the current state as an index into the rules and select the matching ones immediately. For example, consider the legal-move generation rule for chess shown in in Fig. 6.4. To be able to access the appropriate rules immediately, all we need do is assign an index to each board position. This can be done simply by treating the board description as a large number. Any reasonable hashing function can then be used to treat that number as an index into the rules. All the rules thai describe a given board position will be stored under the same key and so will be found together. Unfortunately, this simple indexing scheme only works because preconditions of rules match exact board configurations. Thus the matching process is easy but at the price of complete lack of generality in the statement of the rules. As discussed in Section 2.1, it is often better to write tules in a more general form, such as that shown in Fig. 6.5. When this is done, such simple indexing is not possible. In fact, there is often a trade-off between the ease of writing rules (which is increased by the use of high-level descriptions) and the simplicity of the matching process (which is decreased by such descriptions). Black Black a|x[a[alvlo/alala xla/al ie/aja[n 7(alalalalalalala alalalalalalalas 6 { [ 1 5 ie ~ 4 & 3 2(a[alalalalalala alalala; [ajala 1\glalalylelalalg nlalal le/slale aobedef GQGih abcdefdginh White White Fig. 6.4 One Legal Chess Move Representing Knowledge Using Rules 139 White pawn at Square(tile e, rank 2) AND move pawn from Square(file e, rank 3) > Square(file e, rank 2) is empty to Square(file e, rank 4) AND Square(file e, rank 4) is empty Fig. 6.5 Another Way to Describe Chess M