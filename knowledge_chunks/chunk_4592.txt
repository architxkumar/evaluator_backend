ent ), For each synonym a new fact has to be added. This makes the process tedious. Lists provide for a more compact database as thesaurus( like , [love , fond , similar , akin*}). thesaurus( give , [ offer , bestow, present ]). This could be further compacted by including the base word such as like as the head of the corresponding list. thesaurus({ like , love, fond , similar, akin ]). thesaurus({ give , offer, bestow , present ]). One may now write a program to interpret the list as The head of the list is the base word while the tail contains its synonyms. We may also interpret it as If a word belongs to the list, the rest of the words in the list are its synonyms. We could also condense the thesaurus into just one list asthesaurus([[ like , love , fond , similar , akin ],[ give , offer, bestow , present ]]). wherein all the words along with their respective synonyms form a list of lists. A few sample programs that manipulate lists form interesting utilities and when coupled with other programs can reveal the true potential of the list structure. Some of them have been included below Appending an element to a list add(Element, In List, [Element | In List]). It is amusing to note that the above single statement can perform the following: 510 Artificial Intelligence Ge nna (a) Add an element to a list: The clause for add/3 takes in an element (Element) and the list to which it is to be added (/n List) to give the output list with the element as its head and the /n List as its tail. For example, add(1,{2,3,4], Out_List). binds Out_List to [1,2,3,4]. ' (b) Verify whether an element is the head of the list as in ~ add(1, [2,3,4],[1,2,3,4]). (c) Get the head of a list whose tail is known. add(Head, [2,3,4],[1,2,3,4]). (d) Get the tail of a list whose head is known. add(1, Tail, [1,2,3,4]). Though (c) and (d) can be achieved using other techniques they have been stated here to emphasize the functionality of the same predicate. Member of a list member(X,{X\_]). member(X,