 as Frames, Il Computation of a value of a slot as needed. This relies on the to-compute and transfers-through attributes. Checking that only a single value is asserted for single-valued slots. This is usually done by replacing an old value by the new one when it is asserted. An alternative is to force explicit retraction of the old value and to signal! a contradiction if a new value is asserted when another is already there. There is something slightly counterintuitive about this way of defining slots. We have defined the properties range-constraint and default as parts of a slot. But we often think of them as being properties of a slot associated with a particular class. For example, in Fig. 9.5, we listed two defaults for the batting-average slot, one associated with major league baseball players and one associated with fielders. Figure 9.11 shows how batting-average instance : Slot domain : ML-Basebail-Player range | Number range-constraint : Ax (0 < x.range-constraint < 1) default : 252 single-valued : TRUE fielder-batting-average instance : Slot isa: batting-average domain : Fielder range * Number range-constraint : Ax (0 < x.range-constraint < 1) default : 262 single-valued : TRUE Fig.9.11 Associating Defaults with Slots Weak Slot-and-Filler Structures 201 Ak ARAN SE TPS INE this can be represented correctly, by creating a specialization of batting-average that can be associated with a specialization of ML-Baseball-Player to represent the more specific information that is known about the specialized class. This seems cumbersome. It is natural, though, given our definition of a slot as a relation. There are really two relations here, one a specialization of the other. And below we will define inheritance so that it looks for values of either the slot it is given or any of that slot s generalizations. Unfortunately, although this model of slots is simple and it is internally consistent, it is not easy to use. So we introduce some notational shorthand that allow