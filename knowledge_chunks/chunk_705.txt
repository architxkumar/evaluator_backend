es all movies as long as they are not emotional dramas. tion as failure provides us a useful tool for defining compliments of sets. For example we can d compositeNumber(N) :- neg(primeNumber(N)). weakStudent(S) :- neg(brightStudent(S), neg(averageStudent(S). jill not get into the intricacies of Prolog, but only make the observation that while it may be suf the relations in a logic programming language, it becomes necessary to do so with extreme care if it efficient systems. So much so that writing the rules in a language like Prolog involves as muc' rograms in other languages. We illustrate this point in closing with presumably the most common essing, that of sorting a list. ollowing program describes perfectly well what it means to sort a list (see also (Lloyd, 1984)). rt(X, Y) :-permutation(X, Y), sorted(Y). rmutation((), ()). rmutation (cons(X, Y), cons(U, V)) :- remove(X, cons(U, V), Z), permutation(Y, Z). move(X, cons(X, Y), Y). move(X, cons dzilf)ut s(Z, U)) :- remove(X, Y, U). rted(()). rted(cons(X, ()). append(sorteadSOE, cons(Xhead, sortedB)). licksort((),()). irtition(Pivot, cons(HeadList, TailList), cons(HeadList, Sm), Bg) :- SmallerOrEqualThan(HeadList, Pivot), partition(Pivot, TailList, Sm, Bg) irtition(Pivot, cons(HeadList, TailList), Sm, cons(HeadList, Bg) :- LessThan(Pivot, HeadList), partition((Pivot, TailList, Sm, Bg). irtition(Pivot, (),(),()). 1 says that partition the tail of the given list into smaller and bigger elements by choosing the h as pivot, recursively (quick)sort the two lists, and append the results, with the pivot inserted betwe the base case to end the recursive calls. Line 3 picks the first element if it smaller or equal, and call to partition. Line 4 picks it if it is larger. Line 5 ends the recursive calls to partitioning. ly, it is a good practice to write the base clauses in recursion first. Sometimes it is nece: ness. For example the following definition of natural numbers works only when the clauses are 1 suming that the suc