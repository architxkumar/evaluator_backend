;-., MuP:-1) 1 Preconds precond(a,) 2 if Preconds P, , 3 then for each p, Preconds 4 for each py Preconds 5 if Pe, Py MuP:-, or Py, Pa MuPs-, 6 then return false 7 else return false 8 xreturn true FIGURE 10.5 The procedure ExtendGraph creates the i" action layer and the i proposition layer. It begins by copying the two preceding layers, and then adds any new applicable actions, and effects, and links to preconditions and effects. After adding all the actions and their effects, it computes afresh the mutex relation for the new action layer and the proposition layer. The algorithm returns the planning graph along with the level i and the flag levelled. If levelled false then the planning graph has been extended to the first layer in which the goal propositions exist without any mutex relations between them. The (calling) algorithm now needs to investigate whether a valid plan can be extracted from the planning graph. If levelled true then the problem has no solution. PlanningGraph (S, G, A) Res A () Mua, ( ) MuP, ( ) PreE, () PostP, ( PostNy ( ied leveled false 0 while not (GoalPropExist(G, P, 1 ieitl 2 PlanGraph ExtendGraph (i, A, Aj, MuAy, PreE,, PostP,, PostNy, Py, Muy, .., Az, MuA;., PreE;,, PostP;,, PostN;-., P:-;, MuP,-, ) 13 if (P,., P, and MuP,., MuP,) then leveled true 14 return PlanGraph, i, leveled ) ) MuP.)) or leveled) PERE OOIHHHWWH GoalPropExist(G, P,, MuP,)) if GcP, then for each p, G for each pp G if p,, Py MuP, or py, P MuP, then return false else return false return true YHRULWY HE FIGURE 10.6 The algorithm PlanningGraph takes as input the start state S, the goal propositions G, and the set of ground actions A. It begins by extending the graph to layer one. After that, it keeps calling ExtendGraph until one of the following conditions become true. One, the goal propositions have appeared nonmutex in the latest layer. Or two, the planning graph has levelled off. The empty sets at level zero have been created only to allow a uniform call to ExtendGrap