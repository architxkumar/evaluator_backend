 side of the rule can are satisfied. In brief one should bear in mind that PROLOG allows structures that comprise a name (or it could be an atom) with arguments enclosed in brackets. Two such terms unify only if their structure names, also called the functors, are same, the number of arguments within are same and every argument within it unifies with the corresponding one of the other. 25.9 BACKTRACKING By now we have partially discussed what backtracking means. But let s finish it for good. Imagine you have entered a maze and are trying to search for something within. You would in the normal course always take the left turn (or right) consistently at every fork and continue. If you reach a dead end, you would return to the fork and try the right tum (or the left). Eventually you would search the whole maze. We have seen that in compound goals, PROLOG attempts to do the very same. The process is called backtracking. Whenever there is a fork or alternate paths to be discovered a backtracking point is put up and the same is visited in the event of a failure. Let s look at the following program. likes(prakash, X) :-edible(X), tastes(X, sweet}. tastes(chocolates, sweet). tastes( gourd, bitter). tastes(toffees, sweet), edible(chocolates). edible(toffees). edible(gourd). What happens when you pose the goal: likes(prakash,X). The right hand side of the rule for likes is first triggered. So we have edible(X) interpreted as Find an X such that X is pdible to be satisfied. There are thfee values that X could take (chocolates, toffees and gourd). The variable X is first bound to chocolates. The process of verifying whether chocolates are sweet continues using tastes(chocolates, sweet). Since this too is true the system retums chocolates as an answer. If you press ; you can get further solutions for X. Now, inspect the modified program below: 504 Artificial intelligence likes(prakash, X) :-edible(X), tastes(X, sweet),write(X),nl fail. tastes( chocolates,sweet). tastes( gourd, b