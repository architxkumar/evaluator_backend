es from the right half of the tree. Let us flip the tree about the root by reversing the order of the leaves and run the AlphaBeta procedure on the reversed tree. The resulting cutoffs are shown in Figure 8.26. Minimax value Recommended move ee ee ) Beta cutoff ae . a asa he S 1 Beta cutoff 7 rae 7 (s) C ) ) CF, O iS (s) 7) 5) nN 8 uj a2i s js 9 Jcs ie 11 7 j -s J fo Alpha cutoff Alpha cutoff N ) is) is) 10 FIGURE 8.26 When the tree of Figure 8.25 is flipped about the root, the algorithm inspects only eight nodes out of sixteen. As can be seen, the number of cutoffs in the same game tree, but with the order reversed, has gone up to eight, and only eight of the sixteen nodes are inspected. In Exercise 8, the reader is asked to construct a tree in which AlphaBeta is forced to evaluate all leaves, and then try the algorithm on the flipped tree. It is evident that the performance of the AlphaBeta algorithm depends upon the order in which the moves are generated, and when the better moves are generated earlier, the cutoffs will be greater in number. But how do we generate the better moves first? One way could be to somehow put in domain-specific heuristics to order the moves. For example, in the Noughts and Crosses game, corner moves might be preferred over side moves. Another, and a domain independent, way would be to use one instance of search to order the moves in the next instance of search. Let us say MAX is to play in some board position X. MAX calls the AlphaBeta algorithm and along with finding the best moves, also keeps track of the moves it explored at the third ply. These are moves it will start searching with the next time it has to make a move. MAX utilizes the current search to order the moves in preparation of the next one (see exercises 6 and 9). Another way would be to give the algorithm a sense of direction, like in the transition from depth first search to heuristic search in Chapter 3. The algorithm AlphaBeta searches blindly from left to right. In th