. In these problems, there is no a priori goal state. For problems of this sort, it makes sense to terminate hill climibing when there is no reasonable alternative state to move to. 3.2.1 Simple Hill Climbing The simplest way to implement hill climbing is as follows. Algorithm: Simple Hill Climbing 1, Evaluate the initial state. If it is also a goal state, then return it and quit. Otherwise, continue with the initial state as the current state. 2. Loop until a solution is found or until there are no new operators left to be applied in the current state: (a) Select an operator that has not yet been applied to the current state and apply it to produce a new state. (b) Evaluate the new state. (i) Hf it is a goal state, then return it and quit. (ii) If it is not a goal state but it is better than the current state, then make it the current state. (iii) If it is not better than the current state, then continue in the loop. The key difference between this algorithm and the one we gave for generate-and-test is the use of an evaluation function as a way to inject task-specific knowledge into the control process. It is the use of such knowledge that makes this and the other methods discussed in the rest of this chapter heuristic search methods, and it is that same knowledge that gives these methods their power to solve some otherwise intractable problems. Notice that in this algorithm, we have asked the relatively vague question, Is one state better than another? For the algorithm to work, a precise definition of better must be provided. In some cases, it means a higher value of the heuristic function. In others, it means a lower value. It does not matter which, as long as a particular hill-climbing program is consistent in its interpretation. To see how hill climbing works, let's return to the puzzle of the four colored blocks. To solve the problem, we first need to define a heuristic function that describes how close a particular configuration is to being a solution, One s