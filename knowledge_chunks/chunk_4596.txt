 be a dynamic predicate. Clauses for this predicate can now be added or deleted during run time. enter_name/0 uses add_name/] to get the input name string to be added to the database. Since getb/] reads the characters entered via the keyboard, we need to collect and transform them into a string for proper storage. Note that add_name/] is recursive and called with an empty list into which the characters are added one by one. The check for code 13 is done to see whether the Enter key is pressed and if so the output list containing the characters in reverse order is reversed using reverse_list/3 to put them in the right form. The list is converted to a string using string_chars/2 and then stored into the dynamic database using assert. assert and retract thus constitute a way to add or delete dynamic clauses for name_db during run time. The program also features predicates for discard_name/0 which deletes the fact from the dynamic database using retract. Together assert and retract form a powerful tool to manipulate the execution of code during mun time. Compile the program and issue the goal 514 Artificial Intelligence OSCAR LT TTC enter_name. Enter the name to be added. Assume you typed Prakash for a name. Now you can go ahead to verify whether the same is entered in the database by using the goal name_db(Name). you would get the output as | ?- Name = Prakash You could add more names and imagine you accidentally entered the name Devil and wish to delete it. Use the goal discard _name. and enter the name Devil. Try issuing the goal name_db(Devil) again and lo and behold you will discover that the Devil has vanished! Now that we have seen how a dynamic database can be generated and manipulated imagine a case wherein you could also add, delete or modify code on the fly. In the PROLOG environment this can be achieved by adding or deleting rules. Recollect the count/] program we used to comprehend recursion. Let s see how we can add the whole program dynamically. The actua