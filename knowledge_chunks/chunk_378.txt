8 then if J is MAX 9 then for j b tol bi branching factor 10 do J-j is the j child of J 11 open Cons( J j, LIVE, h , open) 12 else only first child for MIN node 13 open Cons( Jl, LIVE, h , open) 14 else Jas terminal 15 open Insert( J, SOLVED, Min(h, e(J)) , open) 16 else status s SOLVED 17 if J Jyj is MAX Jis the j child of J, 18 then if j b 20 then open Cons( Jy, SOLVED, h , open) 21 else open Cons( J, j 1, LIVE, h , open) 2 else J 9, j is MIN 23 open Cons( J,, SOLVED, h , open) 24 like an cutoff 25 Remove from open all successors of Jp 26 until FALSE Repeat Indefinitely, exit when root is SOLVED FIGURE 8.33 The algorithm SSS maintains a sorted open containing partial strategies and their upper bounds. It returns the minimax value when the root is labelled SOLVED. The function Insert inserts the triple after the last triple that has a higher value (as in the variation given in (Pearl, 1984)). Now D7 is removed from OPEN, and since it has an unexplored sibling, that is added to OPEN in Line 21 as a LIVE node with a value 11. Next it is removed and replaced (Line 15) with a SOLVED label and the value 11, the smaller of 11 (value of h in D1) and 12 (its own value e(D2)). OPEN ( D2, SOLVED, 11 , A1, SOLVED, 10 , B1, SOLVED, 7 , C1, SOLVED, 5 ) The node D2 is removed next, and since it is the last unexplored sibling, the parent node D12 is added as a SOLVED node in Line 20. This is still the best node. OPEN ( D12, SOLVED, 11 , A1, SOLVED, 10 , B1, SOLVED, 7 , C1, SOLVED, 5 ) Now D12 is removed and replaced by node D as a SOLVED node, and all its siblings (in this case C1) removed (Lines 23-25). OPEN ( D, SOLVED, 11 , A1, SOLVED, 10 , B1, SOLVED, 7 ) root wis ITIL L Js 1 fi2) (2 J s Al A BI cl DI D2 Dl D2 Dyl FIGURE 8.34 The game tree of Figure 8.32 redrawn with names for the nodes visited by SSS . The shaded nodes are the ones that were marked SOLVED by SSS at some point. When D is removed (Line 21), its sibling D; is added to OPEN as a LIVE node. OPEN ( Dj, LIVE, 11 , 