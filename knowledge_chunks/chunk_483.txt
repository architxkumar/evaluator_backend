gorithm that is aware of the underlying constraint graph, but determines where to jump back to, based on the actual conflicts that it has recorded. As a result, it can jump back over variables that GraphBackjumping is forced to revisit. The algorithm uses an ordering of the constraints defined as follows. Given an ordering of the variables, a constraint C; comes earlier than a constraint C; if the latest variable in its scope S; which is not in S; comes earlier in the variable ordering, than the latest variable in Ss not in S;. For example, if the variables are ordered as (xy, X2, ..., Xn ) and the scope of Cy is S4 x4, X5, X7, Xg and the scope of Cz is So Xp,x5,Xg,X9 then Cz comes earlier in the constraint ordering because xg comes before x7. Let the ordered set of constraints be (C4, Co, ..., Cp) with the corresponding relations (Rj, Ro, ..., Rp) and scopes (Sj, So, ..., Sp). When the algorithm has constructed a compound label ay (x4 V4, Xo Vo, ... Xk Vx) and is looking for a consistent value for the (k 1) t variable X,41, it looks at the values in its domain D,4; one by one. For each value b Dy. 4 that is inconsistent with a,, it identifies the earliest constraint C; (in the ordering described above) that violates (ay, x, 4 6). It adds the variables in the scope S; of that constraint to the set of target variables it may need to jump back to. Like GraphBackjumping, this algorithm too accumulates the target variables when it jumps back from a future variable Y to the current variable, and also chooses the latest variable from this set of target variables. The algorithm is depicted in Figure 9.45. One difference between Gaschnig s Backjumping algorithm and CDBackjumping is that in the SelectValue phase, the former marks the index of the variable that is the culprit at a leaf dead end, while the latter marks the constraints that participate in a conflict with any value of the current variable. As it tries different values b CED,4,1, it marks all the (variables in th