nstant amount of computation for each label. A queue queue of labels without support that need to be processed. The resulting algorithm AC-4 is given in Figure 9.10. We separate the initial setting up of the data structures and the propagation into two modules. Before propagation begins, the procedure nitialize constructs the data structures. For every constraint Cy, it does the following. For each label x, a in D, it finds the supports y, b in Dy and stores them in Sc, a , and conversely stores x, a in Scy, p for each label y, b in Dy. It also counts how many support each label has for each constraint it participates in. Finally, it identifies unsupported labels, removes them from their domains, and enters them into a queue to propagate the effects of their being removed. In the propagation phase after the initialization, it removes the labels in the queue and deletes them one by one. For every value a for a variable x that is removed, the AC-4 algorithm looks up S.,, a for values of other variables it was supporting. For each such value b of variable y, it decrements counter(y, b, x). If any counter becomes zero then the corresponding value is removed and a label is added to queue for propagation. Thus while AC-3 was an improvement over AC-1 because it selectively calls Revise only with those pairs of domains for which a supporting a value has been deleted, AC-4 is an improvement over AC-3 because it only looks at those labels whose supporting labels have been deleted. Since it does not make a brute force call to revise it saves on the O(k)? computation that Revise does. Given that there are e edges and each domain has at most k values, the complexity of procedure Initialize is O(ek2). This is because constructing the support S and the counter can be done by inspecting the domains of the variables on each side of each constraint. In the algorithm above, the support sets have been initialized outside the loop at step 4 for simplicity. In practice, they will be cons