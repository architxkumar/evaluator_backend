 are enough to prevent search from leaking back. The SMGS also keeps relay nodes for reconstruction of the path like the DCFS. The difference is that it calls a module PruneClosed to prune the CLOSED list only when it senses that it is running out of memory. The algorithm identifies three kinds of nodes. One, the kerne! nodes that have been inspected and all their successors have been inspected. And two, the boundary nodes that have been inspected but have some successors on OPEN. Finally, the nodes in OPEN are the ones that have been generated but have not been inspected. Together, the kernel and the boundary would form the CLOSED set. Initially, the Start node is marked as a relay node. The algorithm begins by keeping all three kinds of nodes, and proceeds to pick nodes from OPEN and inspect them. Then at any time if it senses that it is running out of memory, it does the following, by calling a PruneClosed function. First, for every node on OPEN, it marks the corresponding nodes on the boundary as relay nodes. Then for each node on the boundary, it traces the back pointers to the latest relay node, and sets an ancestor pointer to that relay node. Then it deletes all kernel nodes that are not relay nodes. Having finished the pruning, it continues to pick nodes from OPEN and inspect them. The first time this is done, the ancestor pointer points to Start. The process is illustrated in Figures 5.26 and 5.27. ee (OPEN) Start Goal Nodes in Boundary become Relay nodes FIGURE 5.26 SMGS converts boundary nodes into Relay when a prune module is called. The SMGS algorithm may create more than one relay layer if it is solving a large problem. It would have to recursively solve each segment between two consecutive relay nodes; otherwise it continues like the A search algorithm. Therefore, while on the one hand it does pruning only when necessary, thus saving on reconstruction cost; on the other hand, it can create many relay layers, thus being able to tackle larger problems. 