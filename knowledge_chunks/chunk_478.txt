alls SelectValue-GBJ with a variable x;, the latter inspects values in the domain Dj one by one, till it finds a consistent value. For each value, it checks for consistency with the prefix of k values in the label, k varying from 1 to i. If for some k, it cannot find a value then it marks that k as a possible culprit. The real culprit is the highest such index found for each of the values of x;. Note that the culprit is needed only if all values of x; are inconsistent, and the state is a dead end. Backjumping (X, D, C) 1aAe ( )) 2ai 1 3 De D, 4 latest(i) 3 S while l1 ign do a, SelectValue-GBI(D, , A, C, i) 7 if a; aull 8 then i latest(i) i A Tail(A) 1 else 11 A Cons(a;, A) 12 ie i- el 13 datest(i) - 23 14 ificgn 15 then D, D, l return Tail (Reverse (A) ) SelectValue-GBJ (D. , A, C, i) 1 while not empty(D, ) 2 do a, Head(D, ) 3 D, Tail(D, ) 4 conflicting false kel while k i and not conflicting 7 if k latest(i) then latest(i) - k 8 if Consistent(SubLabel(A, k), x, a,) S then ke k 1 1 else conflicting true 11 if not conflicting then return a, 12return null FIGURE 9.42 The algorithm Backjumping is like Backtracking, except that the procedure SelectValueGBJ tests for consistency with compound labels of increasing size. If at some stage the value being considered is not consistent with the label, it marks the index of the label as a possible culprit. We assume a function SubLabel that extracts a compound label of the first k variables from the partial solution being constructed. Gaschnig s approach to jumping back works only when a dead end is encountered during search, sometimes called a leaf dead end. It may be possible that when the algorithm jumps back to the culprit variable, it cannot find another value there as well. This situation is referred to as an internal dead end. But here the algorithm is compelled to do chronological backtracking. The reason for this is as follows. Let x, be the culprit variable that Backjumping has jumped back to. Now the fact that the al