e rule. The dotted notation x.y should be read as the y attribute of the unit x. The result of a successful Parse using this grammar will be either a command or a query. S what is FILE-PROPERTY of FILE? query FILE.FILE-PROPERTY} SK = | want to ACTION {command ACTION} FILE-PROPERTY the FILE-PROP FILE-PROP} FILE-PROP extension | protection | creation date | owner {value} FILE > FILE-NAME { FILE1 Value} FILE1 > USER s FILE2 {FILE2.owner: USER} FILE1 > FILE2 FILE2} FILE2 > EXT tile instance: file-struct extension: EXT} EXT init | .txt | .Isp | for 1.ps |.mss value ACTION print FILE {instance: printing object: FILE} ACTION - print FILE on PRINTER {instance: printing object: FILE printer: PRINTER} USER - Bill | Susan {value} Fig. 15.10 A Semantic Grammar A semantic grammar can be used by a parsing system in exactly the same ways in which a strictly syntactic grammar could be used. Several existing systems that have used semantic grammars have been built around an ATN parsing system, since it offers, a great deal of flexibility. Figure 15.11 shows the result of applying this semantic grammar to the sentence I want to print Bill s .init file. Notice that in this approach, we have combined into a single process ail five steps of Section 15.1.1 with the exception of the final part of pragmatic processing in which the conversion to the system s command syntax is done. The principal advantages of semantic grammars are the following: When the parse is complete, the result can be used immediately without the additional stage of processing that would be required if a semantic interpretation had not already been performed during the parse. 304 Artificial Intelligence CLERC EO EON EORET $s {command: {instance: printing object: {instance: file-struct extension: .init owner: Bill}}} ACTION {instance: printing abject: {instance: file-struct extension: init , owner: Bill}} re FILE1 {instance: file-struct extension: init owner: Bill} Jue {instance: file-struct extension: .init owner: Bil