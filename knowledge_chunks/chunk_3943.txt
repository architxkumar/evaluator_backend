gure 5.9(a) shows the results of that conversion. Figure 5.9(b) shows a resolution proof of the statement hate(Marcus, Caesar) 118 Artificial Intelligence Axioms in clause form: 1. man({Marcus) 2. Pompeian(Marcus} 3. -Pompeian(x,) \/ Roman(x,) 4, ruler Caesar) 5. =Roman(x.) \/ loyalto(x,,Caesar) \/ hate(x,,Caesar, 6. loyalto(xs,f Kx3}) 7. ~man(x,) \/ ~rulerly,) \/ >tryassassinate(x,, ,) VV loyalto(x,, 4) 8. tryassassinate( Marcus, Caesar) (a) Prove: hate (Marcus, Caesar) shate (Marcus, Caesar) 5 Marcus! x2 3 Roman (Marcus) \/ loyalto (Marcus, Caesar) Ne Marcus! x, ~Pompeian (Marcus) \/ loyaito (Marcus, Caesar) 2 a 7 loyalto (Marcus, Caesar) acs, Caesarly, 1 man (Marcus) \/ ruler (Caesar) \/ ~tryassassinate (Marcus, Caesar) NL ruler(Caesar) \/ tryassassinate (Marcus, Caesar) 4 Ne stryassassinate (Marcus, Caesar) (b) Fig. 5.9 A Resolution Proof 8 Of course, many more resolvents could have been generated than we have shown, but we used the heuristics described above to guide the search. Notice that what we have done here essentially is to reason backward from the statement we want to show is a contradiction through a set of intermediate conclusions to the final conclusion of inconsistency. Suppose our actual goal in proving the assertion hate(Marcus, Caesar} was to answer the question Did Marcus hate Caesar? In that case, we might just as easily have attempted to prove the statement shate(Marcus, Caesar) Using Predicate Logic 119 CECA ONDER SEO To do so, we would have added hate(Marcus, Caesar) to the set of available clauses and begun the resolution process. But immediately we notice that there are no clauses that contain a literal involving ~hate. Since the resolution process can only generate new clauses that are composed of combinations of literals from already existing clauses, we know that no such clause can be generated and thus we conclude that hate(Marcus, Caesar) will not produce a contradiction with the known statements. This is an example of the kind of sit